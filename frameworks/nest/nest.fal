/*
   FALCON - The Falcon Programming Language
   
   Nest - Falcon web applcation engine
   
   FILE: nest.fal

   Main file driving the engine.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Fri, 25 Jun 2010 10:52:46 +0200

   -------------------------------------------------------------------
   (C) Copyright 2010: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

import Config from self.config as Config
import NestError from self.error as NestError
import Service from self.service as Service
import ServiceVar from self.service as ServiceVar
import DataManager from self.datamanager as DataManager
import from self.utils

import from compiler

const _phase_startup = 0
const _phase_config = 1
const _phase_exec = 2
const _phase_render = 3

class BasicRouter
   function route( nestObject )
      return Request.getField("pid", "home")
   end

   function routingURI( baseUri, pid )
      return baseUri + "?pid=" + URI.encode( pid )
   end
end

class BasicFilter
   function filter()
      return Request.gets + Request.posts
   end
end

class BasicSessionManager

   _session = nil
   
   function restore()
      if Request.hasSession()
         try
            self._session = Request.getSession()
            if "_Nest" in self._session
               // we have a living session
               sd = self._session["_Nest"]
               se = false
            else
               // a new session was generated by getSession()
               sd = [=>]
               se = true
            end
         catch WopiError
            sd = [=>]
            se = true
         end
         
         return [sd, se]
      end
      
      // new and not expired
      return [ [=>], false]
   end
   
   function save( sessionData )
      if not Request.hasSession()
         self._session = Request.getSession()
      end

      self._session["_Nest"] = sessionData
   end
end


class BasicLogger( channel )
   channel = channel
   _ts = TimeStamp()
   
   function log( mode, caller, data )
      self._ts.currentTime()
      if caller.startsWith( "Method" )
         caller = caller[caller.find(".")+1:]
      end
      
      self.channel.writeText( self._ts.toString() + " " + mode + " " + caller + "\t" + data +"\n" )
   end
   
end

/*# Standard authorization levels.

   A lower authorization code means more priviledges.
*/
enum AuthLevel
   ADMIN = 0
   STAFF = 10
   USER = 20
   VISITOR = 30
   NONE = 100
end

/*#
   Just a reminder
   
   Nest structure:
   
   offline:
      nest/
         srv/
            ServiceName/
               ServiceName.fal
               config.fal 
               skins/
                  default.fal
                  ...
               res/
                  css
               j  s
         ...
         srv/
            ...
      
   online:
   
      site/
         nest/
            pages/
               ...
               
            srv/<name>/
               config.fal
               res/
                  css, js ...
               skins/
                  default.fal
                  ...
            res/
               css, js ...
            
            skins/
               askin.fal
               ...

   =========================================

   Nest phases:
   ------------
   1) Load configuration
   2) Page routing         
   3) Parameter evaluation/filter       <--> Nest.route()
   4) Service/provider registration     <--> Nest.service( ... ); Nest.dprovider( ... )
   5) Service run                       <--> Nest.display( 'service' )
   6) Session recording                 
   7) Page rendering                    <--> Nest.commit()
   
*/

object Nest
   //===================================================================
   // Public properties
   //===================================================================

   /*# Nest configuration.
   
      Manipulate this object (always an object of class @a Config) to change
      the behavior of nest.
   */
   config = Config

   /*# List of search paths for services */
   spath = nil

   /*# Page ID of the currently served page */
   pid = nil

   /*# Repeat the AuthLevel enumeration */
   AL = AuthLevel

   /*# For now, use the max authlevel by default. */
   auth_level = AuthLevel.ADMIN

   /*# Function called back after routing and before routed page execution.

      This is the ideal place to put code that must be always executed.

      Normally, database managers and login services are configured here.
   */
   
   onStartup = nil
   /*# Router.

      This object maps a raw web request into a page id.

      The property can be assigned by the user application to an arbitrary router,
      which is an object exposing a route() function.

      The function must return a page id (a string) if the router could determine
      where the request should be sent, or nil if the page ID cannot be determined.

      In this case, Nest raises an error and the execution terminates.

      The default router seeks a "pid" field first in the posts, then the gets fields
      of the Request. If the "pid" is not found, the router returns a "home" page id.
   */
   router = BasicRouter

   /*# Filter.
   
      Filters the content of the get and post values and stores them
      in the @a Nest.inputVars field as a dictionary pairs.

      Cookies and session data are used by Nest and provided to the application
      via the @a Nest.sessionData property. However, the application can access
      them separately (nest uses a "Nest" namespace to save its own variables
      in cookies or session data).

      The filter object must expose a "filter" function, that returns the
      dictionar function should return a dictionary of variables then saved
      in the inputVars field.
      
      The basic filter just stores all the gets and posts variables in the
      inputVars field.
   */
   filter = BasicFilter
   

   /*# List of active services.
   
      Usually not at the disposal of the user application.
   */
   services = [=>]

   /*# Dictionary of loaded data managers.

      Usually not at the disposal of the user application.
   */
   dms = [=>]
   
   /*# List of services that have performed rendering.
   
      Usually not at the disposal of the user application.
   */
   rendered = [=>]

   /*# Nest-specific session data.

      Contains data which must be retained across sessions.

      Services use it automatically, but it can be used also by
      the user application at will.
   */
   sessionData = [=>]

   /*# True when we detect the session data to be exipred.
   */
   sessionExpired = false

   /*# Manager for persistent variables.
      By default, it's pointing to a BasicSessionManager object,
      which implements the stanard WOPI session management.
   */
   sessionManager = BasicSessionManager()

   /*# Input variables as parsed and filtered.
   
      At the disposal of services and user applications.
   */
   inputVars = [=>]


   /*# Javascripts to be loaded in html headers */
   extscripts = []

   /*# Stylesheets to be loaded in html headers */
   stylesheets = []

   /*# Inline scripts to be put before body. */
   scripts = []

   /*# Inline scripts to be put before body. */
   styles = []

   /*# Basic logger */
   logger = nil

   /*# Debug mode? */
   debug = false

   /*# Log level.

      Can be:
      - 0: none
      - 1: warning
      - 2: info
      - 3: debug
   */
   log_level = 0
   
   //===================================================================
   // Private properties
   //===================================================================

   // Work Phase:
   // 0 - startup & routing
   // 1 - service & provider configuration
   // 2 - page executuion
   // 3 - rendering
   _phase = 0

   _comp = compiler.Compiler()

   // Used to send logs to output during debug.
   _debugStream = nil

   // Services in registration order
   _srvlist = []

   // dictionary of ambient variables
   _ambient = [=>]
   
   //===================================================================
   // Public interface
   //===================================================================

   init
      auth_level = ServiceVar( "Authorization level" )
      me = self  // use closing methods
      auth_level.listen( { v => me.auth_level = v == nil ? me.AL.NONE : v } )
      self._ambient["auth_level"] = auth_level
      self._defaultDirs()
      self._comp.launchAtLink = true
   end
   
   /*# Nest entry point.
   
      This method routes a web request down into the nest sytem.
   */

   function route()
      self.logi( "Routing started" )
      self._phase = _phase_startup
      // 1. Determine PID
      pid = self.router.route( self )

      if pid == nil
         // Todo: get the proper error.
         self.logw( "No route found" )
         self._manageError( NestError( NestError.no_route ), "" )
         if self.debug: self._displayDebug()
         return
      end
      
      // 2. Load variables
      self._loadSession()

      self.logi( "Filtering input variables" )
      self.inputVars = self.filter.filter( self )
      if self.log_level >= 3: self.logd( "Input vars: " + self.inputVars.describe() )

      // 3. Enter config phase
      self.pid = pid
      try
         self._startup()
      catch Error in e
         self._manageError(e)
         if self.debug: self._displayDebug()
         return
      end
      
      // 4. Read the page -- and load services
      self._phase = _phase_config
      self.selector( pid )
   end

   /*# Page selector.

      Call this function to get the main ID of the page to be displayed.

      This is the entry point of a Nest web application.
   */

   function selector( pid )
      if not pid: pid = "home"
      
      p = Path()
      p.fulloc = utils.reldir( self.config.homedir, self.config.pagedir )
      
      p.file = pid
      extfunc = .[
         .[ 'fal' self._selector_script ]
         .[ 'ftd' self._selector_script ]
         .[ 'fam' self._selector_script ]
         .[ 'html' self._selector_html ]
         .[ 'htm' self._selector_html ]
      ]

      // see if there is a file matching our page in the directory.
      for ext, func in extfunc
         p.extension = ext
         pagefile = p.path
         if fileType( pagefile ) == FileStat.NORMAL
            func( pagefile )
            return
         end
      end
      
      raise NestError( NestError.page_notfound, "", pid )
   end


   /*# Invoke a Data Manager. */
   function dm( name, inst, vars )
      cfg = self.config
      dm = self._instanceModule( "DataManager", name, inst, self.dms,
               // using a function instead of an array prevents array generation if not necessary
               { => [ cfg.nestdir + "/dm",
                  utils.reldir( cfg.homedir, cfg.site_dm_dir ) ] })

      if not ^? dm
         // here the trick of the function is useless, as we KNOW we have to configure this stuff
         self._configModule( dm, vars,
               [  utils.reldir( cfg.homedir, cfg.site_dm_dir + "/" + name ),
                  cfg.nestdir + "/dm/" + name ])
         self.dms[dm.fullName()] = dm
      end
      
      return ^- dm
   end

   /*# Invoke an ambient variable.
   
      Ambient variables are service variables which are immediately repeated to all the system.
   */
   function ambient( aname, descr, binding )
      if aname in self._ambient
         s = self._ambient[aname]
         if descr or binding: s.reinit( descr, binding )
      else
         s = ServiceVar( descr, binding )
         self._ambient[ aname ] = s
      end
      
      return s
   end

   /*# Invoke a service. */
   function service( name, inst, vars )
      cfg = self.config
      srv = self._instanceModule( "Service", name, inst, self.services,
               // using a function instead of an array prevents array generation if not necessary
               {=> [cfg.nestdir + "/srv",
                  utils.reldir( cfg.homedir, cfg.site_srv_dir ) ] })

      // srv is OOB'd if already registered.
      if not ^? srv
         // 1. Load service configuration

         // here the trick of the function is useless, as we KNOW we have to configure this stuff
         self._configModule( srv, vars,
               [  utils.reldir( cfg.homedir, cfg.site_srv_dir  + "/" + name ),
                  cfg.nestdir + "/srv/" + name ])

         // 2-N. Register the service, that is, configre its resources and prepare Nest to run it
         self._registerService( srv, vars )
      end
         
      return ^- srv
   end

   function _instanceModule( type, name, inst, regdict, locMaker )
      fullName = inst ? name + "." + inst : name
      self.logi( @"Invoked $(type) $(fullName)" )

      // already loaded?
      if fullName in regdict
         self.logi( @"$(type) $(fullName) already loaded; retuning existing instance." )
         // return an OOB item to specify it's already registered.
         return ^+ regdict[fullName]
      end
      
      // find the module
      srvdirs = locMaker()
      if self.log_level >= 3
         self.logd( @ "Searching $type $name in " + srvdirs.describe() )
      end
      
      srvfile = utils.findFileInDirs(
            srvdirs,
            name,
            ["fal", "fam"]
         )

      if srvfile
         if self.log_level >= 2
            self.logi( @"Found $type $name in " + srvfile )
         end
         
         mod = self._comp.loadFile( srvfile, name )
         try
            srvClass = mod.get( name )
         catch AccessError
            raise NestError( NestError.no_mod_class, "", name )
         end

         srv = srvClass( inst )
         srv.homedir = Path( srvfile )

      else
         raise NestError( NestError.mod_notfound, "", name )
      end
      
      return srv
   end


   /*# Runs all the loaded services.

      This method is implicitly called at first service.render, but it's possible
      to explicitly run it before.
   */
   function run()
      if self._phase > _phase_config: return
      self.logi( "Entering run phase" )
      
      for srv in self._srvlist
         self.logi( "Binding service " + srv.fullName() )
         srv.bind( self._onSessionVarChanged )
      end

      self._phase = _phase_exec
      
      for srv in self._srvlist
         self.logi( "Running service " + srv.fullName() )
         srv.run()
      end
   end


   /*# Produces nest automatic headings. */
   function headings()
      str = ""
      for item in self.extscripts
         str += @"<script type=\"text/javascript\" src=\"$item\"></script>\n"
      end

      for item in self.stylesheets
         str += @"<link rel=\"stylesheet\" type=\"text/css\" href=\"$item\"/>\n"
      end

      for item in self.styles
         str += "<style>\n" + item + "\n</style>\n"
      end

      for item in self.scripts
         str += "<script type=\"text/javascript\">\n" + item + "\n</script>\n"
      end
      
      return str
   end

   /*# Create a link to this page */
   function pageLink( pid, vars )
      return self.linkVars( self.router.routingURI( self.getURI(), pid ? pid : self.pid ), vars )
   end

   /*# Create a link to this page */
   function linkVars( link, vars )
      v = link

      if vars
         pos = v.find("?")
         if pos == -1
            v += "?"
         else
            if pos + 1 < v.len(): v += "&"
         end
         
         for key, value in vars
            v += URI.encode(key)
            if value != nil: v += "=" + URI.encode(value.toString())
            formiddle: v += "&"
         end
      end

      return v
   end

   function actionLink( pid, cmd, cmdField )
      v = self.router.routingURI( self.getURI(), pid ? pid : self.pid )
      if cmd
         if "?" notin v: v += "?"
         if not cmdField: cmdField = "cmd"
         v += URI.encode(cmdField) + "=" + URI.encode(cmd)
      end
      return v
   end


   function eidLink( pid, cmd, cmdField )
      v = self.actionLink( pid, cmd, cmdField )
      if "?" notin v: v += "?"
      return v + "&eid=$(eid)"
   end

   function getURI( scheme )
      if self.config.self_uri: return self.config.self_uri
      if not scheme: scheme = "http"
      try
         return scheme +"://" + Request.headers["Host"] + Request.location
      catch AccessError
         return "/"
      end
   end

   function formFields( vars )
      r = ""
      for key, value in vars
         key = URI.escape( key )
         value = URI.escape( value )
         r += @'<input type="hidden" name="$(key)" value="$(value)"/>'
      end
      return r
   end

   
   //=============================================================
   // Logging functions
   //=============================================================


   function logw( data )
      if self.log_level >= 1
         if not self.logger: self._initLogger()
         self.logger.log( "WARN", fself.caller().toString(), data )
      end
   end


   function logi( data )
      if self.log_level >= 2
         if not self.logger: self._initLogger()
         self.logger.log( "INFO", fself.caller().toString(), data )
      end
   end

   function logd( data )
      if self.log_level >= 3
         if not self.logger: self._initLogger()
         self.logger.log( "DBG ", fself.caller().toString(), data )
      end
   end
   
   //=============================================================
   // private part
   //=============================================================
   function _startup()
      if self.onStartup.isCallable()
         self.logd("Calling onStartup function" )
         self.onStartup()
      end
   end
   
   function _initLogger()
      if self.debug
         self._debugStream = StringStream()
         self.logger = BasicLogger( self._debugStream )
      else
         self.logger = BasicLogger( stdErr() )
      end
   end
   
   function _registerService( srv, vars )
      cnf = self.config

      // 2. determine online resources (and verify they're installed)
      self._checkOnlineRes( srv )
      
      // ... and just add inline styles and scripts
      self.styles += srv.styles
      self.scripts += srv.scripts

      // 3 - Find the skin file
      if srv.skin.value
         skinFile = srv.skin.value
         skinNeeded = true
      else
         skinFile = "default.fal"
         skinNeeded = false
      end

      self._scanForSkin( srv, skinFile, skinNeeded )

      // 4 - Register the service
      self._srvlist += srv
      self.services[ srv.fullName() ] = srv
      srv.startup()
   end

      

   // Service configuration step 2 -- Check online resources
   function _checkOnlineRes( srv )
      cnf = self.config
      
      if srv.extscripts or srv.stylesheets
         if fileType( utils.reldir( cnf.homedir, cnf.site_res_dir ) ) == FileStat.DIR
            onl_res_dir = cnf.site_res_dir
         elif fileType( utils.reldir( cnf.homedir, cnf.site_srv_dir + "/" + srv.name + "/res" ) ) == FileStat.DIR
            onl_res_dir = cnf.site_srv_dir + "/" + srv.name +"/res"
         else
            raise NestError( NestError.resloc, "", srv.name )
         end
      end
      
      missing_res = []
      for script in srv.extscripts
         sf = onl_res_dir + "/" + script
         if fileType( sf ) != FileStat.NORMAL
            missing_res += script
         else
            self.extscripts += sf
         end
      end
      
      for ss in srv.stylesheets
         ssf = onl_res_dir + "/" + ss
         if fileType( ssf ) != FileStat.NORMAL
            missing_res += ss
         else
            self.stylesheets += ssf
         end
      end

      if missing_res
         raise NestError( NestError.misres, "", 
               srv.name + ": " + ", ".merge( missing_res ) )
      end
   end

   
   // Service configuration step 3.1 -- load service specific config
   function _configModule( srv, vars, dirs )
      cnf = self.config

      lname = srv.className()
      debug = self.log_level >= 3

      if debug: self.logd( "Module \"" + lname + "\" searching config in " + dirs.describe() )
      cf1_data = self._loadConfig( dirs, "config" )
      if debug: self.logd( "Config variablers for " + lname + ": " + vars.describe() )

      // searching config in subdirs
      if srv.instance
         // search instance.fal under ./config
         ddet = map( {d=> d + "/config"}, dirs )
         if debug: self.logd( @"Module $(lname) searching cfg for \"$(srv.instance)\" in "+ ddet.describe() )
         cf2_data = self._loadConfig( ddet, srv.instance )
      end
      
      // Search in the main configuration
      sname = srv.fullName()
      if sname in cnf.mod_config
         cf3_data = cnf.mod_config[sname]
      end

      // Sum it up; priority is:
      // 1. Variables given at instantation
      // 2. Global configuration at index
      // 3. Instance configuration
      // 4. Module configuration
      
      if cf1_data or cf2_data or cf3_data or vars
         configData = [=>]
         for d in .[ cf1_data cf2_data cf3_data vars]
            if d: configData += d
         end
      end
      
      // Actually, the configuration is done in the bind step;
      // The Configuration binder uses the configuration field in the service
      if self.log_level >= 3
         self.logd( "Configuring module " + sname + ": " + configData.describe() )
      end
      srv.configure( configData )
   end

   
   // Service configuration step 3.1 -- load service specific config
   function _loadConfig( dirs, fname )
      confFile = utils.findFileInDirs( dirs, fname + ".fal" )

      if confFile
         if self.log_level >= 3
            self.logd( "Compiling config from " + confFile )
         end
         
         try
            cmp = compiler.Compiler()
            cmp.launchAtLink = true
            confMod = cmp.loadFile( confFile )
            vars = [=>]
            for var in confMod.globals()
               value = confMod.get( var )
               if value.isCallable() 
                  continue
               end
               vars[var] = value
            end

         catch in e
            raise NestError( NestError.econfig, "", e.toString() )
         end
      end
      
      return vars // will be nil if not loaded
   end

   // Service configuration step 4 - skin scan
   function _scanForSkin( srv, skinName, skinNeeded )
      cnf = self.config
      s_base_name = srv.className()
      
      skinPaths = []
      if skinNeeded
         // if needed (esplicit), search the skin in the global skin path
         skinPaths += utils.reldir( cnf.homedir, cnf.site_skins_dir )
      end

      skinPaths += [
            utils.reldir( cnf.homedir, cnf.site_srv_dir + "/" + s_base_name +  "/skins" ),
            cnf.nestdir +"/srv/" + s_base_name  + "/skins" ]
            
      if self.log_level >= 3
         self.logd( "Service " + s_base_name + " scanning for skin \"" + skinName + "\"" +
         (skinNeeded ? "(needed)" : "") +
         " in " + skinPaths.describe() )
      end
      
      skinFile = utils.findFileInDirs( skinPaths, skinName, ['fal','ftd','fam'] )
      if skinFile
         self.logi( "Service " + srv.fullName() + " using skin " + skinFile )
         srv.setSkinFile( skinFile )
      elif skinNeeded
         raise NestError( NestError.noskin, "", s_base_name + ": "+ skinName )
      end
   end
      
   function _selector_script( file )
      s = StringStream()
      old = stdOut( s )
      try
         include( file )
         for name, service in self.services
            service.finalize()
         end

         // save session data
         self._saveSession()

         // save an eventual error for later
      catch in e
      end

      // ... finally
      stdOut( old )
      ctx = s.closeToString()

      // do we have an error to manage?
      if e
         self._manageError( e, ctx )
      else
         >> ctx
      end

      if self.debug
         self._displayDebug()
      end

   end


   function _selector_html( file )
      f = InputStream( file )
      out = stdOut()
      r = ""
      while not f.eof()
         f.read( f, 4096 )
         out.write( r )
      end
      f.close()
   end

   function _onSessionVarChanged( sv, value )
      self.logd( @"Session var changed: $(sv)=$value" )
      self.sessionData[sv] = value
   end

   function _subconfig( varname )
      var = self.metaconfig.getOne( varname )
      if var: self.config.setProperty( varname, var )
   end

   function _defaultDirs()
      c = self.config
      if c.nestdir == nil: c.nestdir = Path(vmModulePath()).fulloc + "/nest"
   end

   function _manageError( e, ctx )      
      try
         // force excluding bindings
         self._phase = _phase_exec
         ereport = self.service( "ereport" )
         ereport.error.value = e
         ereport.context.value = ctx
         
         > ereport.render()
      catch in f
         self._defErrorReport( e, ctx, f )
      end
   end

   function _defErrorReport( e, ctx, f )
      > ctx
      > "=" * 66
      > "FATAL ERROR -- failed to load error report service, using default error reporting:"
      > e.toString()
      > "=" * 66
      > "Error in loading the error report service was:"
      > f.toString()
   end

   // Restore session data
   function _loadSession()
      self.logi( "Loading session data" )
      self.sessionData, self.sessionExpired = self.sessionManager.restore()
      if self.log_level >= 3: self.logd( "Session data: " + self.sessionData.describe() )
   end
   
   // save session data
   function _saveSession()
      if self.sessionData
         if self.log_level >= 3: self.logd( @"Saving session data: "+ self.sessionData.describe() )
         self.sessionManager.save( self.sessionData )
      end
   end

   // Display debug data
   function _displayDebug()
      if self._debugStream
         > "<hr/><h2>Debug log sent to client</h2><pre>"
         > htmlEscape(self._debugStream.closeToString())
         > "</pre>"
         > "<hr/>"
      end
   end
end

// Re-export relevant Nest elements
export Nest, Service, ServiceVar, NestError, DataManager
