/*
   FALCON - The Falcon Programming Language

   Nest - Falcon web applcation engine

   FILE: nest.fal

   Main file driving the engine.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Fri, 25 Jun 2010 10:52:46 +0200

   -------------------------------------------------------------------
   (C) Copyright 2010: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

const _version = "2.0"
directive lang = "en_US"

import NestError from self.error as NestError
import Hook from self.hook in hook_module
import from self.utils

import from compiler
import from json

const pages_dir = "pages"
const widget_dir = "widgets"
const hooks_dir = "hooks"
const ajax_dir = "ajax"
const mod_dir = "mod"
const res_dir = "res"

/*# Basic Nest router class.

   This class has the role of

   - determining what page ID is implied in the web request currently being served.
   - building an URI that will include the current page ID.
*/
class BasicRouter
   //# Returns the page ID implied in the current web request
   function route()
      return Request.getField("pid", "home")
   end

   //# Returns a string that may be used to reach the given page
   function routingURI( baseUri, pid )
      if not pid: pid = "home"
      return baseUri + "?pid=" + URI.encode( pid )
   end
end

/*# Basic Nest filter for input variables.
   This class is meant to provide Nest with input coming from
   the web requests.

   An instance of this class must be set as the @a Nest.filter
   property; Nest will call the @b filter method of the instance
   at proper time, and store its return value into @a Nest.inputVars.

   This base class just provides nest with the sum of Request.gets
   and Request.post dictionaries, effectively feeding all the standard
   input fields into @a Nest.inputVars.
*/

class BasicFilter
   //# Returns a dictionary of name/value variable pairs.
   function filter()
      return Request.gets + Request.posts
   end
end


/*# Nest basic session manager.

   Session managers have the role of providing Nest with persistent storage for
   variables related to a specific remote user connection, thus enabling the
   sateless-http requests to be seen as "sessions".

   The basic session manager uses the WOPI session system as a backend for
   persistent storage. More sophisticated application-specific session managers
   may be written to store sessions on serialized files, databases, memory
   mapped files and so on.
*/
class BasicSessionManager

   _session = nil

   /*# Restores a previously existing session.
      @return a pair of session data + session status.

      The function returns an array of two values; the first one is the
      dictionary of session variables and their own values. The second is
      true if the session expired.

      A new empty session is represented by the return values [ [=>], false],
      while an expired session will be returned as [ [=>], true].
   */
   function restore()
      if Request.hasSession()
         try
            self._session = Request.getSession()
            if "_Nest" in self._session
               // we have a living session
               sd = self._session["_Nest"]
               se = false
            else
               // a new session was generated by getSession()
               sd = [=>]
               se = true
            end
         catch WopiError
            sd = [=>]
            se = true
         end

         return [sd, se]
      end

      // new and not expired
      return [ [=>], false]
   end

   /*# Saves the session data.
      @param sessionData Dictionary of session variables with their values to be saved.
   */
   function save( sessionData )
      if not Request.hasSession()
         self._session = Request.getSession()
         
      end
      //inspect( Reply )
      self._session["_Nest"] = sessionData
   end

end


/*# Basic Nest Logger.
   @param channel a Stream where to send the log information.
   Logger class is used to render nest log information to.

   The basic logger writes its output to a given stream.
*/
class BasicLogger( channel )
   channel = channel
   _ts = TimeStamp()

   function log( mode, caller, data )
      self._ts.currentTime()
      if caller.startsWith( "Method" )
         caller = caller[caller.find(".")+1:]
      end

      self.channel.writeText( self._ts.toString() + " " + mode + " " + caller + "\t" + data +"\n" )
   end

end

/*# Standard authorization levels.

   A lower authorization code means more priviledges.
*/
enum AuthLevel
   ADMIN = 0
   STAFF = 10
   USER = 20
   VISITOR = 30
   NONE = 100
end

/*# Nest application framework.

   This object represents the core of the Nest system.
   It is mean to be part of the web application loading it,
   so it should be loaded with the directive

   @code
   load nest
   @endcode
*/
object Nest
   //===================================================================
   // Public properties
   //===================================================================

   /*# Nest application directory for current site.

      It's relative to the entrypoint script, and defaults to "./nest".
   */
   site_nest_dir = "./nest"

   /*# Home of the nest installed hierarcy.

      It defaults to vmModulePath(), which is the path from where Falcon loaded this Nest module.
   */
   nest_dir = nil

   /*# URI of the entry point script.

      If set to nil, in case of need the URI of the entry point script will be determined
      through the Request fields.
   */
   self_uri = nil

   /*# Page ID of the currently served page */
   pid = nil

   /*# Repeat the AuthLevel enumeration */
   AL = AuthLevel

   /*# For now, use the max authlevel by default. */
   auth_level = AuthLevel.ADMIN

   /*# User that has logged in */
   auth_user = nil
   
   /*# Arbitrary data for logged in entity */
   auth_data = nil

   /*# Name of the module used for error reporting.

      Nest uses the Module.render() method of a dynamic Nest
      module to report errors that have happened during the routing
      of a page. The error module delegated to show the error to
      the user is "ErrorReport" by default, but it can be changed,
      even dynamically, so to provide context-sensible errors.
   */
   ereport_module = "ErrorReport"
   
   /*# Router.

      This object maps a raw web request into a page id.

      The property can be assigned by the user application to an arbitrary router,
      which is an object exposing a route() function.

      The function must return a page id (a string) if the router could determine
      where the request should be sent, or nil if the page ID cannot be determined.

      In this case, Nest raises an error and the execution terminates.

      The default router seeks a "pid" field first in the posts, then the gets fields
      of the Request. If the "pid" is not found, the router returns a "home" page id.
   */
   router = BasicRouter

   /*# Filter for input variables (POST or GET key/value pairs).

      Filters the content of the get and post values and stores them
      in the @a Nest.inputVars field as a dictionary pairs.

      Cookies and session data are used by Nest and provided to the application
      via the @a Nest.sessionData property. However, the application can access
      them separately (nest uses a "Nest" namespace to save its own variables
      in cookies or session data).

      The filter object must expose a "filter" function, that returns the
      dictionar function should return a dictionary of variables then saved
      in the inputVars field.

      The basic (default) filter just stores all the GET and POST variables in the
      inputVars field (post variables having higer priority).
   */
   filter = BasicFilter

   /*# Nest-specific session data.

      Contains data which must be retained across sessions.

      Services use it automatically, but it can be used also by
      the user application at will.
   */
   sessionData = [=>]

   /*# True when we detect the session data to be exipred.
   */
   sessionExpired = false

   /*# Manager for persistent variables.
      By default, it's pointing to a BasicSessionManager object,
      which implements the stanard WOPI session management.
   */
   sessionManager = BasicSessionManager()

   /*# Input variables as parsed and filtered.

      At the disposal of services and user applications.
   */
   inputVars = [=>]


   /*# Javascripts to be loaded in html headers */
   extscripts = []

   /*# Stylesheets to be loaded in html headers */
   stylesheets = []

   /*# Inline scripts to be put before body. */
   scripts = []

   /*# Inline CSS texts to be put before body. */
   styles = []

   /*# Javascript functions to be executed after all the widgets inits */
   onLoad = []

   /*# Title for the page.
      This will be renedered as \<title>\<?=Nest.title?>\</title> when
      Nest.headings are called.
   */
   title = nil

   /*# Basic logger */
   logger = nil

   /*# Debug mode? */
   debug = false

   //# Instructs the modules to perform checks on service parameters. False by default.
   pcheck = false

   /*# Framing.

      When the @b frame property is set to a function,
      then Nest will load the page that the routing system
      required and render it separately. The output of the
      rendered page will be retrieved through the @a Nest.content
      method; then, the function stored in @b frame will be
      called, and it will just need to print @a Nest.content variable
      at the desired position.

      Interesting functions can be:
      @code
      Nest.frame = .[ include "some_file" ]
      Nest.frame = .[ include Nest.pageLink("pid-of-frame") ]
      @endcode

      The function should produce an output that will be captured by Nest
      and then rendered.
   */
   frame = nil

   /*# Log level.

      Can be:
      - 0: none
      - 1: warning
      - 2: info
      - 3: debug
   */
   log_level = 0

   //# If true, widget declared @b css properties are rendered in-line
   genWidgetStyles = true
   
   //===================================================================
   // Private properties
   //===================================================================

   _comp = compiler.Compiler()

   // Used to send logs to output during debug.
   _debugStream = nil

   // Function registered to be execued at startup.
   _startupFunctions = nil
   
   // dictionary of ambient variables
   _ambient = [=>]

   // Content set later on during the page work
   _delayedSlices = [=>]

   // Rendered content of the page, each being a strtring or a function to be called back.
   _contentSlices = nil
   _contentProvider = nil

   // Current stream where the page is generating its output
   _pageStream = nil

   _jsComponents =  [
      "base" => "nest.js",
      "fx" => "nest_fx.js"
   ]

   // widgets subscribed for rendering.
   _widgets = nil

   // Styles to be applied by class
   _classStyles = [=>]

   // Hook functions invoked by direct emit("...") requests
   _hooks = [=>]

   // Modules
   _modules = [=>]

   _menus = [=>]
   _menu_registar = [=>]

   //===================================================================
   // Public interface
   //===================================================================

   init
      self.nest_dir = Path(vmModulePath()).fulloc + "/nest"
      self._comp.launchAtLink = true
      self._comp.sourceEncoding = 'utf-8'
   end

   /*# Nest entry point.
      @optparam pid If given, force the entry point skipping the router.

      This method routes a web request down into the nest sytem.
   */

   function route( pid )
      self.logi( "Routing started" )
      // 1. Determine PID
      if not pid
         if (rid = Request.getField( "r", nil ) )
            self.logi( "Selecting resource " + rid )
            self.selector_resource( rid )
            return
         end
         
         aid = Request.getField( "a", nil )
         wid = Request.getField( "w", nil )
         if not aid and not wid
            pid = self.router.route( self )
         end
      end

      if pid == nil and aid == nil and wid == nil
         // Todo: get the proper error.
         self.logw( "No route found" )
         self._manageError( NestError( NestError.no_route ), "" )
         if self.debug: self._displayDebug()
         return
      end
      self.pid = pid

      // 2. Load variables
      self._loadSession()

      self.logi( "Filtering input variables" )
      self.inputVars = self.filter.filter( self )
      if self.log_level >= 3: self.logd( "Input vars: " + self.inputVars.describe() )

      // 3. Enter config phase
      try
         self._startup()
      catch Error in e
         self._manageError(e)
         if self.debug: self._displayDebug()
         return
      end

      // 4. Read the pages
      if pid
         self.selector( pid )
      elif aid
         self.selector_ajax( aid )
      else
         self.selector_ajax_widget( wid )
      end

   end

   /*# Nest redirect function.
      @param url An URL or Page ID where to redirect the page.
      @optparam values A dictionary of values to be added to the page id.
      
      This method kills the current processing of the Nest page,
      and invokes WOPI Reply.redirect request. The redirection
      request will be sent as an HTTP header, and all the parts
      of the document generated up to date will be discarded.

      @note If URL begins with a "!", then is inteded as a nest PID. 
   */
   function redirect( url, values )
      if url.startsWith('!')
         url = self.pageLink(url[1:], values)         
      end

      Reply.redirect(url)
      Reply.commit()
      exit(0)
   end

   /*# Adds a startup function.
      @param func a function that must be invoked at startup.
      
      This is the ideal place to put code that must be always executed.
      Normally, database managers and login services are configured here.
   */
   function addStartup( func )
      if self._startupFunctions == nil
         self._startupFunctions = [func]
      else
         self._startupFunctions += func
      end
   end

   /*# AJAX function selector.
      @param aid The ID of the AJAX function or widget.
      @optparam method A method for an AJAX widget.

   */
   function selector_ajax( aid )
      ajax_file = utils.findFileInDirs(
            [self.site_nest_dir + "/" +  ajax_dir, self.nest_dir + "/" +  ajax_dir ],
            aid,
            ["fal", "fam"]
         )

      if( ajax_file )
         self._selector_ajax( aid, ajax_file )
      else
         raise NestError( NestError.page_notfound, "", aid )
      end
   end

   /** Selects a resource */
   function selector_resource( rid )
      if self.log_level >= 3: self.logd( "Checking resourece for RID: " + rid )
      dirs = [self.site_nest_dir + "/" +  res_dir, self.nest_dir + "/" + res_dir ]
      res_file = utils.findFileInDirs(
            dirs,
            rid
         )

      if( res_file )         
         // shall we really send it?
         if utils.checkModifiedSince( res_file ): return
            
         if res_file[-3:] == ".js"
            Reply.ctype( "application","javascript" )
            text = true
         elif ( ext = res_file[-4:] ) == ".png"
            Reply.ctype( "image","png" )
         elif ext == ".jpg"
            Reply.ctype( "image","jpg" )
         elif ext == ".gif"
            Reply.ctype( "image","gif" )
         else
            Reply.ctype( "octect","stream" )
         end

         Reply.setHeader( "Content-disposition", @"inline; filename=\"$(rid)\"" )
         Reply.setHeader( "Cache-Control", "public,max-age=0" )
         Reply.setHeader( "Pragma" )
         stdOut().write( readURI( res_file, text ? "utf-8" : "C" ) )
      else
         utils.exitReply( 404, "File not found", "The request " + Request.uri +
                        " is pointing to a resource that couldn't be found")
      end
   end
   
   /*# Page function or method selector.

      Call this function to get the main ID of the page to be displayed.

      This is the entry point of a Nest web application.
   */

   function selector( pid )
      if not pid: pid = "home"

      p = Path()
      p.fulloc = self.site_nest_dir + "/" + pages_dir

      p.file = pid
      extfunc = .[
         .[ 'fal' self._selector_script ]
         .[ 'ftd' self._selector_script ]
         .[ 'fam' self._selector_script ]
         .[ 'html' self._selector_html ]
         .[ 'htm' self._selector_html ]
      ]

      // see if there is a file matching our page in the directory.
      for ext, func in extfunc
         p.extension = ext
         pagefile = p.path
         if fileType( pagefile ) == FileStat.NORMAL
            func( pagefile )
            return
         end
      end

      raise NestError( NestError.page_notfound, "", pid )
   end


   /*# Declare a user.
      @param uid An identifier for the logged in user.
      @param level An authentication level.
      @param data Extra data that is to be associated to the user.
      @optparam save If true, automatically save the parameters to the session.
      
      This method advertises the fact that the remote browsing entity
      has been recognized as a user.

      If the @b param save is true, the auth_user, auth_level and auth_data are
      automatically stored in the session data (and then, automatically retrieved
      when the session is re-accessed). Notice that doing so might cause secuirity
      breaches or be plainly impossible if the auth_data variable is containing
      data that cannot be stored to the session. In general, it's better to
      re-authorize the remote user on the base of partially negotiated session 
      information.
   */

   function loggedIn( uid, level, data, save )
      self.auth_user = uid
      self.auth_level = level
      self.auth_data = data
      if save
         self.sessionData["auth_user"] = uid
         self.sessionData["auth_level"] = level
         self.sessionData["auth_data"] = data
      end         
   end

   /*# Invoke an ambient variable.

      Ambient variables are service variables which are immediately repeated to all the system.
   */
   function ambient( aname, val )
      if aname in self._ambient
         s = self._ambient[aname]
      elif val != nil
         s = val
         self._ambient[aname] = s
      end

      return s
   end

   /*# Invoke a widget class
      @param name The logical name of the widget class to be invoked.
      @return A @a Widget class.

      Theoretically, the widget may be located anywhere it can be reached
      via import/load and then just intantiated; but this might make hard to
      impossible to create project-specific widget overrides or may require to
      dirty the code-out-of-site model of Nest. So, this method is just a facility
      to load the desired class as a Nest aware plug-in.

      The widget file must contain a class named exactly as the file (extension
      excluded), which is the class that will be returned by this method.
   */
   function widget( name )
      wid = self._internal_module( name, widget_dir );
      if not wid: raise NestError( NestError.mod_notfound, "", name )
      return wid
   end


   /*# Invoke a module.
      @param name The logical name of the module class to be invoked.
      @return A @a Module instance.

      A @a nest.Module class instance is a dynamic plugin that can be loaded
      on demand when necessary. This method is actually a simple helper
      that searches for the module in standard "mod" directories.

      If already loaded, the previously created instance is returned.

      When loaded, a [modname]_cfg.fal file is searched in the modules directory
      as well. If found, it is loaded and each global variable in the _cfg
      module is set in a pseoudo-object that is then passed to the
      onConfig() methdod of the module instance.
   */
   function module( name )
      if name in self._modules
         return self._modules[name]
      end
      
      modc = self._internal_module( name, mod_dir );
      if not modc: raise NestError( NestError.mod_notfound, "", name )
      mod = modc()
      self.loadConfig( mod )
      self._modules[name] = mod
      
      return mod
   end

   /*# Loads a module class without creating an instance.
      @param name The logical name of the module class to be invoked.
      @return A @a Module class.
      
   */
   function moduleClass( name )
      modc = self._internal_module( name, mod_dir );
      if not modc: raise NestError( NestError.mod_notfound, "", name )
      return modc
   end

   function loadConfig( entity, name )
      modName = entity.className()
      if name: modName += "_" + name
      modName += "_cfg"

      w_file = utils.findFileInDirs(
            .[
               self.site_nest_dir + "/" +  mod_dir
               self.site_nest_dir + "/" +  widget_dir
               self.nest_dir + "/" + mod_dir
               self.nest_dir + "/" + widget_dir
            ],
            modName,
            ["fal", "fam"]
         )

      if( w_file )
         // by default, launchAtLink is true.
        try
            privAlias = modName + "-" + random(1,1000000)
            self._comp.launchAtLink = true
            confMod = self._comp.loadFile( w_file, privAlias )
            vars = [=>]
            for var in confMod.globals()
               value = confMod.get( var )
               if var.startsWith("_")
                  continue
               end
               vars[var] = value
            end

            entity.onConfig( bless(vars) )
         catch in e
            nerr = NestError( NestError.econfig, "" )
            nerr.boxed = e
            raise nerr
         end
         
      else
         self.logi( "Configuration module not found " + modName )
         if name
            raise NestError( NestError.config_notfound, "", modName )
         end
         // else, we simply didn't want any configuration
      end
   end
   
   function subscribeWidget( widget )
      if not self._widgets: self._widgets = []
      self._widgets += widget
   end

   function selector_ajax_widget( wid )
      widgetClass = self.widget( wid )

      try
         // init the widget.
         params =  Request.getField( "params", nil )
         if params: params = json.JSONdecode( params )
         if params and "init" in params
            initfunc = [widgetClass] + params["init"]
            widget = initfunc()
         else
            widget = widgetClass()
         end

         // Execute the method.
         if not widget provides AJAX
            ctx = [ "error"=>"-4",
                  "errorDesc"=>"Widget is not exposing the AJAX entry point: " + wid]
         else
            ctx = widget.AJAX( params )
            if typeId( ctx ) != DictionaryType and typeId( ctx ) != ArrayType
               ctx = [  "error"=>"-2",
                        "errorDesc"=>"AJAX function \"" + wid + ".AJAX\" didn't return a dicitonary"
                        ]
            end
         end
         
         self._saveSession()
      catch in e
         ctx = [ "error"=>"-3",
                  "errorDesc"=>"Uncaught error: " + e.toString() ]
      end

      // Ok send the output
      >> json.JSONencode(ctx)

      if self.debug
         self._displayDebug()
      end
   end


   /*# Produces nest automatic headings. */
   function headings()
      Nest.logi( "Placing render mark for headers" )
      // save the rendering up to date
      self._contentSlices += self._pageStream.closeToString()
      // prepare for later rendering at this point
      self._contentSlices += self._render_headings
      // generate a new stream for the rest of the page.
      self._pageStream = StringStream()
      stdOut( self._pageStream )
   end

   function _render_headings()
      str = ""

      if self.title
         str += @"<title>$(self.title)</title>\n"
      end

      for item in self.extscripts
         str += @"<script type=\"text/javascript\" src=\"$item\"></script>\n"
      end

      for item in self.stylesheets
         str += @"<link rel=\"stylesheet\" type=\"text/css\" href=\"$item\"/>\n"
      end

      for item in self.styles
         str += "<style>\n" + item + "\n</style>\n"
      end

      for item in self.scripts
         str += "<script type=\"text/javascript\">\n" + item + "\n</script>\n"
      end

      // Eventually write the page-specific styles
      if self._widgets and self.genWidgetStyles
         self.logi( "Rendering widgets styles" )

         // first to all the setup...
         styles = ""
         classCSS = [=>]
         empty = [=>]
         for item in self._widgets
            // first, the CSS per item
            self.logi( "Rendering styles for widget " + item.id )
            
            if item.idStyles
               item_id =  "#" + strReplace( item.getFullID(), ".", "\\." )
               styles += self._makeCSSforID( item_id, item.idStyles, item )
            end

            //then the CSS for the classes
            classStyles = item.pickClassStyles( self._classStyles )
            if classStyles
               id = item.CSSClassID()
               if id notin classCSS
                  styles += self._makeCSSforID( "." + id, classStyles, item )
                  classCSS[id] = 1
               end
            end
         end
         if styles
            str += "<style type=\"text/css\">\n" + styles + "</style>\n"
         end
      end
      
      return str
   end
   
   /*# Create a link to this or another page.
      @optparam pid The pageID of the desired page; leave nil to use the current pid.
      @optparam vars A dictionary of variables to be passed to the given page.

   */
   function pageLink( pid, vars )
      return self.linkVars( self.router.routingURI( self.getURI(), pid ? pid : self.pid ), vars )
   end

   /*# Create a link to an ajax function.
      @param ajax The name of the Ajax function.
      @optparam vars A dictionary of variables to be passed to the given function.

   */
   function ajaxLink( ajax, vars )
      return self.linkVars( self.getURI() + "?a=" + ajax, vars )
   end
   
   /*# Create a link to an internal resource file.
      @param rid Name of the resource to be served.
   */
   function resLink( rid )
      return self.getURI() + "?r=" + rid
   end

   /*# Create a link to this page */
   function linkVars( link, vars )
      base = v = nil        // Base: the address, v: existing params
      d = [ => ]

      l = link.split("?")
      base = l[0]

      if l.len() > 1: v = l[1].trim()

      if v

         parms = strSplit( v, "&")

         for param in parms
            name, value = param.split( "=" )
            d[name] = value
         end

      end

      if vars
         for key, value in vars: \
            d[ URI.encode(key) ]  = ^? value ? value:URI.encode(value.toString())
      end

      v = ""

      for key, value in d

         if not value: continue

         v += key + "=" + value

         forfirst
            v = "?" + v
         end

         formiddle
            v += "&"
         end
      end

      return base + v

   end

   function actionLink( pid, cmd, cmdField )
      v = self.router.routingURI( self.getURI(), pid ? pid : self.pid )
      if cmd
         if "?" notin v: v += "?"
         if not cmdField: cmdField = "cmd"
         v += URI.encode(cmdField) + "=" + URI.encode(cmd)
      end
      return v
   end


   function eidLink( pid, cmd, cmdField )
      v = self.actionLink( pid, cmd, cmdField )
      if "?" notin v
         v += "?"
      else
         v += "&"
      end
      return v + "eid=$(eid)"
   end

   /*# Returns the URI confgiured for this site.
      If the site has been configured with an explicit callback uri, it is returned,
      otherwise the URI of the entry point script is determined looking at the Request
      WOPI fields.
   */
   function getURI( scheme )
      if self.self_uri: return self.self_uri
      if not scheme: scheme = "http"
      try
         return scheme +"://" + Request.headers["Host"] + Request.location
      catch AccessError
         return "/"
      end
   end

    /*# Calls a hook.
      @param The name of a previously registered hook
      @optparam ...

      Calls a previously registered @a Hook instance.
      The hook function should return an oob value to signal that the
      message has been handled, and stop from further propagation.
   */
   function emit( name )
      self.logi( "Calling hook " + name )
      if name in self._hooks
         hook = self._hooks[name]
      else
         // try to load the hook
         mod = self._internal_module( name, hooks_dir )
         if mod
            hook = mod()
            self._hooks[name] = hook
         end
      end

      if hook
         ret = passvp( hook.invoke )
         self.logd( "Hook " + name + " returned  " + ret.describe() )
      else
         self.logw( "Can't find hook " + name )
      end
      return ret
   end


   /*# Invoke the content of a frame page.
      @raise NestError if not invoked from a frame function, or if called more than once.

      If called inside a frame function, this will cause the routed page to be
      copied verbatim at the required position.

      @note The function returns nothing, so nothing should be printed out of it.
      The content page is simply copied verbatim in place of this declaration.
   */
   function content()
      if not self._contentProvider
         NestError( NestError.not_in_frame, "" )
      end

      // save the rendering up to date
      self._contentSlices += self._pageStream.closeToString()
      // generate a new stream for the rest of the page.
      self._pageStream = StringStream()
      stdOut( self._pageStream )

      // includes the content page and proceeds with the rest of the framing.
      self._contentProvider()
      self._contentSlices += self._pageStream.closeToString()
      self._pageStream = StringStream()
      stdOut( self._pageStream )

      // also, make sure this can't be done anymore
      self._contentProvider = nil
   end

   /*# Defers a text or a function.
      @param id A text ID for a later definition, or a function to be called later on.

      This methods places in the current position of the currently processed page a
      text that will be determined later on.

      The text to be displayed in this position can be set, either before or after
      this call, through the @a Nest.dtext method.

      The @b id parameter can be a function; in that case, it will be called
      during the page render step, and its return value will be placed in the
      current page position.

      @note If @a Next.dtext is never called to define the value of the required
      text @b id, then this call is ignored, and nothing is displayed in its place.
   */
   function defer( id )
      // save the rendering up to date
      self._contentSlices += self._pageStream.closeToString()
      if id.isCallable()
         self._contentSlices += id
      else
         dl = self._delayedSlices
         self._contentSlices += {=> if id in dl: return dl[id]; return "" }
      end
      // generate a new stream for the rest of the page.
      self._pageStream = StringStream()
      stdOut( self._pageStream )
   end

   /*# Sets a deferred text value.
      @param id The id of the text.
      @param text The text that should be rendered on the place where
                   the @a Nest.defer method is invoked.

      This method specifies what text should be rendered on the place where
      a placeholder has been left through the @a Nest.defer call.
   */
   function dtext( id, text )
      self._delayedSlices[id] = text
   end

   /*# Checks for the current page to be accessible, and eventually loads an alternate page.
      @param level The authorization level required to access this resource.
      @param pid_on_failure The Page ID of a resource to be loaded instead of this page.
      @return True if the current page is authorized, false if it's not allowed.

      This method should be called as the very first method of the routed page (or eventually
      of the routed frame, if the frame is security-sensible.

      The caller may simply use the returned value to switch into a security-insensible
      code branch, or it may provide a PID of a resource to be loaded in place of the currently
      processed page. In this latter case, the caller should return immediately, as nest will have
      routed the required resource.

      For example, home.ftd may look like

      @code
      <?
         import from ...

         if not Nest.allowed( Nest.AL.USER, "unauthorized" ): return
         ...
      ?>
      <h1>Welcome user</h1>
      <p>sensible things here...</p>
      ,,,
      @endcode

      and unauthorized.ftd may simply be a warning message:
      @code
      <h1>Unauthorized</h1>
      <p>Sorry, you shouldn't be here...</p>
      @endcode

   */
   function allowed( level, pid_on_failure )
      if self.auth_level <= level: return true
      if pid_on_failure
         self.selector( pid_on_failure )
      end
      return false
   end

   /** Remotely loads a standard javascript in the Nest environment */
   function requireJS( component )
      self.logi( "Requiring JS component " + component )
      jsc = self._jsComponents
      if component notin jsc
         raise NestError( NestError.jscomponent_notfound, "", component )
      end

      fname = jsc[ component ]
      if fname
         fname =  self.resLink( fname )
         self.logd( "Loading JS component " + fname )
         self.extscripts += fname
         jsc[ component ] = nil
      end
      // else it was already loaded.
   end
   
   /*# Gets version/subversion of the Nest system.
       @return A version string in format major.minor
   */
   function getVersion()
      return _version
   end

   /*# Register a menu item for dynamic menu instantation.
      @param menuName The socket (public) name of the menu where the item is to be registered.
      @param menuItem The item to be registered.

      This method allows to dynamically create new menu items when/if a target menu is created.
   */
   function registerMenuItem( menuName, menuItem )
      if menuName in self._menus
         self._menus[menuName].addChild( menuItem )
      else
         if menuName notin self.menu_registar
            self._menu_registar = [menuItem]
         else
            self._menu_registar += menuItem
         end
      end
   end

   /*# Registers a public menu.
      This method is automatically called by the menu class during its initialization process. 
   */
   function registerMenu( menu )
      if menu.socket in self._menu_registar
         for item in self._menu_registar[menu.socket]
            menu.addChild( item )
         end
      end
      self._menus[ menu.socket ] = menu
   end
      
   
   //=============================================================
   // Style functions
   //=============================================================

   function addClassStyle( wcls, style )
      if not self.genWidgetStyles
         self.logd( "Skipping style \"" + style.name
            + "\" as widget style generation is not active" )
         return
      end

      self.logd( "Adding style \"" + style.name + "\" on class " + wcls )
      dict = self._classStyles
      if wcls in dict
         dict[wcls] += style
      else
         dict[wcls] = [style]
      end
   end

   function getClassStyles( cls )
      if cls in self._classStyles: return self._classStyles[cls]
   end

   function hasOneOfClassStyles( classes )
      for cls in classes
         if cls in self._classStyles: return true
      end
      return false
   end
   
   //=============================================================
   // Logging functions
   //=============================================================


   function logw( data )
      if self.log_level >= 1
         if not self.logger: self._initLogger()
         self.logger.log( "WARN", fself.caller().toString(), data )
      end
   end


   function logi( data )
      if self.log_level >= 2
         if not self.logger: self._initLogger()
         self.logger.log( "INFO", fself.caller().toString(), data )
      end
   end

   function logd( data )
      if self.log_level >= 3
         if not self.logger: self._initLogger()
         self.logger.log( "DBG ", fself.caller().toString(), data )
      end
   end

   //=============================================================
   // private part
   //=============================================================
   function _startup()
      self.logd("Calling onStartup functions" )
      for func in self._startupFunctions
         func()
      end
   end


   function _initLogger()
      if self.debug
         self._debugStream = StringStream()
         self.logger = BasicLogger( self._debugStream )
      else
         self.logger = BasicLogger( stdErr() )
      end
   end

   function _internal_module( name, dir )
      w_file = utils.findFileInDirs(
            [self.site_nest_dir + "/" +  dir, self.nest_dir + "/" + dir ],
            name,
            ["fal", "fam"]
         )

      if( w_file )
         // by default, launchAtLink is true.
         page = self._comp.loadFile( w_file )
         widget = page.get(name)
         if typeId( widget ) != ClassType
            raise NestError( NestError.no_mod_class, "", name )
         end

         return widget
      else
         return nil
      end
   end


   function _selector_script( file )
      // prepare the output stream
      self._pageStream = StringStream()
      old = stdOut( self._pageStream )

      // prepare the content slices
      self._contentSlices = []

      try
         self._comp.launchAtLink = false
         page = self._comp.loadFile( file )
         self._comp.launchAtLink = true
         main = page.get("__main__")

         // should the page be framed?
         if self.frame.isCallable()
            attrs = page.attributes()
            if "nest_frame" in attrs and not attrs["nest_frame"]
              main()
            else
               self._contentProvider = main
               self.frame()
            end
         else
            main()
         end

         // render the slices requiring rendering.
         self._renderSlices()

         // render the closeScripts
         self._renderClosingScript()
         self._renderOnLoad()
         
         // generate the (last) content slice
         self._contentSlices += self._pageStream.closeToString()

         // save an eventual error for later
         self._saveSession()
      catch in e
      end
      
      
      // Return to standard output
      stdOut( old )
      // Save what we have achieved up to date.
      ctx = self._packSlices()

      // do we have an error to manage?
      if e
         self._manageError( e, ctx )
      else
         // Ok send the output
         >> ctx
      end

      if self.debug
         self._displayDebug()
      end
   end

   function _renderSlices()
      self.logi( "Rendering data slices" )

      i = 0
      cs = self._contentSlices
      slen = cs.len()
      while i < slen
         mth = cs[i]
         if mth.isCallable()
            if self.log_level >= 3: self.logd( "Calling slice " + mth )
            cs[i] = mth()
         end
         ++i
      end
   end

   function _renderClosingScript()
      if self._widgets
         self.logi( "Rendering widgets setup scripts" )

         onCreate = []
         str = "<script language=\"javascript\">\n/* Nest: Widgets initialization. */\n" +
                          "(function(){ var element;\n"
         // first to all the setup...
         for item in self._widgets
            if item.prototype != 0  // skip protos
               value = item.setup()
               if value: str += value

               if item.onCreate
                  onCreate += item
               end
            end
         end

         str += "}());\n"
         // then eventually invoke the onCreate script.
         for item in onCreate
            forfirst: str+= "\n/* Nest: Execution of onCreate requests. */\n(function(){\n"
            str += "Nest.i('" + item.getFullID() + "').onCreate();\n"
            forlast: str+= "}());\n"
         end

         str += "\n</script>\n"
         
         self._contentSlices += str
      end
   end

   function _renderOnLoad()
      if self.onLoad
         self.logi( "Rendering onLoad script requests" )
          str = "<script language=\"javascript\">\n/* Nest: explicit onLoad requests. */\n"
         for item in self.onLoad
            str += item + ";\n"
         end

         str += "\n</script>\n"
         self._contentSlices += str
      end
   end

   function _packSlices()
      self.logi( "Packing data slices" )

      str = ""
      for s in self._contentSlices
         str += s
      end
      return str
   end
   

   function _selector_html( file )
      f = InputStream( file )
      out = stdOut()
      r = ""
      while not f.eof()
         f.read( r, 4096 )
         out.write( r )
      end
      f.close()
   end


   function _selector_ajax( aid, file )
      try
         // by default, launchAtLink is true.
         page = self._comp.loadFile( file )
         ajax = page.get(aid)
         if not ajax.isCallable()
            ctx = [  "error"=>"-1",
                     "errorDesc"=>"Module \"" + file + "\" is not defining '"+aid+"' as function." ]
         else
            // parameters are in Request.getField
            params = Request.getField( "params", nil )
            if params and params != "{}": params = json.JSONdecode( params )
            ctx = ajax( params )
            if typeId( ctx ) != DictionaryType
               ctx = [  "error"=>"-2",
                        "errorDesc"=>"AJAX function \"" + file + "\" didn't return a dicitonary" ]
            end
         end

         self._saveSession()
      catch in e
         ctx = [ "error"=>"-3",
                  "errorDesc"=>"Uncaught error: " + e.toString()+ "\nDATA: " + params ]
      end

      // Ok send the output
      >> json.JSONencode(ctx)

      if self.debug
         self._displayDebug()
      end
   end


   function _onSessionVarChanged( sv, value )
      self.logd( @"Session var changed: $(sv)=$value" )
      self.sessionData[sv] = value
   end


   function _manageError( e, ctx )
      try
         // force excluding bindings
         self.title = "Nest Framework Error"
         ereport = self.moduleClass( self.ereport_module )( e, ctx )
         self.loadConfig( ereport )
         > ereport.render()
      catch in f
         self._defErrorReport( e, ctx, f )
      end
   end

   function _defErrorReport( e, ctx, f )
      > ctx
      > "=" * 66
      > "FATAL ERROR -- failed to load error report service, using default error reporting:"
      > e.toString()
      > "=" * 66
      > "Error in loading the error report service was:"
      > f.toString()
   end

   // Restore session data
   function _loadSession()
      self.logi( "Loading session data" )
      self.sessionData, self.sessionExpired = self.sessionManager.restore()
      if self.log_level >= 3: self.logd( "Session data: " + self.sessionData.describe() )
   end

   // save session data
   function _saveSession()
      if self.sessionData
         if self.log_level >= 3: self.logd( "Saving session data: "+ self.sessionData.describe() )
         self.sessionManager.save( self.sessionData )
      end
   end

   // Display debug data
   function _displayDebug()
      if self._debugStream
         > "<hr/><h2>Debug log sent to client</h2><pre>"
         > htmlEscape(self._debugStream.closeToString())
         > "</pre>"
         > "<hr/>"
      end
   end

   
   function _makeCSSforID( cssid, styles, item )     
      results = [=>]
      id = strReplace(item.getFullID(), ".", "\\.")
      for style in styles
         full_id = style.mode ? (cssid + ":" + style.mode) : cssid
         if style.spec
            if style.spec.typeId() == ArrayType
               newid = ",".merge(map({v=> full_id+" " + v}, style.spec))
               full_id = newid
            else
               full_id += " " + style.spec
            end
         end
         
         if full_id in results
            res_by_id = results[full_id]
            if style notin res_by_id: res_by_id += style
         else
            results[full_id] = [style]
         end
         
      end

      result = ""
      for k,v in results
         singleCSS = ""
         for style in v
            singleCSS += style.css
            if not singleCSS.endsWith(";"): singleCSS += ";"
         end
         
         result += @k + " {\n" + singleCSS + "}\n"
      end
      
      return result
   end

   
end

// Re-export relevant Nest elements
export Nest, NestError
