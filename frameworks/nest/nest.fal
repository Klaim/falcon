/*
   FALCON - The Falcon Programming Language
   
   Nest - Falcon web applcation engine
   
   FILE: nest.fal

   Main file driving the engine.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Fri, 25 Jun 2010 10:52:46 +0200

   -------------------------------------------------------------------
   (C) Copyright 2010: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

import NestError from self.error as NestError
import Service from self.service as Service
import ServiceVar from self.service as ServiceVar
import DBIDataManager from self.dbidm as DBIDataManager
import DataManager from self.datamanager as DataManager
import Hook from self.hook in hook_module 
import from self.utils

import from compiler

const _phase_startup = 0
const _phase_config = 1
const _phase_exec = 2
const _phase_render = 3

const pages_dir = "pages"
const srv_dir = "srv"
const dm_dir = "dm"
const hooks_dir = "hooks"
//const res_dir = "res"

/*# Basic Nest router class.

   This class has the role of

   - determining what page ID is implied in the web request currently being served.
   - building an URI that will include the current page ID.
*/
class BasicRouter
   //# Returns the page ID implied in the current web request
   function route()
      return Request.getField("pid", "home")
   end

   //# Returns a string that may be used to reach the given page
   function routingURI( baseUri, pid )
      return baseUri + "?pid=" + URI.encode( pid )
   end
end

/*# Basic Nest filter for input variables.
   This class is meant to provide Nest with input coming from
   the web requests.

   An instance of this class must be set as the @a Nest.filter
   property; Nest will call the @b filter method of the instance
   at proper time, and store its return value into @a Nest.inputVars.

   This base class just provides nest with the sum of Request.gets
   and Request.post dictionaries, effectively feeding all the standard
   input fields into @a Nest.inputVars.
*/

class BasicFilter
   //# Returns a dictionary of name/value variable pairs.
   function filter()
      return Request.gets + Request.posts
   end
end


/*# Nest basic session manager.

   Session managers have the role of providing Nest with persistent storage for
   variables related to a specific remote user connection, thus enabling the
   sateless-http requests to be seen as "sessions".

   The basic session manager uses the WOPI session system as a backend for
   persistent storage. More sophisticated application-specific session managers
   may be written to store sessions on serialized files, databases, memory
   mapped files and so on.
*/
class BasicSessionManager

   _session = nil

   /*# Restores a previously existing session.
      @return a pair of session data + session status.

      The function returns an array of two values; the first one is the
      dictionary of session variables and their own values. The second is
      true if the session expired.

      A new empty session is represented by the return values [ [=>], false],
      while an expired session will be returned as [ [=>], true].
   */
   function restore()
      if Request.hasSession()
         try
            self._session = Request.getSession()
            if "_Nest" in self._session
               // we have a living session
               sd = self._session["_Nest"]
               se = false
            else
               // a new session was generated by getSession()
               sd = [=>]
               se = true
            end
         catch WopiError
            sd = [=>]
            se = true
         end
         
         return [sd, se]
      end
      
      // new and not expired
      return [ [=>], false]
   end

   /*# Saves the session data.
      @param sessionData Dictionary of session variables with their values to be saved.
   */
   function save( sessionData )
      if not Request.hasSession()
         self._session = Request.getSession()
      end

      self._session["_Nest"] = sessionData
   end
end


/*# Basic Nest Logger.
   @param channel a Stream where to send the log information.
   Logger class is used to render nest log information to.

   The basic logger writes its output to a given stream.
*/
class BasicLogger( channel )
   channel = channel
   _ts = TimeStamp()
   
   function log( mode, caller, data )
      self._ts.currentTime()
      if caller.startsWith( "Method" )
         caller = caller[caller.find(".")+1:]
      end
      
      self.channel.writeText( self._ts.toString() + " " + mode + " " + caller + "\t" + data +"\n" )
   end
   
end

/*# Standard authorization levels.

   A lower authorization code means more priviledges.
*/
enum AuthLevel
   ADMIN = 0
   STAFF = 10
   USER = 20
   VISITOR = 30
   NONE = 100
end


/*# Standard authorization levels.

   A lower authorization code means more priviledges.
*/
enum Priority
   STARTUP = 0
   HIGH = 10
   NORMAL = 20
   LOW = 30
   LOWEST = 40
end

/*# Nest application framework.

   This object represents the core of the Nest system.
   It is mean to be part of the web application loading it,
   so it should be loaded with the directive

   @code
   load nest
   @endcode
*/
object Nest
   //===================================================================
   // Public properties
   //===================================================================
   
   /*# Nest application directory for current site.

      It's relative to the entrypoint script, and defaults to "./nest".
   */
   site_nest_dir = "./nest"

   /*# Home of the nest installed hierarcy.
   
      It defaults to vmModulePath(), which is the path from where Falcon loaded this Nest module.
   */
   nest_dir = nil

   /*# URI of the entry point script.
      
      If set to nil, in case of need the URI of the centry point script will be determined
      through the Request fields.
   */
   self_uri = nil
   
   /*# Page ID of the currently served page */
   pid = nil

   /*# Repeat the AuthLevel enumeration */
   AL = AuthLevel

   /*# Repeat the Priority enumeration */
   PRIO = Priority
   
   /*# Repeat data managers.
      An enumeration with the following values
      - DBI = DBIDataManager class
   */
   DM = bless( [
      "DBI" => DBIDataManager
      ])

   //# Repeat the hook class
   Hook = hook_module.Hook

   /*# For now, use the max authlevel by default. */
   auth_level = AuthLevel.ADMIN

   /*# Function called back after routing and before routed page execution.

      This is the ideal place to put code that must be always executed.

      Normally, database managers and login services are configured here.
   */
   
   onStartup = nil
   /*# Router.

      This object maps a raw web request into a page id.

      The property can be assigned by the user application to an arbitrary router,
      which is an object exposing a route() function.

      The function must return a page id (a string) if the router could determine
      where the request should be sent, or nil if the page ID cannot be determined.

      In this case, Nest raises an error and the execution terminates.

      The default router seeks a "pid" field first in the posts, then the gets fields
      of the Request. If the "pid" is not found, the router returns a "home" page id.
   */
   router = BasicRouter

   /*# Filter for input variables (POST or GET key/value pairs).
   
      Filters the content of the get and post values and stores them
      in the @a Nest.inputVars field as a dictionary pairs.

      Cookies and session data are used by Nest and provided to the application
      via the @a Nest.sessionData property. However, the application can access
      them separately (nest uses a "Nest" namespace to save its own variables
      in cookies or session data).

      The filter object must expose a "filter" function, that returns the
      dictionar function should return a dictionary of variables then saved
      in the inputVars field.
      
      The basic (default) filter just stores all the GET and POST variables in the
      inputVars field (post variables having higer priority).
   */
   filter = BasicFilter
   

   /*# List of active services.
   
      Usually not at the disposal of the user application.
   */
   services = [=>]

   /*# Nest-specific session data.

      Contains data which must be retained across sessions.

      Services use it automatically, but it can be used also by
      the user application at will.
   */
   sessionData = [=>]

   /*# True when we detect the session data to be exipred.
   */
   sessionExpired = false

   /*# Manager for persistent variables.
      By default, it's pointing to a BasicSessionManager object,
      which implements the stanard WOPI session management.
   */
   sessionManager = BasicSessionManager()

   /*# Input variables as parsed and filtered.
   
      At the disposal of services and user applications.
   */
   inputVars = [=>]


   /*# Javascripts to be loaded in html headers */
   extscripts = []

   /*# Stylesheets to be loaded in html headers */
   stylesheets = []

   /*# Inline scripts to be put before body. */
   scripts = []

   /*# Inline scripts to be put before body. */
   styles = []

   /*# Title for the page.
      This will be renedered as \<title>\<?=Nest.title?>\</title> when
      Nest.headings are called.
   */
   title = nil

   /*# Basic logger */
   logger = nil

   /*# Debug mode? */
   debug = false
   
   //# Instructs the modules to perform checks on service parameters. False by default.
   pcheck = false

   /*# Framing.
   
      When the @b frame property is set to a function,
      then Nest will load the page that the routing system
      required and render it separately. The output of the
      rendered page will be retrieved through the @a Nest.content
      method; then, the function stored in @b frame will be
      called, and it will just need to print @a Nest.content variable 
      at the desired position.

      Interesting functions can be:
      @code
      Nest.frame = .[ include "some_file" ]
      Nest.frame = .[ include Nest.pageLink("pid-of-frame") ]
      @endcode

      The function should produce an output that will be captured by Nest
      and then rendered.
   */
   frame = nil      
	
   /*# Log level.

      Can be:
      - 0: none
      - 1: warning
      - 2: info
      - 3: debug
   */
   log_level = 0
   
   
   //===================================================================
   // Private properties
   //===================================================================

   // Work Phase:
   // 0 - startup & routing
   // 1 - service & provider configuration
   // 2 - page executuion
   // 3 - rendering
   _phase = 0

   _comp = compiler.Compiler()

   // Used to send logs to output during debug.
   _debugStream = nil

   // Services in registration order
   _srvlist = []

   // dictionary of ambient variables
   _ambient = [=>]

   // dictionary of function hooks
   _hooks = [=>]
   
   // dictionary of data managers
   _dms = [=>]

   // Rendered content of the page, each being a strtring or a function to be called back.
   _contentSlices = nil
   _contentFile = nil

   // Current stream where the page is generating its output
   _pageStream = nil

   
   //===================================================================
   // Public interface
   //===================================================================

   init
      self.nest_dir = Path(vmModulePath()).fulloc + "/nest"
      auth_level = ServiceVar( "Authorization level" )
      me = self  // use closing methods
      auth_level.listen( { v => me.auth_level = v == nil ? me.AL.NONE : v } )
      self._ambient["auth_level"] = auth_level
      self._comp.launchAtLink = true
   end
   
   /*# Nest entry point.
   
      This method routes a web request down into the nest sytem.
   */

   function route()
      self.logi( "Routing started" )
      self._phase = _phase_startup
      // 1. Determine PID
      pid = self.router.route( self )

      if pid == nil
         // Todo: get the proper error.
         self.logw( "No route found" )
         self._manageError( NestError( NestError.no_route ), "" )
         if self.debug: self._displayDebug()
         return
      end
      
      // 2. Load variables
      self._loadSession()

      self.logi( "Filtering input variables" )
      self.inputVars = self.filter.filter( self )
      if self.log_level >= 3: self.logd( "Input vars: " + self.inputVars.describe() )

      // 3. Enter config phase
      self.pid = pid
      try
         self._startup()
      catch Error in e
         self._manageError(e)
         if self.debug: self._displayDebug()
         return
      end
      
      // 4. Read the page -- and load services
      self._phase = _phase_config
      self.selector( pid )
   end

   /*# Page selector.

      Call this function to get the main ID of the page to be displayed.

      This is the entry point of a Nest web application.
   */

   function selector( pid )
      if not pid: pid = "home"
      
      p = Path()
      p.fulloc = self.site_nest_dir + "/" + pages_dir
      
      p.file = pid
      extfunc = .[
         .[ 'fal' self._selector_script ]
         .[ 'ftd' self._selector_script ]
         .[ 'fam' self._selector_script ]
         .[ 'html' self._selector_html ]
         .[ 'htm' self._selector_html ]
      ]

      // see if there is a file matching our page in the directory.
      for ext, func in extfunc
         p.extension = ext
         pagefile = p.path
         if fileType( pagefile ) == FileStat.NORMAL
            func( pagefile )
            return
         end
      end
      
      raise NestError( NestError.page_notfound, "", pid )
   end


   /*# Invoke a Data Manager.
      @param name The name of the data manager to be invoked.
      @optparam config Dictionary of variables to be used as configuration.

      The "type" key must be specified either in the @b config
      parameter or in the file named after dm/**<name>**.fal, and must
      contain a Nest class (i.e. DBIDataManager)

      All the entities relative to this Data Manager name. For example,
      they are named like dm/<name>/**<entity_name.fal>**.
      
   */
   function dm( name, config )
      if name in self._dms
         // Return it oob if already registered.
         return ^+ self._dms[ name ]
      end
      
      // here the trick of the function is useless, as we KNOW we have to configure this stuff
      dirs = [ self.site_nest_dir + "/" + dm_dir ]
      if self.log_level >= 3: self.logd( @"DM $(name) searching config in " + dirs.describe() )
      vars = self._loadConfig( dirs, name )
      
      // Let the config parameter have an higher priority
      if not vars
         vars = config
      elif config
         vars += config
      end
      
      // Ok, see if we have a type entry
      if "type" notin vars
         raise NestError( NestError.no_dm_type, "", name )
      end
      
      sClass = vars["type"]
      if not sClass.derivedFrom( DataManager )
         raise NestError( NestError.wrong_dm_type, "", name )
      end
      
      dm = sClass( name, self.site_nest_dir + "/" + dm_dir + "/" + name )
      dm.configure( vars )
      self._dms[ name ] = dm
      return dm
   end

   /*# Invoke an ambient variable.
   
      Ambient variables are service variables which are immediately repeated to all the system.
   */
   function ambient( aname, binding )
      if aname in self._ambient
         s = self._ambient[aname]
         if binding: s.reinit( binding )
      else
         s = ServiceVar( binding )
         self._ambient[ aname ] = s
      end
      
      return s
   end

   /*# Invoke a service.
      @param name The logical name of the service to be invoked.
      @optparam inst The instance name for the service.
      @optparam vars A dictionary of configuration key/values pairs.
      @return A @a Service instance.
      
   */
   function service( name, inst, vars )
      nestDir = self.nest_dir
      siteNestDir = self.site_nest_dir
      srv = self._instanceModule( "Service", name, inst, self.services,
               // using a function instead of an array prevents array generation if not necessary
               {=> [ nestDir + "/" + srv_dir,
                  siteNestDir + "/" + srv_dir] })

      // srv is OOB'd if already registered.
      if not ^? srv
         // 1. Load service configuration
         dirs = self.getServiceDirs( name, inst )
         
         // here the trick of the function is useless, as we KNOW we have to configure this stuff
         self._configModule( srv, vars, dirs)

         // 2. Register the service, that is, configre its resources and prepare Nest to run it
         self._registerService( srv )

         // 3. Binding the service
         self.logi( "Binding service " + srv.fullName() )
         srv.bind( self._onSessionVarChanged )

         self.logi( "Calling startup on service " + srv.fullName() )
         srv.startup()
      end

      //TODO: should we de-oob?
      //return ^- srv
      return srv
   end


   
   /*# Produces nest automatic headings. */
   function headings()
      Nest.logi( "Placing render mark for headers" )
      // save the rendering up to date
      self._contentSlices += self._pageStream.closeToString()
      // prepare for later rendering at this point
      self._contentSlices += self._render_headings
      // generate a new stream for the rest of the page.
      self._pageStream = StringStream()
      stdOut( self._pageStream )
   end
   
   function _render_headings()
      str = ""

      if self.title
         str += @"<title>$(self.title)</title>\n"
      end
      
      for item in self.extscripts
         str += @"<script type=\"text/javascript\" src=\"$item\"></script>\n"
      end

      for item in self.stylesheets
         str += @"<link rel=\"stylesheet\" type=\"text/css\" href=\"$item\"/>\n"
      end

      for item in self.styles
         str += "<style>\n" + item + "\n</style>\n"
      end

      for item in self.scripts
         str += "<script type=\"text/javascript\">\n" + item + "\n</script>\n"
      end
      
      return str
   end

   /*# Create a link to this page */
   function pageLink( pid, vars )
      return self.linkVars( self.router.routingURI( self.getURI(), pid ? pid : self.pid ), vars )
   end

   /*# Create a link to this page */
   function linkVars( link, vars )
      v = link

      if vars
         pos = v.find("?")
         if pos == -1
            v += "?"
         else
            if pos + 1 < v.len(): v += "&"
         end
         
         for key, value in vars
            v += URI.encode(key)
            if value != nil: v += "=" + URI.encode(value.toString())
            formiddle: v += "&"
         end
      end

      return v
   end

   function actionLink( pid, cmd, cmdField )
      v = self.router.routingURI( self.getURI(), pid ? pid : self.pid )
      if cmd
         if "?" notin v: v += "?"
         if not cmdField: cmdField = "cmd"
         v += URI.encode(cmdField) + "=" + URI.encode(cmd)
      end
      return v
   end


   function eidLink( pid, cmd, cmdField )
      v = self.actionLink( pid, cmd, cmdField )
      if "?" notin v: v += "?"
      return v + "&eid=$(eid)"
   end

   /*# Returns the URI confgiured for this site.
      If the site has been configured with an explicit callback uri, it is returned,
      otherwise the URI of the entry point script is determined looking at the Request
      WOPI fields.
   */
   function getURI( scheme )
      if self.self_uri: return self.self_uri
      if not scheme: scheme = "http"
      try
         return scheme +"://" + Request.headers["Host"] + Request.location
      catch AccessError
         return "/"
      end
   end

   function formFields( vars )
      r = ""
      for key, value in vars
         key = URI.escape( key )
         value = URI.escape( value )
         r += @'<input type="hidden" name="$(key)" value="$(value)"/>'
      end
      return r
   end

   /*# Adds a callback hook
      @param hook An instance of @a Hook class.
      @optparam before if true, this hook will be processed before the others.
   */
   function addHook( hook, before )
      if hook.typeId() == StringType
         return self.loadHook( hook, nil, before )
      end

      Nest.logi( "Registering hook on " + hook.name )
      if hook.name in self._hooks
         if before
            self._hooks[0:0] = hook
         else
            self._hooks[hook.name] += hook
         end
      else
         self._hooks[hook.name] = [hook]
      end

      return hook
   end

   /*# Loads a callback hook and configures it.
      @param name The logical name of the callback hook.
      @optparam vars Configuration variables to be passed to the hook.
      @optparam before if true, the hook will take priority over existing ones.
      
   */
   function loadHook( name, vars, before )
      Nest.logi( "Loading hook " + name )

      nestDir = self.nest_dir
      siteNestDir = self.site_nest_dir
      
      hook = self._instanceModule( "Hook", name, nil, nil,
               // using a function instead of an array prevents array generation if not necessary
               {=> [ nestDir + "/" + hooks_dir,
                      siteNestDir + "/" + hooks_dir ] })

      dirs = [ self.site_nest_dir + "/" + hooks_dir  + "/" + name,
               self.nest_dir + "/" + hooks_dir + "/" + name ]
               
      self.logd( "Hook \"" + name + "\" searching config in " + dirs.describe() )
      cf1_data = self._loadConfig( dirs, "config" )
      self.logd( "Config variablers for " + name + ": " + vars.describe() )

      if vars
         if cf1_data: cf1_data += vars
      end
      
      if cf1_data: hook.configure( cf1_data )
      Nest.logi( "Hook " + name + " of type " + hook.name + " being registered." )
      // as the first parameter is now a hook instance, everything will go fine.
      return self.addHook( hook, before )
   end

    /*# Calls a hook.      
      @param The name of a previously registered hook
      @optparam ...

      Calls a previously registered @a Hook instance.
      The hook function should return an oob value to signal that the
      message has been handled, and stop from further propagation.
   */
   function emit( name )
      if name in self._hooks
         self.logi( "Calling hook " + name )
         for hook in self._hooks[name]
            ret = passvp( hook.func )
            if ^? ret
               break
            end
         end

         self.logd( "Hook " + name + " reutrned  " + ret.describe() )
         return ^- ret
      else
         self.logw( "Can't find hook " + name )
      end
   end


   /*# Renders the given service at this point in page.
      @param service the service to be rendered.

      Actually, the rendering is postponed up to the end of the page processing.
      Then, the @a Service.perform_render callback is invoked, and its output
      placed at this position in page
   */
   function renderService( service )
      Nest.logi( "Placing render mark for service " + service.fullName() )
      // save the rendering up to date
      self._contentSlices += self._pageStream.closeToString()
      // prepare for later rendering at this point
      self._contentSlices += service.perform_render
      // generate a new stream for the rest of the page.
      self._pageStream = StringStream()
      stdOut( self._pageStream )
   end

   /*# Invoke the content of a frame page.
      @raise NestError if not invoked from a frame function, or if called more than once.

      If called inside a frame function, this will cause the routed page to be
      copied verbatim at the required position.

      @note The function returns nothing, so nothing should be printed out of it.
      The content page is simply copied verbatim in place of this declaration.
   */
   function content()
      if not self._contentFile
         NestError( NestError.not_in_frame, "" )
      end
      
      // save the rendering up to date
      self._contentSlices += self._pageStream.closeToString()
      // generate a new stream for the rest of the page.
      self._pageStream = StringStream()
      stdOut( self._pageStream )
      
      // includes the content page and proceeds with the rest of the framing.
      include( self._contentFile )
      self._contentSlices += self._pageStream.closeToString()
      self._pageStream = StringStream()
      stdOut( self._pageStream )
      
      // also, make sure this can't be done anymore
      self._contentFile = nil
   end
   
   /*# Compile a class having the same name of the host module.
   	
   	This method automatically loads a module and returns a class
   	having the same name of the loaded module.
   	
   	This kind of scheme is used in several cases in the Nest
   	scheme, for example in the DB entities.
   */
   function compileClass( location, name )
      alias = name + "-" + random(1,1000000)
      mod = self._comp.loadFile( location, alias )
      try
         srvClass = mod.get( name )
      catch AccessError
         raise NestError( NestError.no_mod_class, "", name )
      end
      return srvClass
   end

   /*# Returns the standard directories to be searched for a service-related file.
      @param name The service name
      @optparam inst The service instance
   */

   function getServiceDirs( name, inst )
      
      dirs = [  self.site_nest_dir + "/" + srv_dir  + "/" + name,
                  self.nest_dir + "/" + srv_dir  + "/" + name ]
      if inst
         dirs = [ self.site_nest_dir + "/" + srv_dir  + "/" + name + "/" + inst
               ] + dirs
      end
      
      return dirs
   end

   /*# Checks for the current page to be accessible, and eventually loads an alternate page.
      @param level The authorization level required to access this resource.
      @param pid_on_failure The Page ID of a resource to be loaded instead of this page.
      @return True if the current page is authorized, false if it's not allowed.

      This method should be called as the very first method of the routed page (or eventually
      of the routed frame, if the frame is security-sensible.

      The caller may simply use the returned value to switch into a security-insensible
      code branch, or it may provide a PID of a resource to be loaded in place of the currently
      processed page. In this latter case, the caller should return immediately, as nest will have
      routed the required resource.

      For example, home.ftd may look like

      @code
      <?
         import from ...

         if not Nest.allowed( Nest.AL.USER, "unauthorized" ): return
         ...
      ?>
      <h1>Welcome user</h1>
      <p>sensible things here...</p>
      ,,,
      @endcode

      and unauthorized.ftd may simply be a warning message:
      @code
      <h1>Unauthorized</h1>
      <p>Sorry, you shouldn't be here...</p>
      @endcode
      
   */
   function allowed( level, pid_on_failure )
      if self.auth_level <= level: return true
      if pid_on_failure
         self.selector( pid_on_failure )
      end
      return false
   end
   
   //=============================================================
   // Logging functions
   //=============================================================


   function logw( data )
      if self.log_level >= 1
         if not self.logger: self._initLogger()
         self.logger.log( "WARN", fself.caller().toString(), data )
      end
   end


   function logi( data )
      if self.log_level >= 2
         if not self.logger: self._initLogger()
         self.logger.log( "INFO", fself.caller().toString(), data )
      end
   end

   function logd( data )
      if self.log_level >= 3
         if not self.logger: self._initLogger()
         self.logger.log( "DBG ", fself.caller().toString(), data )
      end
   end
   
   //=============================================================
   // private part
   //=============================================================
   function _startup()
      if self.onStartup.isCallable()
         self.logd("Calling onStartup function" )
         self.onStartup()
      end
   end

   
   function _initLogger()
      if self.debug
         self._debugStream = StringStream()
         self.logger = BasicLogger( self._debugStream )
      else
         self.logger = BasicLogger( stdErr() )
      end
   end

   
   function _registerService( srv )
      // 1. determine online resources (and verify they're installed)
      //self._checkOnlineRes( srv )
      
      // ... and just add inline styles and scripts
      self.styles += srv.styles
      self.scripts += srv.scripts

      // 2 - Register the service
      self._srvlist += srv
      self.services[ srv.fullName() ] = srv
   end


   function _instanceModule( type, name, inst, regdict, locMaker )
      fullName = inst ? name + "." + inst : name
      self.logi( @"Invoked $(type) $(fullName)" )

      // already loaded?
      if fullName in regdict
         self.logi( @"$(type) $(fullName) already loaded; retuning existing instance." )
         // return an OOB item to specify it's already registered.
         return ^+ regdict[fullName]
      end

      // find the module
      srvdirs = locMaker()
      if self.log_level >= 3
         self.logd( @ "Searching $type $name in " + srvdirs.describe() )
      end

      srvfile = utils.findFileInDirs(
            srvdirs,
            name,
            ["fal", "fam"]
         )

      if srvfile
         if self.log_level >= 2
            self.logi( @"Found $type $name in $srvfile" )
         end

         srvClass = self.compileClass( srvfile, name )
         srv = srvClass( inst )
         srv.homedir = Path( srvfile )

      else
         raise NestError( NestError.mod_notfound, "", name )
      end

      return srv
   end


   // Service configuration step 2 -- Check online resources
   /*
   function _checkOnlineRes( srv )
      
      if srv.extscripts or srv.stylesheets
         if fileType( utils.reldir( cnf.homedir, cnf.site_res_dir ) ) == FileStat.DIR
            onl_res_dir = cnf.site_res_dir
         elif fileType( utils.reldir( cnf.homedir, cnf.site_srv_dir + "/" + srv.name + "/res" ) ) == FileStat.DIR
            onl_res_dir = cnf.site_srv_dir + "/" + srv.name +"/res"
         else
            raise NestError( NestError.resloc, "", srv.name )
         end
      end
      
      missing_res = []
      for script in srv.extscripts
         sf = onl_res_dir + "/" + script
         if fileType( sf ) != FileStat.NORMAL
            missing_res += script
         else
            self.extscripts += sf
         end
      end
      
      for ss in srv.stylesheets
         ssf = onl_res_dir + "/" + ss
         if fileType( ssf ) != FileStat.NORMAL
            missing_res += ss
         else
            self.stylesheets += ssf
         end
      end

      if missing_res
         raise NestError( NestError.misres, "", 
               srv.name + ": " + ", ".merge( missing_res ) )
      end
   end
   */

   
   // Service configuration step 3.1 -- load service specific config
   function _configModule( srv, vars, dirs )
      lname = srv.className()
      debug = self.log_level >= 3

      if debug: self.logd( @"Module $(lname) searching cfg for \"$(srv.instance)\" in "+ dirs.describe() )
      cf1_data = self._loadConfig( dirs, "config" )
      if debug: self.logd( "Config variablers for " + lname + ": " + vars.describe() )
      
      // Search in the main configuration
      sname = srv.fullName()

      // Sum it up; priority is:
      // 1. Variables given at instantation
      // 2. Global configuration at index
      // 3. Instance configuration
      // 4. Module configuration
      
      if cf1_data or vars
         configData = [=>]
         for d in .[ cf1_data vars]
            if d: configData += d
         end
      end
      
      // Actually, the configuration is done in the bind step;
      // The Configuration binder uses the configuration field in the service
      if self.log_level >= 3
         self.logd( "Configuring module " + sname + ": " + configData.describe() )
      end
      srv.configure( configData )
   end

   
   // Service configuration step 3.1 -- load service specific config
   function _loadConfig( dirs, fname )
      confFile = utils.findFileInDirs( dirs, fname + ".fal" )

      if confFile
         if self.log_level >= 3: self.logd( "Compiling config from " + confFile )
         
         try
            privAlias = fname + "-" + random(1,1000000)
            confMod = self._comp.loadFile( confFile, privAlias )
            vars = [=>]
            for var in confMod.globals()
               value = confMod.get( var )
               if var.startsWith("_")
                  continue
               end
               vars[var] = value
            end

         catch in e
            nerr = NestError( NestError.econfig, "" )
            nerr.boxed = e
            raise nerr
         end
         
         if self.log_level >= 3: self.logd( @"In $(fname), found variables "+ vars.describe() )
      else
         self.logi( @"Couldn't find $(fname)" )
      end
      
      return vars // will be nil if not loaded
   end
      
   function _selector_script( file )
      // prepare the output stream
      self._pageStream = StringStream()
      old = stdOut( self._pageStream )

      // prepare the content slices
      self._contentSlices = []
      
      try
         // should the page be framed?
         if self.frame.isCallable()
            self._contentFile = file
            self.frame()
         else
            include( file )
         end
         
         // ok, we can run the services
         self._runServices()

         // render the slices requiring rendering.
         self._renderSlices()

         // finalize services
         self._finalizeServices()

         // save session data
         self._saveSession()

         // generate the (last) content slice
         self._contentSlices += self._pageStream.closeToString()

         // save an eventual error for later
      catch in e
      end

      // Return to standard output
      stdOut( old )
      // Save what we have achieved up to date.
      ctx = self._packSlices()
         
      // do we have an error to manage?
      if e
         self._manageError( e, ctx )
      else
         // Ok send the output
         >> ctx
      end

      if self.debug
         self._displayDebug()
      end
   end

   function _runServices()
      if self._phase > _phase_config: return
      self.logi( "Entering run phase" )

      self._phase = _phase_exec

      for srv in self._srvlist
         self.logi( "Running service " + srv.fullName() )
         srv.run()
      end
   end

   
   function _renderSlices()
      self.logi( "Rendering data slices" )
      
      i = 0
      cs = self._contentSlices
      slen = cs.len()
      while i < slen
         mth = cs[i] 
         if mth.isCallable()
            if self.log_level >= 3: self.logd( "Calling slice " + mth )
            cs[i] = mth()
         end
         ++i
      end
   end
      
   function _packSlices()
      self.logi( "Packing data slices" )
      
      str = ""
      for s in self._contentSlices
         str += s
      end
      return str
   end

   function _finalizeServices()
      for name, service in self.services
         service.finalize()
      end
   end
   

   function _selector_html( file )
      f = InputStream( file )
      out = stdOut()
      r = ""
      while not f.eof()
         f.read( f, 4096 )
         out.write( r )
      end
      f.close()
   end

   function _onSessionVarChanged( sv, value )
      self.logd( @"Session var changed: $(sv)=$value" )
      self.sessionData[sv] = value
   end


   function _manageError( e, ctx )      
      try
         // force excluding bindings
         self._phase = _phase_exec
         ereport = self.service( "ereport" )
         ereport.error.value = e
         ereport.context.value = ctx
         
         > ereport.perform_render()
      catch in f
         self._defErrorReport( e, ctx, f )
      end
   end

   function _defErrorReport( e, ctx, f )
      > ctx
      > "=" * 66
      > "FATAL ERROR -- failed to load error report service, using default error reporting:"
      > e.toString()
      > "=" * 66
      > "Error in loading the error report service was:"
      > f.toString()
   end

   // Restore session data
   function _loadSession()
      self.logi( "Loading session data" )
      self.sessionData, self.sessionExpired = self.sessionManager.restore()
      if self.log_level >= 3: self.logd( "Session data: " + self.sessionData.describe() )
   end
   
   // save session data
   function _saveSession()
      if self.sessionData
         if self.log_level >= 3: self.logd( @"Saving session data: "+ self.sessionData.describe() )
         self.sessionManager.save( self.sessionData )
      end
   end

   // Display debug data
   function _displayDebug()
      if self._debugStream
         > "<hr/><h2>Debug log sent to client</h2><pre>"
         > htmlEscape(self._debugStream.closeToString())
         > "</pre>"
         > "<hr/>"
      end
   end

end

// Re-export relevant Nest elements
export Nest, Service, ServiceVar, NestError, DataManager
