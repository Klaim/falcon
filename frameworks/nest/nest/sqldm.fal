/*
   FALCON - DBI Data Manager

   Nest - Falcon web applcation engine

   FILE: sqldm.fal

   General (and simple) DBI/sql based data manager.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Mon, 09 Aug 2010 15:33:56 +0200

   -------------------------------------------------------------------
   (C) Copyright 2010: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

import from dbi
import DataManager from .datamanager as DataManager
import NestError from .error as NestError
import DBEntity from .dbentity as DBEntity

/*# Class used to serve dbi connections */
class SQLDM( instance ) from DataManager( instance )
   dbc = nil
   entities = [=>]
   configuration = nil

   /*# Connection string */
   cs = nil

   /*# Title of the columns of the last query operation */
   columns = nil

   function configure( data )
      Nest.logi( "Configuring SQLDM" )
      if "connectString" notin data
         raise NestError( NestError.other, i"missing 'connectString' in configuration" )
      end

      for item, value in data
         if value.derivedFrom( DBEntity )
            self.entities[ value.table_name ] = value
         end
      end

      self.configuration = data
      self.cs = data["connectString"]
      try
         self.dbc = dbi.connect( self.cs )
      catch dbi.DBIError in dbe
         if dbe.code != dbi.DBIError.DB_NOTFOUND
            raise dbe
         end
         // allow to proceed with dbc empty.
         Nest.logw( "Database not found: " + self.cs )
      end

      if Nest.log_level >= 2: Nest.logi( "Setting entities: " + self.entities.keys().describe() )
      
   end


   function create( cond )
      self.cs = self.configuration["connectString"] + ";create=" +  (cond ? "cond" : "always")
      Nest.logi( "Creating database through: " + self.cs )
      self.dbc = dbi.connect( self.cs )
      self._createContent_internal( cond )
   end


   function createContent( cond )
      self.cs = self.configuration["connectString"]
      Nest.logi( "Creating content of database through: " + self.cs )
      self.dbc = dbi.connect( self.cs )
      self._createContent_internal( cond )
   end


   function _createContent_internal( cond )      
      for ename, ev in self.entities
         self.createEntity( ev, cond )
      end
   end

   function createEntity( ev, cond )
      // todo: respect referential integrity
      dbc = self.dbc
      try
         Nest.logi( "Creating database entity: " + ev.table_name )
         c = ev.getCreate( cond )
         if Nest.log_level >= 3: Nest.logd( "Launching SQL: \n" + c )
         dbc.perform( c )

         if ev.startup
            for record in ev.startup()
               self.add( ev.table_name, record )
            end
         end
      catch dbi.DBIError in dbie
         raise NestError( NestError.db_create, "", @"[$(ev.table_name)]:" + dbie.heading())
      end
   end


   function query( entity, view, start, count )
      dbe = self.getEntity(entity)

      // do we want a particular view?
      if view
         if not view in dbe.views
            raise NestError( NestError.other, i"View not found", entity +" -> " + view )
         end

         view = dbe.views[view]
         // however, always add the key fields.                                                                        
         sql_fields = ",".merge( dbe.key_fields +
                                 map( {column => column.field}, view ) )
      else
         // get all
         sql_fields = ",".merge( dbe.key_fields + dbe.fields ) 
      end

      if start and count
         r = self.dbc.query(
            self.dbc.lselect( @"select $sql_fields from $dbe.table_name", start, count ) )
      else
         r = self.dbc.query( @"select $sql_fields from $dbe.table_name" )
      end

      result = []
      while (d = r.fetch([=>]))
         result += dbe.makeRecord( d, view )
      end
      
      // add a title row if we were ordered a view
      if view
         self.columns = map( {column => column.title}, view )
      else
         self.columns = sql_fields
      end

      return result
   end
   

   function queryItem( entity, eid, view )
      dbe = self.getEntity(entity)

      // do we want a particular view?
      if view
         if not view in dbe.views
            raise NestError( NestError.other, i"View not found", entity +" -> " + view )
         end

         view = dbe.views[view]
         // however, always add the key fields.
         sql_fields = ",".merge( dbe.key_fields +
                                 map( {column => column.field}, view ) )
      else
         // get all
         sql_fields = ",".merge( dbe.key_fields + dbe.fields )
      end

      r = self.dbc.query( @"select $sql_fields from $dbe.table_name where " + dbe.keyExpr( eid ) )
      d  = r.fetch([=>])
      if not d: return nil

      // add a title row if we were ordered a view
      if view
         self.columns = map( {column => column.title}, view )
      else
         self.columns = sql_fields
      end

      return dbe.makeRecord( d, view )
   end
   

   function add( entity, data )
      Nest.logi( "Adding entity of type " + entity )
      dbe = self.getEntity(entity)
      sql_fields = ",".merge( data.keys() )
      sql_qm = ("?," * data.len())[0:-1]  // ?,?,?, << kill the last ","
      sql_command = .[ self.dbc.perform @"insert into $(dbe.table_name)( $(sql_fields) )\nvalues($sql_qm)" ]
      if Nest.log_level >= 3: Nest.logd("Executing sql: " + sql_command[1] )
      ( sql_command + data.values() )()
      return self.dbc.getLastID( dbe.table_name )
   end
   

   function update( entity, eid, data )
      Nest.logi( "Updating entity of type " + entity )
      dbe = self.getEntity(entity)

      sql_fields = "=?,".merge( data.keys() ) + "=?"
      sql_command = .[ self.dbc.perform
                       @"update $(dbe.table_name)\nset $sql_fields\nwhere " + dbe.keyExpr(eid) ]
      // Return the number of affected columns
      if Nest.log_level >= 3: Nest.logd("Executing sql: " + sql_command[1] )
      return ( sql_command + data.values() )()
   end
   

   function delete( entity, eid )
      Nest.logi( @"Deleting $(eid) from $(entity)" )
      dbe = self.getEntity(entity)
      return self.dbc.perform( @"delete from $(dbe.table_name)\nwhere " + dbe.keyExpr(eid)  )
   end


   function getEntity( entity )
      try
         return self.entities[entity]
      catch AccessError
         raise NestError( NestError.other, i"Entity not found", entity )
      end
   end

end
