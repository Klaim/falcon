/*
   FALCON - The Falcon Programming Language

   Nest - Falcon web applcation engine

   FILE: bindings.fal

   Default built-in bindings for Nest.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Wed, 04 Aug 2010 09:57:06 +0200

   -------------------------------------------------------------------
   (C) Copyright 2010: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

import from nest.utils in utils
import NestError from nest.error as NestError

/*# Built-in configuration binder.

   This binder is used to bind service configuration values to Nest variables.

   The reason to do this convolute thing is that listeners can set themselves
   into ServiceVar instances, and in this way they can be notified of even
   configuration variables set in the service.

   Of course, a service is not REQUIRED to offer all its configuration variables
   publically in this way. It can just receive the configuration data and use
   it turing the startup or run phase.

   However, if some relevant automated variable has any utility in being published
   and universally know, this is a useful way to automatically store its value from
   the configuration of the service into it, and eventually notify listeners.
*/

object ConfigBinder
   function bind( varname, srv, var )
      if varname in srv.configuration
         var.value = srv.configuration[varname]
      end
   end
end

/*# Binder retreiving values from the Request GET fields.

   @note Unless you know what you're doing, you should use the @a InputBinder
         object instead.

   This binder initialize the variable with a part of the incoming query
   matching the variable name.

   If the service has an instance value, then the variable serched among the
   input elements is prefixed with a "<instance>_" string, where <instance>
   is the name of the service instance.

   For example, in the following service:
   @code
   class Test(i) from Service(i)
      var = ServiceVar( GetBinder )
   end
   @endcode

   @b var will assume the value of the input variable named "var", if present.
   If the service is created with an instance name, for example "mytest", then
   the variable searched will be "mytest_var".

   If the variable is @b not found in the input scope (in this case GET HTTP fields),
   the @a ServiceVar.value property will be nil, and the value of @a ServiceVar.isSet
   will be false.

   @see InputBinder
*/

object GetBinder
   function bind( varname, srv, var )
      vn = srv.instance ? srv.instance + "_" + varname : varname         
      if vn in Request.gets
         var.value = Request.gets[vn]
      end
   end
end

/*# Binder retreiving values from the Request POST fields.

   @note Unless you know what you're doing, you should use the @a InputBinder
         object instead.
         
   This binder initialize the variable with a part of the incoming POST query
   matching the variable name.

   If the service has an instance value, then the variable serched among the
   input elements is prefixed with a "<instance>_" string, where <instance>
   is the name of the service instance.

   For example, in the following service:
   @code
   class Test(i) from Service(i)
      var = ServiceVar( PostBinder )
   end
   @endcode

   @b var will assume the value of the input variable named "var", if present.
   If the service is created with an instance name, for example "mytest", then
   the variable searched will be "mytest_var".

   If the variable is @b not found in the input scope (in this case POST HTTP fields),
   the @a ServiceVar.value property will be nil, and the value of @a ServiceVar.isSet
   will be false.

   @see InputBinder
*/
object PostBinder
   function bind( varname, srv, var )
      vn = srv.instance ? srv.instance + "_" + varname : varname
      if vn in Request.posts
         var.value = Request.posts[vn]
      end
   end
end

/*# Binder retreiving values from the HTTP cookies.

   @note Unless you know what you're doing, you should use the @a InputBinder
         object instead.

   This binder initialize the variable with a part of the incoming HTTP header
   storing a cookie named after the bound variable.

   If the service has an instance value, then the variable serched among the
   input elements is prefixed with a "<instance>_" string, where <instance>
   is the name of the service instance.

   For example, in the following service:
   @code
   class Test(i) from Service(i)
      var = ServiceVar( CookieBinder )
   end
   @endcode

   @b var will assume the value of the input variable named "var", if present.
   If the service is created with an instance name, for example "mytest", then
   the variable searched will be "mytest_var".

   If the variable is @b not found in the input scope (in this case, cookies),
   the @a ServiceVar.value property will be nil, and the value of @a ServiceVar.isSet
   will be false.

   @see InputBinder
*/
object CookieBinder
   function bind( varname, srv, var )
      vn = srv.instance ? srv.instance + "_" + varname : varname
      if vn in Request.cookies
         var.value = Request.cookies[vn]
      end
   end
end

/*# Binder retreiving values from Cookies, GET or POST HTTP Requeset variables.

   This binder initialize the variable with a part of the incoming query, using
   the Request.getField search algorithm. The fields are searched in the following
   order:

   - cookies
   - POST
   - GET

   If the service has an instance value, then the variable serched among the
   input elements is prefixed with a "<instance>_" string, where <instance>
   is the name of the service instance.

   For example, in the following service:
   @code
   class Test(i) from Service(i)
      var = ServiceVar( WebVarBinder )
   end
   @endcode

   @b var will assume the value of the input variable named "var", if present.
   If the service is created with an instance name, for example "mytest", then
   the variable searched will be "mytest_var".

   If the variable is @b not found in the input scope,
   the @a ServiceVar.value property will be nil, and the value of @a ServiceVar.isSet
   will be false.

   @see InputBinder
*/
object WebVarBinder
   function bind( varname, srv, var )
      vn = srv.instance ? srv.instance + "_" + varname : varname
      if (value = Request.getField( vn, nil ) )
         var.value = value
      end
   end
end


/*# Binder retreiving values from Nest input variables.

   This binder initialize the variable with a pre-filtered input variable.

   Nest system reads the input variables with the following priority:

   - POST HTTP fields
   - GET HTTP fields (URI queries).

   but web application can define new @a Nest.filter functions to create new
   strategies to read the input variables, removing some of them, adding some
   of them and so on.

   If a variable is defined in a higher priority input source, values eventually
   defined in lower priority sources are ignored.

   Nest can optionally pass the input variables to an application-defined filter
   prior passing them too the modules. This helps the applicaiton to perform
   extra security checks or inject special variables autonomously.

   Session variables are handled separately, and they are not usually served as
   input variables unless 

   If the service has an instance value, then the variable serched among the
   input elements is prefixed with a "<instance>_" string, where <instance>
   is the name of the service instance.

   For example, in the following service:
   @code
   class Test(i) from Service(i)
      var = ServiceVar( InputBinder )
   end
   @endcode

   @b var will assume the value of the input variable named "var", if present.
   If the service is created with an instance name, for example "mytest", then
   the variable searched will be "mytest_var".

   If the variable is @b not found in the @a Nest.input dictionary,
   the @a ServiceVar.value property will be nil, and the value of @a ServiceVar.isSet
   will be false.

   @see SessionBinder
*/
object InputVarBinder
   function bind( varname, srv, var )
      vn = srv.instance ? srv.instance + "_" + varname : varname
      if vn in Nest.inputVars
         var.value = Nest.inputVars[vn]
      end
   end
end

/*# Automatically turns the given variable in a persistent session variable.

   The binder automatically retreives the variable value at application startup
   from the Nest session system, and subscribes this variable to be saved upon
   application correct termination.

   Session variables comes separated for every Service instance. Every instance
   has its own session variables.

   The value is saved after it is first assigned setting a value in @a ServiceVar.value.
   If a variable was previously assigned, the @a ServiceVar.isSet member will be true.

   The value saved as a session may be any Falcon value that may be serialized and
   restored. Strings are of course safe, but numbers, arrays, dictionaries and simple
   classes can be used as well.

   The amount of data that an application can save in a session depends on the underling
   session driver user by Nest. It is safe to consider available a minimum of 4096 bytes
   per session.
   
   @see Nest.sessionExpired
*/
object SessionBinder
   function initVar( var )
      var.isSession = true
   end
   
   function bind( varname, srv, var )
      vn = srv.varName( varname )
      if vn in Nest.sessionData
         var.value = Nest.sessionData[vn]
      end
   end
end

/*# Binds a variable with a skin.

   Skin binders automatically search for skin files in the service home direcory(es).

   The skin variable is searched in the service configuration file. If it's a function,
   then is set as the skin function; if it's a string, then the given skin file is searched
   in the proper service directory.

   If the variable is not found in the service configuration, then a file named after the variable
   is searched in the service directory. In short, it's like having a default for the skin variable
   being the same as the skin file name (and extension ".fal", ".ftd" or ".fam").

   The skin file search order is the following:
   - <host site>/srv/<service>/<instance>
   - <host site>/srv/<service>
   - <Nest installation>/srv/<service>/<instance>
   - <Nest installation>/srv/<service>

   The skin module must expose a function named "skin" at its topmost level.
   
   All the services have in their base class a default skin variable called "skin".

   If the skin name is explicitly set in the configuration file, an error will be raised in case
   it is not found. Otherwise, the skin load will just silently fail.

   A skin can also be explicitly disabled setting the value to nil.

   It is possible to "disarm" the default "skin" property by simply setting it to nil in the class
   declaration (may be useful for skin-less services to reduce the startup overhead).
   
   @see serivce_skin
*/
object SkinBinder
   function bind( varname, srv, var )
      if varname in srv.configuration

         skinFile = srv.configuration[varname]
         if skinFile.isCallable()
            Nest.logi( "Service " + srv.fullName() + " is setting sub-skin " + varname + " to a callable in configuration." )
            var.value = srv.configuration[varname]
         elif skinFile    // ignore nil
            skin = self.getSubSkin(skinFile, srv, var)
            if skin
               Nest.logi( "Service " + srv.fullName() + " is setting sub-skin " + varname + " from file." )
               var.value = skin
            else
               raise NestError( NestError.noskin, "", skinFile )
            end
         end
         
      else
         // get the default-<varname>.fal skin,
         // but if the service skin file is not set,
         // don't force it.
         bset = var.isSet
         
         // The nameis always the skin name
         name = varname
         
         Nest.logi( "Service " + srv.fullName() + " searching default sub-skin " + name + " from file." )
         skin = self.getSubSkin( name , srv, var)
         if not skin            
            if bset
               // The skin was mandatory
               raise NestError( NestError.noskin, "", skinFile )
            end
            Nest.logi( "Service " + srv.fullName() + " ignoring missing sub-skin." )
         else
            var.value = skin
         end
      end
   end

   /*# Loads the required skin for the required service.
      @param skinFile The name of the skin module to be searched.
      @param srv A service willing to load te skin
      @return The @b skin callable exposed by the loaded module or nil on failure.
      @raise IoError on errors opening modules.
      @raise CodeError on module compilation or link errors.
   */
   function getSubSkin( skinFile, srv )
      srvName = srv.className()
      srvInst = srv.instance

      skinPaths = Nest.getServiceDirs( srvName, srvInst )

      if Nest.log_level >= 3
         Nest.logd( "Service " + srv.fullName() + " scanning for sub-skin \"" + skinFile + "\" in " + skinPaths.describe() )
      end

      skinFile = utils.findFileInDirs( skinPaths, skinFile, ['fal','ftd','fam'] )
      if skinFile
         if Nest.log_level >= 2: Nest.logi( "Service " + srv.fullName() + " using sub-skin " + skinFile )
         include( skinFile, symDict | (sd=["skin"=>nil] ) )
         return sd["skin"]
      end
   end
end

export 
