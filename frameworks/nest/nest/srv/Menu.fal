/*
   FALCON - The Falcon Programming Language

   Nest - Falcon web applcation engine

   FILE: Menu.fal

   Service for managing menus
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Wed, 15 Sep 2010 18:56:26 +0200

   -------------------------------------------------------------------
   (C) Copyright 2010: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

import Service from nest as Service
import ServiceVar from nest as ServiceVar
import NestError from nest as NestError
import from nest.bindings in b

/*# Entity representing a menu item.
   @param text The text of the menu item.
   @param target The destination link.
   @optparam al Authorization level for this item to appare.
   @optparam submenu A list of MenuItems

   The @b target can be a link (possibly, a "javascript:" link) or a
   nest page PID. In this case, pass it as oob'd, and the
   @a Nest.pageLink method will be automatically applied to it.
   
   If the @b target is nil, then the entry won't be clickable;
   this may be used both for disabled menus or to hold sub-menus.
   
*/
class MenuItem( text, target, al, submenu )
   //# text of this menu item
   text = text
   //# Target link of this menu item
   target = nil
   //# Authorization level
   auth_level = al
   
   //# Sub-menu; shall be an array of menus.
   submenu = submenu

   //# Indicates if an item represents the current page.
   current = false

   init
      if ^? target
         self.target = Nest.pageLink( target )
      else
         self.target = target
      end
   end
end


/*# Menu service.
   @optparam instance An instance name for this service.

   This service is used to manage static and dynamic web site menus.

   Menus are a set of links, associated with a string to identify them, that
   can be shown or optionally hidden if the incoming user level is not
   high enough to grant him with some option.
   
   The base menu can be configured through the @a Menu.items configuration, which
   must be an array of MenuItem variables.

   The Skin of this serivce will render the menu as a whole, while a subskin called mi_skin
   is called to render each single item. The default skins will render sub-menus recursively;
   you may implement a different strategy by reimplementing the default skin or the item_skin
   subskin, or both.

   Other services can dynamically register new items through the the @b add_menu hook, or
   in case this service has an @b instance name, on @b add_menu.<instance>. The add_menu
   signal is emitted (during startup phase) as
   @code
      Nest.emit( "add_menu[.<instance>]", MenuItem(...) [, "parent" ] )
   @endcode
   where the optional @b parent is a string indicating an @a MenuItem.text property in a
   toplevel item. Deeper submenu parents may be reached using "level1.level2...." dot separator
   between items.

   Submenus added this way are pushed at the end of the already registered menus at the same level.
   If more complex interaction is required, the Menu.items service variable can be subscribed and
   manipulated directly.

*/
class Menu( instance ) from Service( instance )

   //# Skin for a single menu item
   skin_item = ServiceVar( b.SkinBinder )

   //# Config: Items in the menu -- array of MenuItems
   items = ServiceVar( b.ConfigBinder )

   //# The current item, detected by the active pid by run
   current_item = ServiceVar()
   
   //#  The items that are supposed to be visible in this page
   active_items = ServiceVar()
   //# Config: CSS class of the top element of the skin (will default to 'nest_menu')
   cls = ServiceVar( b.ConfigBinder )

   init
      // register to the add_menu[.instance] hook
      name = self.instance ? "add_menu." + self.instance : "add_menu"
      Nest.addHook( Nest.Hook( name, self._add_menu_hook ) )
   end

   function startup()
      if Nest.pcheck
         vals = self.items.value
         if vals and vals.typeId() != ArrayType
            raise NestError( NestError.pcheck, "", "ServiceVar items is not an array" )
         end
         
         for item in vals
            if not item.derivedFrom( "MenuItem" )
               raise NestError( NestError.pcheck, "", "Items in Menu.items are not derived from MenuItem" )
            end
         end
      end

      if not self.cls.value
         self.cls.value = "nest_menu"
      end
   end

   function run()
      if not self.allowed(): return
      Nest.logi( "Menu service run()" )

      // get the authorization level of the user
      auth_level = Nest.ambient( "auth_level" )
      
      // and set none by default
      al = auth_level.isSet ? auth_level.value : Nest.AL.NONE

      // filter out available events.
      menuitems = self.items.value
      if Nest.log_level >= 3: Nest.logd( "Menu input items: " + menuitems.describe() )
      ci = []
      for item in menuitems 
         if not item.auth_level or Nest.auth_level <= item.auth_level
            ci += item
            if Nest.pid == item.target
               item.current = true
               if Nest.log_level >= 3: Nest.logd( "Current item is: " + item.text )
            else
               item.current = false
            end
         end
      end

      self.active_items.value = ci
      if Nest.log_level >= 3: Nest.logd( "Activating the following items: " + ci.describe() )
   end


   function _add_menu_hook( item, parent )
      // consistency ceheck
      if Nest.pcheck
         if not item.derivedFrom( MenuItem )
            raise NestError( NestError.pcheck, "", "in add_menu hook, item not derived from MenuItem" )
         end

         if parent and parent.typeId() != StringType
            raise NestError( NestError.pcheck, "", "in add_menu hook, parent is not a string" )
         end
      end

      // find the correct level in the menu where we need to add it.
      if parent: plist = parent.split(".")
      tree = self.items.value  // we're in a hook, but we're a method. Self points to Menu
      
      // select the correct item
      while ( plist and (current_name = plist.head()) )
         parent_item = tree.filter( { v => v == current_name } )
         if not parent_item
            Nest.logw( @"Requested item $(parent) not found, adding to the main tree" )
            tree = self.items.value
            break
         else
            // filter gets 1 element in an array
            tree = parent_item[0].submenu
         end
      end

      // normally, add the item at the end of the selected tree
      if tree
         tree.add( item )
      else
         // if we have no tree, then it means items are empty
         self.items.value = [item]
      end
      
      // allow further propagation
   end
   
end
