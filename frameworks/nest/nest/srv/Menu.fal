/*
   FALCON - The Falcon Programming Language

   Nest - Falcon web applcation engine

   FILE: Menu.fal

   Service for managing menus
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Wed, 15 Sep 2010 18:56:26 +0200

   -------------------------------------------------------------------
   (C) Copyright 2010: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

import Service from nest as Service
import ServiceVar from nest as ServiceVar
import NestError from nest as NestError
import from nest.bindings in b

/*# Entity representing a menu item.
   @param text The text of the menu item.
   @optparam target The destination link.
   @optparam al Authorization level for this item to appare.
   @optparam submenu A list of MenuItems

   The @b text parameter is the text that should be rendered
   as the menu name. The item may be marked as conditional
   making it out-of-band; this will make it to appare only
   if there is a link (target is not nil) or there are sub-menus.
   Useful for "plugin" menu items.

   The @b target can be a link (possibly, a "javascript:" link) or a
   nest page PID. The special scheme "nest:" marks a nest page ID.
   All the other values are treated as direct links. You may prefix
   the @b target entry with a ">" character to ask for this entity
   to be opeend in a another window.
   
   If the @b target is nil, then the entry won't be clickable;
   this may be used both for disabled menus or to hold sub-menus.
   
*/
class MenuItem( text, target, al, submenu )
   //# text of this menu item
   text = text

   //# Target link of this menu item
   target = nil

   //# Open in a new window?
   wnd = ""
   
   //# Authorization level
   auth_level = al
   
   //# Sub-menu; shall be an array of menus.
   submenu = submenu

   //# Indicates if an item represents the current page.
   current = false

   //# is this item referencing a page ID?
   pid = nil
   
   init
      // parse the target field
      if target
         if target.startsWith(">")
            target = target[1:]
            self.wnd = "_blank"
         end

         if target.startsWith( "nest:" )
            pid = target[5:]
            self.pid = pid
            self.target = Nest.pageLink( pid )
         else
            self.target = target
         end
      end
   end
end


/*# Menu service.
   @optparam instance An instance name for this service.

   This service is used to manage static and dynamic web site menus.

   Menus are a set of links, associated with a string to identify them, that
   can be shown or optionally hidden if the incoming user level is not
   high enough to grant him with some option.
   
   The base menu can be configured through the @a Menu.items configuration, which
   must be an array of MenuItem variables.

   The Skin of this serivce will render the menu as a whole, while a subskin called mi_skin
   is called to render each single item. The default skins will render sub-menus recursively;
   you may implement a different strategy by reimplementing the default skin or the item_skin
   subskin, or both.

   Other services can dynamically register new items through the the @b add_menu hook, or
   in case this service has an @b instance name, on @b add_menu.<instance>. The add_menu
   signal is emitted (during startup phase) as
   @code
      Nest.emit( "add_menu[.<instance>]", MenuItem(...) [, "parent" ] )
   @endcode
   where the optional @b parent is a string indicating an @a MenuItem.text property in a
   toplevel item. Deeper submenu parents may be reached using "level1.level2...." dot separator
   between items.

   Submenus added this way are pushed at the end of the already registered menus at the same level.
   If more complex interaction is required, the Menu.items service variable can be subscribed and
   manipulated directly.

*/
class Menu( instance ) from Service( instance )

   //# Skin for a single menu item
   skin_item = ServiceVar( b.SkinBinder )

   //# Config: Items in the menu -- array of MenuItems
   items = ServiceVar( b.ConfigBinder )

   //# The current item, detected by the active pid by run
   current_item = ServiceVar()
   
   //#  The items that are supposed to be visible in this page
   active_items = ServiceVar()

   init
      // register to the add_menu[.instance] hook
      name = self.instance ? "add_menu." + self.instance : "add_menu"
      Nest.addHook( Nest.Hook( name, self._add_menu_hook ) )
   end

   function startup()
      if Nest.pcheck
         vals = self.items.value
         if vals and vals.typeId() != ArrayType
            raise NestError( NestError.pcheck, "", "ServiceVar items is not an array" )
         end
         
         for item in vals
            if not item.derivedFrom( "MenuItem" )
               raise NestError( NestError.pcheck, "", "Items in Menu.items are not derived from MenuItem" )
            end
         end
      end
   end

   function run()
      if not self.allowed(): return
      Nest.logi( "Menu service run()" )

      // get the authorization level of the user
      auth_level = Nest.ambient( "auth_level" )
      
      // and set none by default
      al = auth_level.isSet ? auth_level.value : Nest.AL.NONE

      // filter out available events.
      menuitems = self.items.value
      if Nest.log_level >= 3: Nest.logd( "Menu input items: " + menuitems.describe() )
      ci = []
      for item in menuitems
         // hidden and empty?
         if ^? item.text and (item.target == nil and not item.submenu)
            // ignore it
            continue
         end

         self._markItems( item, ci )
      end

      self.active_items.value = ci
      if Nest.log_level >= 3: Nest.logd( "Activating the following items: " + ci.describe() )
   end


   // Adds a menu through the "add_menu.instance" hook
   function _add_menu_hook( item, parent )
      // consistency ceheck
      if Nest.pcheck
         if not item.derivedFrom( "MenuItem" )
            raise NestError( NestError.pcheck, "", "in add_menu hook, item not derived from MenuItem " + item.describe() )
         end

         if parent and parent.typeId() != StringType
            raise NestError( NestError.pcheck, "", "in add_menu hook, parent is not a string" )
         end
      end

      // find the correct level in the menu where we need to add it.
      if parent: plist = parent.split(".")
      tree = self.items.value  // we're in a hook, but we're a method. Self points to Menu
      
      // select the correct item
      while ( plist and (current_name = plist.head()) and tree )
         parent_item = filter( { v => v.text == current_name }, tree )
         if not parent_item
            plist = true // force the following error
            tree = self.items.value
            break
         else
            // filter gets 1 element in an array
            parent_item = parent_item[0]
            tree = parent_item.submenu
         end
      end

      // if found, then the list of parents must be empty
      if plist
         Nest.logw( @"Requested item $(parent) not found, adding to the main tree" )
      end

      // normally, add the item at the end of the selected tree
      if tree
         tree.add( item )
      else
         // the tree may be empty if this the only child of the parent.
         if parent_item
            parent_item.submenu = [item]
         else
            // if we have no tree, then it means items are empty
            self.items.value = [item]
         end
      end
      
      // allow further propagation
   end

   function _markItems( item, ci )
      if not item.auth_level or Nest.auth_level <= item.auth_level
         ci += item
         if Nest.pid == item.pid
            item.current = true
            item.target = nil
            if Nest.log_level >= 3: Nest.logd( "Current item is: " + item.text )
         else
            item.current = false
            if ^? item.target: item.target = Nest.pageLink( item.target )
         end
      end

      // do the same for sub-items
      sm = []
      for subitem in item.submenu
         self._markItems( subitem, sm )
      end
      item.submenu = sm
   end
   
end
