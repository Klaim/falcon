/*
   FALCON - The Falcon Programming Language

   Nest - Falcon web applcation engine

   FILE: Form.fal

   Service for simpler handling of web forms.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Sun, 27 Jun 2010 14:01:38 +0200

   -------------------------------------------------------------------
   (C) Copyright 2010: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

import from nest
import NestError from nest as NestError
import from nest.bindings in b
import from dbi


/*# Service receiving the variables in a form.
   @optparam instance Instance of the service.
   
   This service is a useful generator and manager of web forms.

   Writing a web form is relatively easy, but automation of web forms is a complex matter.
   Among the things that a modern web site needs to do with form is:
   - Filling the form with data coming from a data source, or with previously loaded defaults;
   - Validating the form data prior remote post;
   - Validating the form data after it has been received;
   - Storing the validated data on a data source;
   - Indicating validation problems to the user, and prompting him with its own
     previously submitted input.

   The Nest Form service can have also the role to bind with a data entity, completing
   the data manager services.
*/

class Form( instance ) from nest.Service( instance )
   //# Config - DB Entity optionally bound with this form
   entity = nest.ServiceVar( b.ConfigBinder )
   
   /*# Config - Global check on the form.
      It's a function with the following prototype:
      @code
         check( form )
      @endcode

      where @b form is this instance.

      The function has the main role of checking the consistency of the form as a whole,
      veryfing consistency of multiple fields (i.e. repeated passwords) and deciding
      if the form as a whole is valid.

      To signal anomalies, the function may use the @a Field.failure entry, or set the
      service @a Form.result field.

      If the form has a DBEntity set in @a Form.entity, then check() may just return
      @b true if the form is allowed to proceed, or @b false to stop the form data
      from being processed. Notice that if a previusly called @a Field.check function
      was already signaling some problem, the return value of this function will be ignored.

      This function may also store or otherwise process the data on its own; in this case,
      it should properly set @a Form.result and @a Form.stored (and also @a Service.skin,
      if consistent), and it should return @b false to prevent further processing.

      @a Returning @b false won't cause any error status to be actually set, it just prevents
         the form from being automatically stored in a given @a Form.entity.

      In any case, @a Form.stored should be used to tell the application (and the calling page)
      about the success or failure of form processing result.
   */
   check = nest.ServiceVar( b.ConfigBinder )

   //# Config - Action for the form submit
   handler = nest.ServiceVar( b.ConfigBinder )

   //# Config - Actions to be Things to do below the form. 
   actions = nest.ServiceVar( b.ConfigBinder )

   //# Config - Fields in an array.
   fields = nest.ServiceVar( b.ConfigBinder )

   //# Skin - Skin used for input fields -- and select fields.
   skin_input = nest.ServiceVar( b.SkinBinder )
   
   //# Skin - Skin used for multiple input fields (horizontal grouping)
   skin_multiple_h = nest.ServiceVar( b.SkinBinder )
   
   //# Skin - Skin used for multiple input fields (vertical grouping)
   skin_multiple_v = nest.ServiceVar( b.SkinBinder )

   //# Skin - Skin for text areas and wide fields.
   skin_wide = nest.ServiceVar( b.SkinBinder )

   /*# Skin - Skin used to render the "result" message in the main skin.
       The default skin shows the result message in a <div> of id result_[css_id],
      where css_id is the CSS id set in configuration for this service.
   */
   skin_result = nest.ServiceVar( b.SkinBinder )

   /*# Skin - Used when the operation is finally performed.
      This usually closes an update; the caller will want to display
      "operation complete, please return to main page" or similar messages.

      The default skin just displays the contents of the "result" field.
      
      To "disarm" it, the caller should just set it to "skin", so that the
      main skin gets loaded; this means that the "result" field will be renderd
      as a part of the form, which will be proposed again with the updated data.

      The default skin shows the result message in a <div> of id performed_[css_id],
      where css_id is the CSS id set in configuration for this service.
   */
   skin_performed = nest.ServiceVar( b.SkinBinder )

   //# Dictionary of Fields ordered by name, for simpler access from other services
   fieldsByName = nest.ServiceVar()

   //# Result that the final user may be interested in -- as a pre-formatted HTML text
   result = nest.ServiceVar()

   //# Automatically set to UUENC when adding an upload field.
   enctype= nest.ServiceVar()

   /*# Service -- Last store operation Status.

      Will be true if self.result is an OK message, false if self.result is an error message.
      It is automatically set by the form when trying to save the form data on a persistent
      DBEntity; elsewhere it's nil, and isSet will return false.

      The variable could also be used by the form check function (@a Form.check) to declare
      if a self-managed storage operation was successful or not.

      The status is set during the startup phase, so the host page can configure itself
      and decide which path to take depending on what happened.

      The variable is not shared with skins.
   */
   stored = nest.ServiceVar()

   //# Entity ID that is looked upon -- automatically filled from input fields.
   eid = nil

   
   // Will be true if some values has been read
   _updating = false
   
   function startup()
      // preliminary check 
      self._precheck()

      // let's see if we should update something.
      // if we're called "blank", then self._updating will stay false 
      failure = self._checkInputVars()

      // Have we received some update to store?
      if self._updating
         check = self.check.value
         if check.isCallable()
            check = check.base()
            Nest.logi( "Calling overall form check function" )
            if not check( self )
               failure = true
            end
         end

         // should we save the entity?
         if not failure and self.entity.isSet 
            self._storeEntity()
         end
      else
         // should we load the values from the entity?
         if self.eid and self.entity.isSet
            self._loadEntity()
         end
      end         
   end

   
   function _precheck()
      if self.handler.value == nil
         self.handler.value = Nest.pageLink()
      end

      if Nest.pcheck
         if not self.fields.value.typeId() == ArrayType
            raise NestError( NestError.pcheck, "", "fields must be array" )
         end

         if self.entity.isSet and not self.entity.value.derivedFrom( "DBEntity" )
            raise NestError( NestError.pcheck, "", "entity must be nil or a DBEntity subclass" )
         end
      end

      for f in self.fields.value
         if Nest.pcheck and not f.derivedFrom( "Field" )
            raise NestError( NestError.pcheck, "", "fields must be array of Field and is " + f.baseClass() )
         end

         f.setService( self )
      end

      // finally, grab the EID if available
      if not self.eid
         vname = self.instance ? self.instance + ".eid" : "eid"
         self.eid = Request.getField( vname, nil )
      end
   end

   // Check input form data -- returns true if cheks FAILED
   function _checkInputVars()
      Nest.logi( "Checking form input variables" )
      
      // something to do -- check all the fields?
      fields = self.fields.value
      fieldsByName = [=>]
      failure = false
      updating = false
      // prepare also to log
      if Nest.log_level >= 3: grabbed = [=>]
      
      for f in fields
         // organize the fields
         fieldsByName[f.name] = f

         // Is the field incoming in input?
         value = f.grabInputValue()
         // if it is, it may be "" but not nil
         if value != nil
            updating = true
            if Nest.log_level >= 3: grabbed[ f.name ] = value

            // in this case, we also need to see if the field is consistent.
            if f.check
               Nest.logd( "Calling check function for field " + f.name )
               if ( f.failure = f.check( value, f ) )
                  failure = true
               end
            end
         end
      end
      
      if Nest.log_level >= 3: Nest.logd( @"Form values: " + grabbed.describe() )
      self.fieldsByName.value = bless(fieldsByName)
      self._updating = updating
      return failure
   end
   
   
   function _storeEntity()
      Nest.logi( "Storing entity with eid: " + self.eid )
      
      // get all the interesting values
      data = [=>]
      for f in self.fields.value
         // a DB entity field?
         if f.field
            // If the field has a setter, then call it
            if f.setter.isCallable()
               f.setter( f, data )
            else
               // else, just store the value
               data[f.field] = f.value
            end
         end
      end
         
      // If we have an EID it's an existing field update, otherwise it's an insert
      try
         if self.eid
            if Nest.log_level >= 3: Nest.logd( "Updating eid " + self.eid + " with data: " + data.describe() )
            self.entity.value.update( self.eid, data )
         else
            // get the EID -- we'll need it
            if Nest.log_level >= 3: Nest.logd( "Inserting data: " + data.describe() )
            dbr = self.entity.value.insert( data )
            self.eid = dbr.eid()

            // then add a field for subseuent posts
            f = HiddenField( "eid", self.eid )
            f.srv = self
            self.fields.value.add( f )
         end

         // all, ok declare we're clear
         self.skin.value = self.skin_performed.value
         self.stored.value = true
      catch dbi.DBIError in error
         self.result.value = i"<b>Database error</b>: <br/><pre>" + htmlEscape(error.toString()) + "</pre>"
         self.stored.value = false
      end
   end

   
   function _loadEntity()
      Nest.logi( "Loading entity with eid: " + self.eid )
      // let's get the required EID
      record = self.entity.value.find( self.eid )
      // not found? -- that's a problem.
      if record
         for name, f in self.fieldsByName.value
            // a db based field?
            field = f.field
            if field
               if f.getter.isCallable()
                  f.getter( record, f )
               elif field in record.data
                  f.value = record.data[field]
               end
               // Else? -- raise an error?
            end
         end
      else
         entity_name = self.entity.value.name
         eid = self.eid
         self.result.value = @i"Record \"$(eid)\" not found in \"$(entity_name)\""
      end

      // repeat the EID -- if needed
      if "eid" notin self.fieldsByName.value
         Nest.logd( "Adding EID to fields: " + self.eid )
         f = HiddenField( "eid", self.eid )
         f.srv = self
         self.fields.value.add( f )
      end
   end

end



class Field( name, maker )
   /*# Function used to transform the data source into this value.
      Prototype:
      @code
         functon getter( dbrecord, field )
      @endcode

      Where @b dbrecord is a @a DBRecord instance, and field is
      a @b Field instance.

      If given, this has the role to set the value of the field
      when an entity is peeked.

      Otherwise, if @a Field.field property is set to a string,
      the required value will just be copied.
   */
   getter = nil

   /*# Function used to transform a web value in the data source.
      Prototype:
      @code
         functon setter( field, formingData )
      @endcode

      Where field is this @b Field instance, and formingData is
      a dictionary of field-name/value pairs where this field
      should set its value.

      If not given and if this field has a @a Field.field name,
      the incoming data will be simply set as the value for the
      field key.
   */
   setter = nil

   //# Underlying data field name.
   //# May be used by this Field to get or set directly a value from the underlying data.
   field = nil

   //# Function to be called back to check if this value is valid in this field.
   check = nil
   
   name = name
   srv = nil
   type = nil
   dvalue = nil
   value = nil
   
   id = nil
   cls = nil
   disabled  = nil
   readonly  = nil

   //# Skin used by this field to render itself.
   skin = {=>}
   
   //# Message to be displayed as a "field failure"
   failure = nil

   //# javascript handler for when the element got the focus
   onfocus = nil 
   //# javascript handler for when the element lost the focus
   onblur = nil
   //# javascript handler for when some text was selected
   onselect = nil
   //# javascript handler for when the element value was changed
   onchange = nil

   //# javascript handler for when the a pointer button was clicked
   onclick = nil
   //# javascript handler for when a pointer button was double clicked
   ondblclick = nil
   //# javascript handler for when a pointer button was pressed down
   onmousedown = nil
   //# javascript handler for when a pointer button was released
   onmouseup = nil
   //# javascript handler for when a pointer was moved onto
   onmouseover = nil
   //# javascript handler for when a pointer was moved within
   onmousemove = nil
   //# javascript handler for when a pointer was moved away
   onmouseout = nil
   //# javascript handler for when a key was pressed and released
   onkeypress = nil
   //# javascript handler for when a key was pressed down
   onkeydown = nil
   //# javascript handler for when a key was released
   onkeyup = nil
   
   init
      if maker: self.apply( maker )
   end

   function fullName()
      if self.srv: instance = self.srv.instance
      return instance ? instance +"." + self.name : self.name
   end
   
   function toString()
      name = self.fullName()
      str = @'<input type="$(self.type)" name="$(name)" id="$(name)"'
      str += self._makeValue()
      str += self._makeContent()
      str += "/>"
      return str
   end

   function _makeValue()
      value = self.value ? self.value : self.dvalue
      if value: return " value=\"" + htmlEscape( value.toString() ) + "\""
      return ""
   end
   
   function _makeContent()
      str = ""
      if self.id: str += " id=\"" + htmlEscape( self.id ) + "\""
      if self.cls: str += " class=\"" + htmlEscape( self.cls ) + "\""
      if self.readonly: str += " readonly=\"readonly\"" 
      if self.disabled: str += " disabled=\"disabled\""
      if self.cls: str += " class=\"" + htmlEscape( self.cls ) + "\""
      if self.onfocus: str += " onfocus=\"" + htmlEscape( self.onfocus ) + "\""
      if self.onblur: str += " onblur=\"" + htmlEscape( self.onblur ) + "\""
      if self.onselect: str += " onselect=\"" + htmlEscape( self.onselect ) + "\""
      if self.onchange: str += " onchange=\"" + htmlEscape( self.onchange ) + "\""
      if self.onclick: str += " onclick=\"" + htmlEscape( self.onclick ) + "\""
      if self.onclick: str += " onclick=\"" + htmlEscape( self.onclick ) + "\""
      if self.onmousedown: str += " onmousedown=\"" + htmlEscape( self.onmousedown ) + "\""
      if self.onmouseup: str += " onmouseup=\"" + htmlEscape( self.onmouseup ) + "\""
      if self.onmouseover: str += " onmouseover=\"" + htmlEscape( self.onmouseover ) + "\""
      if self.onmousemove: str += " onmousemove=\"" + htmlEscape( self.onmousemove ) + "\""
      if self.onmouseout: str += " onmouseout=\"" + htmlEscape( self.onmouseout ) + "\""
      if self.onkeypress: str += " onkeypress=\"" + htmlEscape( self.onkeypress ) + "\""
      if self.onkeydown: str += " onkeydown=\"" + htmlEscape( self.onkeydown ) + "\""
      if self.onkeyup: str += " onkeyup=\"" + htmlEscape( self.onkeyup ) + "\""
      str += self._makeExtraContent()
      return str
   end

   function _makeExtraContent()
      return ""
   end

   /*# Grabs the data incoming from a DB entity
      @param dbrec a @a DBRecord instance
   */
   function grabData( dbrec )
      data= dbrec.data
      if self.getter
         fval = self.getter( data, self )
         self.value = fval
      elif self.field in data
         fval = data[self.field]
         self.value = fval
      end
   end


   /*# Readies a data to be stored in a DBEntity
      @param forming A dictionary of field name => values entries.
   */
   function applyData( forming )
      if self.setter
         self.setter( self, forming )
      elif self.field
         forming[self.field] = self.value
      end
   end

   //# Grabs the value of this field from nest input values
   function grabInputValue()
      instance = self.srv.instance
      fname = instance ? instance + "." + self.name : self.name
      if fname in Nest.inputVars
         value = Nest.inputVars[ fname ]
         self.value = value
         return value
      end
      return nil
   end

/*
   function setValidator( jsfunc )
      instance = self.srv.instance
      fname = instance ? instance + "_" + self.name : self.name
      
      self.onkeypress = @"javascript:$(fname)()"
      self.srv.scripts += @ "function $(fname)(){\n" + jsfunc + "\n}"
   end
*/
   // internal
   function setService( srv )
      if Nest.log_level >= 3: Nest.logd( @"Setting servivce for field " + self.fullName() )
      self.srv = srv
   end
   
end


class TextField( name, prompt, maker ) from Field( name, maker )
   prompt = prompt
   type = "text"
   size = nil
   maxlength = nil

   function _makeExtraContent()
      str = ""
      if self.size: str += " size=\"" + htmlEscape( self.size.toString() ) + "\""
      if self.maxlength: str += " maxlength=\"" + htmlEscape( self.maxlength.toString() ) + "\""
      return str
   end


   function setService( srv )
      if Nest.log_level >= 3: Nest.logd( @"Setting servivce for field " + self.fullName() )
      self.srv = srv
      self.skin = srv.skin_input.value
   end
   
end


class PasswordField( name, prompt, maker ) from TextField( name, prompt, maker )
   type = "password"
end


class HiddenField( name, value, maker ) from Field( name, maker )
   type = "hidden"
   value = value
   skin = {v, s, f => > f.toString()}
end

class TextArea( name, prompt, maker ) from Field( name, maker )
   prompt = prompt
   type = "textarea"
   rows = nil
   cols = nil

   function toString()
      name = self.fullName()
      str = @'<textarea name="$(name)" id="$(name)"'
      str += self._makeContent()
      if self.cols: str += " cols=\"" + htmlEscape( self.cols.toString() ) + "\""
      if self.rows: str += " rows=\"" + htmlEscape( self.rows.toString() ) + "\""
      str += ">"
      value = self.value ? self.value : self.dvalue
      if value: str += htmlEscape( value.toString() )
      str += "</textarea>"
      return str
   end

   function setService( srv )
      if Nest.log_level >= 3: Nest.logd( @"Setting servivce for field " + self.fullName() )
      self.srv = srv
      self.skin = srv.skin_wide.value
   end
end


class Select( name, prompt, opts, maker ) from Field( name, maker )
   prompt = prompt
   type = "select"
   options = opts
   // Select field default is single selection.
   multiple = false

   function toString()
      value = self.value ? self.value : self.dvalue
      name = self.fullName()
      str = @'<select name="$(name)" id="$(name)"'
      if self.multiple: str += ' multiple="multiple"'
      str += self._makeContent()
      str += ">\n"
      for opt in self.options
         opt_value = toString(opt.value)
         str += "<option value=\"" + htmlEscape(opt_value) +"\""
         if opt_value == toString(value)
            str += ' selected="selected"'
         end
         str += ">" + htmlEscape( toString(opt.desc) ) + "</option>\n"
      end
      
      str += "</select>"
      return str      
   end
   
   function setService( srv )
      if Nest.log_level >= 3: Nest.logd( @"Setting servivce for field " + self.fullName() )
      self.srv = srv
      self.skin = srv.skin_input.value
   end
   
end


class MultiField( name, prompt, options, maker ) from Field( name, maker )
   prompt = prompt
   options = options
   vertical = false
   multiple = false
    
   function setService( srv )
      if Nest.log_level >= 3: Nest.logd( @"Setting servivce for field " + self.fullName() )
      self.srv = srv
      self.skin = self.vertical ? srv.skin_multiple_v.value : srv.skin_multiple_h.value
   end

   /*# Renders all the options in this multiple field.
      @return An array of string pairs (description, rendered input field).

      To be used directly by skin_multiple_h or skin_multiple_v
   */
   function makeOptions()
      res = []
      for opt in self.options
         res.add( [opt.desc, self.makeSingleOption( opt )] )
      end
      return res
   end

   function makeSingleOption( opt )
      name = self.srv.instance ? self.srv.instance +"." + self.name : self.name
      id = name + "_" + htmlEscape( opt.value )
      if self.multiple: name += "[]"
      str = @'<input type="$(self.type)" name="$(name)" id="$(id)"'
      str += self._makeValue( opt )
      str += self._makeContent()
      str += "/>"
      return str
   end

end


class CheckBox( name, prompt, opts, maker ) from MultiField( name, prompt, opts, maker )
   type = "checkbox"
   multiple = true
   
   function _makeValue( opt )
      str = " value=\"" +htmlEscape( opt.value ) + "\""
      if opt.value in self.value
         str += " checked=\"checked\""
      end
      return str
   end
   
end

class Radio( name, prompt, opts, maker ) from MultiField( name, prompt, opts, maker )
   type = "radio"

   function _makeValue( opt )
      str = " value=\"" +htmlEscape( opt.value.toString() ) + "\""
      if opt.value == self.value
         str += " checked=\"checked\""
      end
      return str
   end
end


class GroupField( name, prompt, fields, maker ) from Field( name, maker )
   prompt = prompt
   fields = fields
   vertical = false

   function setService( srv )
      if Nest.log_level >= 3: Nest.logd( @"Setting servivce for field " + self.fullName() )
      self.srv = srv
      self.skin = self.vertical ? srv.skin_multiple_v.value : srv.skin_multiple_h.value
   end

   function makeOptions()
      res = []
      for field in self.fields
         res.add( [field.prompt, field.toString() ] )
      end
      return res
   end

   function grabInputValue()
      data = [=>]
      for field in self.fields
         field.setService( self.srv )
         value = field.grabInputValue()
         data[field.name] = value
         if value != nil: somedata = true
      end
      if somedata: return data
      return nil
   end


   function grabData( dbrec )
      for field in self.fields
         field.grabData( dbrec )
      end
   end

   function applyData( forming )
      if self.setter
         val = [=>]
         for field in self.fields
            val[field.name] = field.value
         end
         self.value = val
         self.setter( self, forming )
      end
   end
   
end


class UploadFile( name, prompt, maker ) from Field( name, maker )
   prompt = prompt
   type = "file"

   function setService( srv )
      if Nest.log_level >= 3: Nest.logd( @"Setting servivce for field " + self.fullName() )
      self.srv = srv
      self.skin = srv.skin_input.value
      srv.enctype.value = "enctype=\"application/x-www-form-urlencoded\""
   end
end


class Option( value, desc )
   value = value
   desc = desc   
end
