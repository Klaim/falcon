/*
   FALCON - The Falcon Programming Language

   Nest - Falcon web applcation engine

   FILE: Wiki.fal

   Service managing wiki-like pages.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Fri, 20 Aug 2010 21:38:16 +0200

   -------------------------------------------------------------------
   (C) Copyright 2010: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

import Service from nest as Service
import ServiceVar from nest as ServiceVar
import from nest.bindings in b
import NestError from nest as NestError
import from nest.dbentity in dbe
import from nest.dbview in dbv
import from parser.render.html in html

import DataManager from nest.datamanager as DataManager

const entity_name = "wiki_pages"
const default_page = "main"

/*# Service Managing WIKI based contents.

@section wiki_plugin Plugin management.

This Wiki service resolves plugin requests in wiki texts by generating a
@a Nest.emit message named "wiki_plugin_<name>", where __name__ is the name
of the required plugin.

As plugin defitions are application (wiki) globals, the instance of the wiki
and its configuration are irrilevant. The wiki plugin handler just need to
generate a string reply that is inserted in its place in the final rendered page.

The function is invoked as
@code
   function wiki_plugin_<name>( parms, node, standout, page )
@endcode

   where params, node and standout are the Falcon wiki renderer parameters:
   - params is the complete string of values passed to the plugin.
   - node is the point in the tree structure where the node is declared.
   - standout true if this is happening in the standout phase.
   - The top node of the wiki tree.

The Nest system defines the following plugins, which are registered as the wiki service is loaded:
   - **toc**: Puts a table of content extracted from the source page in place of its definition.
   - **timestamp**: Puts the current timestamp at its place.

@section wiki_js Javascript management

This service adds a javascript function in the Nest.headings called
{{function nest_wiki_insertText( text, mode )}}, where text is the text to be inserted, and mode can be
'image', 'file' or null. Calling this function results in the desired text (possibly a link
to an internal file or image) to be inserted at the current cursor position in the text area
having the CSS id {{nest_wiki_area}}.

The function can be called back by the @a Uploader service.

@note @a Nest.headings must be properly called for this to work.

*/
class Wiki( instance ) from Service( instance )
   //# Wiki page to be loaded or managed
   wid = ServiceVar( b.InputVarBinder )
   //# Wiki action; 'del' 'mody' 'upd' 'prw' (none for view)
   wka = ServiceVar(b.InputVarBinder )
   //# Wiki data; original data
   wkd = ServiceVar( b.InputVarBinder )
   //# Wiki confirm; a page will be actually remove only if it's not null. Set to h to clear history.
   wkc = ServiceVar( b.InputVarBinder )

   
   //===========================================
   // Configuration.
   //# Data manager used by this WIKI instance -- must be a DataManager instance.
   dm = ServiceVar( b.ConfigBinder )
   //# Instance of a Wiki parser, implementing the Falcon wiki parser interface
   parser = ServiceVar( b.ConfigBinder )
   //# Function retunring a link to uploaded files.
   upload_linker = ServiceVar( b.ConfigBinder )
   //# Wid of the main page (which is also the default wid)
   main_wid = ServiceVar( b.ConfigBinder )
   //# Actions that can be done other than "commit" on a page
   actions = ServiceVar( b.ConfigBinder )
   //# Page used when invoking the wiki page modification
   modyPage = ServiceVar( b.ConfigBinder )
   //# Max depth of the wiki history
   history_depth = ServiceVar( b.ConfigBinder )
   //# Config - Name of the entity used by this wiki service (defaults to "wiki_pages")
   ename = ServiceVar( b.ConfigBinder )


   //===================================================================
   // Skins

   //# Skin for action confirm.
   skin_confirm = ServiceVar( b.SkinBinder )

   //# Skin used for preview pages
   skin_preview = ServiceVar( b.SkinBinder )

   //# Skin used for modify
   skin_modify = ServiceVar( b.SkinBinder )

   //# Skin for the history (page sequence)
   skin_history = ServiceVar( b.SkinBinder )
   
   //===================================================================
   // Internal variables
   
   //# Compiled content of the page
   preview = ServiceVar()
   //# Complete page -- if found
   page = ServiceVar()

   // Gets the authenticated user.
   auth_user = Nest.ambient( "auth_user", b.SessionBinder )
   //# Wiki history; where are we?
   history = ServiceVar( b.SessionBinder )

   helper = _WikiHelper(self)

   //# Wiki Page entity @a DBEntity in the Data Manager
   entity = nil

   //# @a DBView used to read a page
   read_view = nil

   //# @a DBView used to edit a page
   edit_view = nil

   //# @a DBView used to determine if a certain view exists
   exists_view = nil

   //# Spacial variable to be set true when the wiki is not required to display pages.
   mute = false

   init
      //# force nest to load standard plugins
      Nest.addHook( "WikiPluginToc" )
      Nest.addHook( "WikiPluginTimestamp" )
   end
   
   //===================================================================
   // Main part
   //
   function startup()
      if not self.allowed(): return false

      dm = self.dm.value
      if Nest.pcheck
         if not dm.derivedFrom( DataManager )
            raise NestError( NestError.pcheck, "", "Mandatory parameter 'dm' not derived from DataManager" )
         end

         pv = self.parser.value
         if not (pv provides parse)
            raise NestError( NestError.pcheck, "",  "Must configure a parser in configuration" )
         end
      end

      self.setEntities( dm, self.ename.value )
      self.addJsRes( 'insertText.js' )
   end
   
   function run()
      Nest.logi( "Running service Wiki" )
      
      if not self.allowed(): return false

      if self.mute
         Nest.logi("Service muted")
         return false
      end

      // adding default upload linker
      if not self.upload_linker.value: self.upload_linker.value = {v => v}

      // sanitize the WID settings
      if not self.main_wid.value: self.main_wid.value = default_page
      if not self.wid.value
         wid = self.wid.value = self.main_wid.value
      else
         wid = self.wid.value
      end

      todo = self.wka.value
      Nest.logi( @"Executing $(todo) on \"$(wid)\"" )
      
      // save the history -- if required and if browsing the pages.
      depth = self.history_depth.value
      if depth and not todo
         h = self.history.value

         // force to clear when going to top
         if wid == self.main_wid.value or self.wkc.value == "h": h = nil
            
         if h
            pos = h.find( wid )
            if pos >= 0
               h.resize( pos+1 )
            elif depth > h.len()
               h += wid
            end
         else
            self.history.value = [wid]
         end
      end


      // see what we can do
      switch todo
         case 'del'
            if self.wkc.value
               self.removePage( wid )
            else
               self.skin.value = self.skin_confirm.value
            end

         case 'mody'
            page = self.entity.find( wid, self.edit_view )
            if page
               self.wkd.value = page.data.content_wiki
            else
               self.wkd.value = ""
            end
            self.skin.value = self.skin_modify.value
            
         case 'upd'
            data = self.getBlank()
            data.page_name = wid
            data.content_wiki = self.wkd.value 
            data.content_html = self.renderWiki( data.content_wiki, wid )
            data.creator = self.auth_user.value

            self.updatePage( data )
            self.page.value = data

         case 'prw'
            self.preview.value = self.renderWiki( self.wkd.value, wid )
            self.skin.value = self.skin_preview.value

         default
            self.page.value = self.getPage( wid )
      end
   end

   //============================================================================
   // Utilities
   //

   /*# Initializes the wiki system, creating the entity through the data manager.
      @param ename The name of the entity to be created.
   */
   function initialize( ename )
      if not self.allowed(): return false
      Nest.logi( "Initializing WIKI DB entities" )
      // parameter check should be already performed
      dm = self.dm.value
      self.setEntities( dm, ename )
      dm.createEntity( self.entity, true )
   end

   /*# Creates the entities in a data manager.
      @param dm The datamanager under which the WIKI entities are to be published.
      @param ename The name of the entity.
   */
   function setEntities( dm, ename )
      // set our entities in the database
      wp = wiki_entity( dm )
      name = ename ? ename : entity_name
      // add the entity to the datamanager
      dm.addEntity( wp )
      self.entity = wp

      // standard view for basic operations
      self.read_view = dbv.DBView( wp, .[
            dbv.DBViewField( "page_name", i"Page name" )
            dbv.DBViewField( "content_html", i"Html text" )
            dbv.DBViewField( "creator", i"Page creator" )
            dbv.DBViewField( "editor", i"Page editor" )
            dbv.DBViewField( "created", i"Created on" )
            dbv.DBViewField( "last_edited", i"Last edited on" )
      ])

      // view for edits
      self.edit_view = dbv.DBView( wp, .[
            dbv.DBViewField( "page_name", i"Page name" )
            dbv.DBViewField( "content_wiki", i"Wiki text" )
      ])

      // view for edits
      self.exists_view = dbv.DBView( wp, .[
            dbv.DBViewField( "page_name", i"Page name" )
            dbv.DBViewField( "creator", i"The creator of the page" )
            dbv.DBViewField( "created", i"When the page was created" )
            dbv.DBViewField( "last_edited", i"Last edited on" )
      ])

   end

   function linkToPage( page, handler )
      return Nest.pageLink( handler, ["wid"=>page])
   end

   function linkEditPage( page, handler )
      return Nest.pageLink( handler, ["wid"=>page, "wka"=>"mody"])
   end
   
   //============================================================================
   // Core
   //

   /*#
      @brief Returns the full record of the given page.
      @param page_name The id of the page to be retreived.
      @return The page data on success, nil on failure.
   */
   function getPage( page_name )
      page = self.entity.find( page_name, self.read_view )
      if page: return page.data
      return nil
   end

   /*#
      @brief Returns a blank page that can be used to fill the update parameters.
      @return A blank page record.
   */
   function getBlank()
      return self.entity.makeBlank()
   end


   /*#
      @brief Updates (or creates) a page with new contents.
      @param pageEntry The page entry to be sent to the db.
      @return true on success, false if the page cannot be created.
      @raise NestError in case of wiki generation or database error.
      
      if the pageEntry.comp_cnt value is not valorized, compiles automatically
      the wiki content.

      On success sends an "fmwiki_pupd" message.
   */
   function updatePage( pageEntry )
      Nest.logi( "Update request for " + pageEntry.page_name )
      
      // see if the page exists.
      page = self.entity.find( pageEntry.page_name, self.exists_view )
      if page
         // it existed!
         Nest.logi( "Update existing page: " + pageEntry.page_name )

         if pageEntry.creator and not pageEntry.editor 
            pageEntry["editor"] = pageEntry["creator"]
         end

         // the the page was already created
         pageEntry["last_edited"] = CurrentTime()
         pageEntry["creator"] = page.data.creator
         pageEntry["created"] = page.data.created
         self.entity.update( pageEntry.page_name, pageEntry )
      else
         Nest.logi( "Create new page: " + pageEntry.page_name )
         pageEntry["created"] = CurrentTime()
         self.entity.insert( pageEntry )
      end
   end


   function renderWiki( wikitext, pageName )
      try
         p = self.parser.value
         p.reset()
         ctx = p.parse( wikitext )
         hr = html.Renderer( self.helper, "nest_wiki" )
         
         return hr.render( ctx, pageName )
      catch ParseError in e
         raise NestError( NestError.other, i"Can't compile the wiki page", e.heading() )
      end
   end

   /*#
      @brief Removes a page.
      @param page_name The page to be removed.
      @return true on success, false if the page cannot be created.
   */
   function removePage( page_name )
      return self.entity.delete( page_name )
   end


   /*#
      @brief Loads a plugin and returns its result.
      @param page_name The page to be removed.
      @return true on success, false if the page cannot be created.
   */
   function plugin( pname, params, node, sout, page )
      // do we have some user-provided plugins?
      res = Nest.emit( "wiki_plugin_" + pname, params, node, sout, page )

      // still nothing?
      if res == nil and not sout
         return @i"<br/><b>WARNING:</b> Plugin \"<b>$pname</b>\" not found.<br/>"
      else
         return res
      end
   end

   //===================================================================
   // Utilities for the host site
   //
   
   /*# Returns the link that requests to delete the current page.
      @optparam wid The ID of the wiki page to be handled, or nil for current page.
      @optparam page If given, ask to handle the request to the given page ID.
      @return The href to follow to delete the current wiki page.
   */
   function linkDelete( wid, page )
      if not wid: wid = Request.getField("wid","main")
      return Nest.pageLink( page, ["wid"=>wid, "wka"=>"del"])
   end

   /*# Returns the link that requests to modify the current page.
      @optparam wid The ID of the wiki page to be handled, or nil for current page.
      @optparam page If given, ask to handle the request to the given page ID.
      @return The href to follow to modify the current wiki page.
   */
   function linkMody( wid, page )
      if not wid: wid = Request.getField("wid","main")
      return Nest.pageLink( page, ["wid"=>wid, "wka"=>"mody"])
   end

   /*# Returns the link that needed to follow a page.
      @optparam page If given, ask to handle the request to the given page ID.
      @return The href to follow to modify the current wiki page.
   */
   function linkGoToPage( wid, page )
      if not wid: wid = Request.getField("wid","main")
      return Nest.pageLink( page, ["wid"=>wid])
   end
   

end


class _WikiHelper(srv) from html.BaseSiteHelper
   // the service
   srv = srv
   handler = nil

   function pageLink( v )
      return self.srv.linkToPage( v, self.handler )
   end

   function img( v )
      return self.srv.upload_linker.value(v)
   end

   function file( v )
      return self.srv.upload_linker.value(v)
   end


   function plugin( plugin_name, params, node, standout, page )
      return self.srv.plugin( plugin_name, params, node, standout, page )
   end
end

class wiki_entity(dm) from dbe.DBEntity(dm)

   name = entity_name

   definition = (
         "sqlite" in dm.cs ?
         .[
            ^+ "page_name varchar(60) PRIMARY KEY"
            "content_wiki TEXT"
            "content_html TEXT"
            "creator varchar(30)"
            "editor varchar(15)"
            "created datetime"
            "last_edited datetime"
         ]
         :
         .[
            ^+ "page_name varchar(60) PRIMARY KEY"
            "content_wiki TEXT character set utf8"
            "content_html TEXT character set utf8"
            "creator varchar(30) charset utf8"
            "editor varchar(15) charset utf8"
            "created datetime"
            "last_edited datetime"
         ])
end



