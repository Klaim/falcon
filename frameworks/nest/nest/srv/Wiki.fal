/*
   FALCON - The Falcon Programming Language

   Nest - Falcon web applcation engine

   FILE: Wiki.fal

   Service managing wiki-like pages.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Fri, 20 Aug 2010 21:38:16 +0200

   -------------------------------------------------------------------
   (C) Copyright 2010: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

import Service from nest as Service
import ServiceVar from nest as ServiceVar
import from nest.bindings in b
import NestError from nest as NestError
import from nest.dbentity in dbe
import from nest.dbview in dbv
import from parser.render.html in html
import plugins from nest.srv.Wiki.plugins as Plugins
import DataManager from nest.datamanager as DataManager

const entity_name = "wiki_pages"
const default_page = "main"

/*# Service Managing WIKI based contents.
*/
class Wiki( instance ) from Service( instance )
   //# Wiki page to be loaded or managed
   wid = ServiceVar( b.InputVarBinder )
   //# Wiki action; 'del' 'mody' 'upd' 'prw' (none for view)
   wka = ServiceVar(b.InputVarBinder )
   //# Wiki data; original data
   wkd = ServiceVar( b.InputVarBinder )
   //# Wiki confirm; a page will be actually remove only if it's not null. Set to h to clear history.
   wkc = ServiceVar( b.InputVarBinder )

   
   //===========================================
   // Configuration.
   //# Data manager used by this WIKI instance -- must be a DataManager instance.
   dm = ServiceVar( b.ConfigBinder )
   //# Instance of a Wiki parser, implementing the Falcon wiki parser interface
   parser = ServiceVar( b.ConfigBinder )
   //# Function retunring a link to uploaded files.
   upload_linker = ServiceVar( b.ConfigBinder )
   //# Wid of the main page (which is also the default wid)
   main_wid = ServiceVar( b.ConfigBinder )
   //# Actions that can be done other than "commit" on a page
   actions = ServiceVar( b.ConfigBinder )
   //# Page used when invoking the wiki page modification
   modyPage = ServiceVar( b.ConfigBinder )
   //# Max depth of the wiki history
   history_depth = ServiceVar( b.ConfigBinder )
   //# User provided page plugins
   plugins = ServiceVar( b.ConfigBinder )

   //===================================================================
   // Internal variables
   
   //# Compiled content of the page
   preview = ServiceVar()
   //# Complete page -- if found
   page = ServiceVar()

   // Gets the authenticated user.
   auth_user = Nest.ambient( "auth_user", b.SessionBinder )
   //# Wiki history; where are we?
   history = ServiceVar( b.SessionBinder )

   helper = _WikiHelper(self)

   //# Wiki Page entity @a DBEntity in the Data Manager
   entity = nil

   //# @a DBView used to read a page
   read_view = nil

   //# @a DBView used to edit a page
   edit_view = nil

   //# @a DBView used to determine if a certain view exists
   exists_view = nil

   //# Spacial variable to be set true when the wiki is not required to display pages.
   mute = false

   //===================================================================
   // Main part
   //
   function startup()
      if not self.allowed(): return false

      dm = self.dm.value
      if Nest.pcheck
         if not dm.derivedFrom( DataManager )
            raise NestError( NestError.pcheck, "", "Mandatory parameter 'dm' not derived from DataManager" )
         end

         pv = self.parser.value
         if not (pv provides parse)
            raise NestError( NestError.pcheck, "",  "Must configure a parser in configuration" )
         end
      end

      self.setEntities( dm )
   end
   
   function run()
      Nest.logi( "Running service Wiki" )
      
      if not self.allowed(): return false

      if self.mute
         Nest.logi("Service muted")
         return false
      end

      // adding default upload linker
      if not self.upload_linker.value: self.upload_linker.value = {v => v}

      // sanitize the WID settings
      if not self.main_wid.value: self.main_wid.value = default_page
      if not self.wid.value
         wid = self.wid.value = self.main_wid.value
      else
         wid = self.wid.value
      end

      todo = self.wka.value
      Nest.logi( @"Executing $(todo) on \"$(wid)\"" )
      
      // save the history -- if required and if browsing the pages.
      depth = self.history_depth.value
      if depth and not todo
         h = self.history.value

         // force to clear when going to top
         if wid == self.main_wid.value or self.wkc.value == "h": h = nil
            
         if h
            pos = h.find( wid )
            if pos >= 0
               h.resize( pos+1 )
            elif depth > h.len()
               h += wid
            end
         else
            self.history.value = [wid]
         end
      end


      // see what we can do
      switch todo
         case 'del'
            if self.wkc.value
               self.removePage( wid )
            end

         case 'mody'
            page = self.entity.find( wid, self.edit_view )
            if page
               self.wkd.value = page.data.content_wiki
            else
               self.wkd.value = ""
            end
            
         case 'upd'
            data = self.getBlank()
            data.page_name = wid
            data.content_wiki = self.wkd.value 
            data.content_html = self.renderWiki( data.content_wiki, wid )
            data.creator = self.auth_user.value

            self.updatePage( data )
            self.page.value = data

         case 'prw'
            self.preview.value = self.renderWiki( self.wkd.value, wid )

         default
            self.page.value = self.getPage( wid )
      end
   end

   //============================================================================
   // Utilities
   //

   function initialize()
      if not self.allowed(): return false
      Nest.logi( "Initializing WIKI DB entities" )
      // parameter check should be already performed
      dm = self.dm.value
      self.setEntities( dm )
      dm.createEntity( self.entity, true )
   end


   function setEntities( dm )
      // set our entities in the database
      wp = wiki_entity( dm )
      // add the entity to the datamanager
      dm.addEntity( wp )
      self.entity = wp

      // standard view for basic operations
      self.read_view = dbv.DBView( wp, .[
            dbv.DBViewField( "page_name", i"Page name" )
            dbv.DBViewField( "content_html", i"Html text" )
            dbv.DBViewField( "creator", i"Page creator" )
            dbv.DBViewField( "editor", i"Page editor" )
            dbv.DBViewField( "created", i"Created on" )
            dbv.DBViewField( "last_edited", i"Last edited on" )
      ])

      // view for edits
      self.edit_view = dbv.DBView( wp, .[
            dbv.DBViewField( "page_name", i"Page name" )
            dbv.DBViewField( "content_wiki", i"Wiki text" )
      ])

      // view for edits
      self.exists_view = dbv.DBView( wp, .[
            dbv.DBViewField( "page_name", i"Page name" )
            dbv.DBViewField( "creator", i"The creator of the page" )
            dbv.DBViewField( "created", i"When the page was created" )
            dbv.DBViewField( "last_edited", i"Last edited on" )
      ])

   end

   function linkToPage( page, handler )
      return Nest.pageLink( handler, ["wid"=>page])
   end

   function linkEditPage( page, handler )
      return Nest.pageLink( handler, ["wid"=>page, "wka"=>"mody"])
   end
   
   //============================================================================
   // Core
   //

   /*#
      @brief Returns the full record of the given page.
      @param page_name The id of the page to be retreived.
      @return The page data on success, nil on failure.
   */
   function getPage( page_name )
      page = self.entity.find( page_name, self.read_view )
      if page: return page.data
      return nil
   end

   /*#
      @brief Returns a blank page that can be used to fill the update parameters.
      @return A blank page record.
   */
   function getBlank()
      return self.entity.makeBlank()
   end


   /*#
      @brief Updates (or creates) a page with new contents.
      @param pageEntry The page entry to be sent to the db.
      @return true on success, false if the page cannot be created.
      @raise NestError in case of wiki generation or database error.
      
      if the pageEntry.comp_cnt value is not valorized, compiles automatically
      the wiki content.

      On success sends an "fmwiki_pupd" message.
   */
   function updatePage( pageEntry )
      Nest.logi( "Update request for " + pageEntry.page_name )
      
      // see if the page exists.
      page = self.entity.find( pageEntry.page_name, self.exists_view )
      if page
         // it existed!
         Nest.logi( "Update existing page: " + pageEntry.page_name )

         if pageEntry.creator and not pageEntry.editor 
            pageEntry["editor"] = pageEntry["creator"]
         end

         // the the page was already created
         pageEntry["last_edited"] = CurrentTime()
         pageEntry["creator"] = page.data.creator
         pageEntry["created"] = page.data.created
         self.entity.update( pageEntry.page_name, pageEntry )
      else
         Nest.logi( "Create new page: " + pageEntry.page_name )
         pageEntry["created"] = CurrentTime()
         self.entity.insert( pageEntry )
      end
   end


   function renderWiki( wikitext, pageName )
      try
         p = self.parser.value
         p.reset()
         ctx = p.parse( wikitext )
         hr = html.Renderer( self.helper, "nest_wiki" )
         
         return hr.render( ctx, pageName )
      catch ParseError in e
         raise NestError( NestError.other, i"Can't compile the wiki page", e.heading() )
      end
   end

   /*#
      @brief Removes a page.
      @param page_name The page to be removed.
      @return true on success, false if the page cannot be created.
   */
   function removePage( page_name )
      return self.entity.delete( page_name )
   end


   /*#
      @brief Loads a plugin and returns its result.
      @param page_name The page to be removed.
      @return true on success, false if the page cannot be created.
   */
   function plugin( pname, params, node, sout )
      // do we have some user-provided plugins?
      upl=self.plugins.value
      if upl and upl.typeId == DictionaryType and pname in upl
        pin = upl[pname]
      end

      // not found a valid user plugin ---  try ours
      if pin == nil
         pin = pname in Plugins ? Plugins[pname] : nil
      end

      // still nothing?
      if pin == nil 
         return @i"Plugin $pname not found"
      else
         return pin( params, node, sout, self.wid.value )
      end
   end
   
end


class _WikiHelper(srv) from html.BaseSiteHelper
   // the service
   srv = srv
   handler = nil

   function pageLink( v )
      return self.srv.linkToPage( v, self.handler )
   end

   function img( v )
      return self.srv.upload_linker.value(v)
   end

   function file( v )
      return self.srv.upload_linker.value(v)
   end


   function plugin( plugin_name, params, node, standout )
      return self.srv.plugin( plugin_name, params, node, standout )
   end
end

class wiki_entity(dm) from dbe.DBEntity(dm)

   name = entity_name

   definition = (
         "sqlite" in dm.cs ?
         .[
            ^+ "page_name varchar(60) PRIMARY KEY"
            "content_wiki TEXT"
            "content_html TEXT"
            "creator varchar(30)"
            "editor varchar(15)"
            "created datetime"
            "last_edited datetime"
         ]
         :
         .[
            ^+ "page_name varchar(60) PRIMARY KEY"
            "content_wiki TEXT character set utf8"
            "content_html TEXT character set utf8"
            "creator varchar(30) charset utf8"
            "editor varchar(15) charset utf8"
            "created datetime"
            "last_edited datetime"
         ])
end



