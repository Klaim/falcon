/*
   FALCON - The Falcon Programming Language

   Nest - Falcon web applcation engine

   FILE: widget.fal

   Basic definition for the AJAX widgeting subsystem.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Mon, 26 Sep 2011 11:55:58 +0200

   -------------------------------------------------------------------
   (C) Copyright 2011: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

import from json in json

/*# Represents a request that could be sent via AJAX back to a widget.
   @optparam rp Required properties (data that must be sent back to us).
   @optparam extra Extra parameters that should be sent back here.
   @potparam jsPrefix A javascript code that should be invoked before launching the ajax request.

   This class is used to store the parameters of AJAX requests that the widgets
   rendered on a web site could send back to to their server-side counterparts.

   It has a set of required properties and a set of extra fixed parameters.
   The properties are a list of strings that represent a property in the rendered
   widget or in a sibling or parent widget.

   Property names are represented as path, relative to this widget. For instance,
   - "value" reprsents the text value of this object.
   - "../value" represents the text value of the parent object.
   - "../sibling/value" represents the text value of an object called "sibling"
     being rendered at the same level of this widget.
   - "/a/b/value" is the text value of a widget "b" under widget "a" in the
     topmost widget parent of this one.

   If the path starts with a "*", then the NAME of the target item is
   used to return the value.

   Any DOM element property can be queried this way and sent back to the receiving
   application, that will receive it in a "infos" entry, named after the relative
   property name that has been given ("value" => value,
   "../sibling/value" => "sibling.value" and so on).
*/
class AJAXRequest( rp, extra, jsPrefix )
   reqProps = rp
   extra = extra
   jsPrefix = jsPrefix

   function renderReqProps()
      if self.reqProps: return json.JSONencode( self.reqProps ).replace( "\"", "'" )
      return "null"
   end

   function renderExtra()
      if self.extra: return htmlEscape(json.JSONencode( self.extra )).replace( "\"", "'" )
      return "null"
   end

   /*# Renders an AJAX request bound with this widget. */
   function render( hostName, id, message )
      rps = self.renderReqProps()
      extra = self.renderExtra()
      rend = "Nest.widgetAJAX('" + hostName + "', '" +
                       id + "', '"+message+"', " +rps+ ", " + extra +")"

      if self.jsPrefix
         return self.jsPrefix +";"+ rend
      else
         return rend
      end
   end

end

/*# Base class for the widgeting system.
   @param id The id of the widget as know in the HTML/AJAX rendering.

   @note All the widget subclasses willing to become AJAX hosts MUST
   have an @b id parameter as their @b first parameter in the class
   constructor. This @b id parameter will be propagated through the
   widget hierarcy up to this base class, always as first parameter.

*/

class Widget( id )
   //# 'local' ID of this widget in the DOM model.
   id = id

   //# HTML Tag associated with this widget.
   tag = "div"

   //# HTML properties associated with this widget at DOM level.
   props = nil

   //# Javascript callbacks resolving in a NEST widget ajax request.
   ajaxReqs = nil

   //# Custom message handlers.
   ajaxMessages = nil

   //# list of children.
   children = []

   //# dictionary of children ordered by their ID.
   childrenById = nil

   //# parent of this widget.
   parent = nil

   /*# Dictioanry of javascript methods to be added to this widget.
      Each entry is a method that can be invoked on the javascript side.
      The key is the method name, and the value must be a full javascript
      function declaration.
   */
   jsMethods = [=>]

   /*# Dictioanry of javascript Listeners
      Each entry is a method that can be invoked on the javascript side.
      The key is the method name, and the value must be a full javascript
      function declaration.
   */
   jsListeners = [=>]

   //# Some widget cannot be closed with the XML self-closing tag.
   isSelfClosing = false

   //# Method invoked at javascript level after rendering.
   onCreate = nil

   /*# If true, this is a ajax host, and can receive ajax messages directly.
   */
   isAJAXHost = false

   /*# If true, this widget is also a value host (i.e. has value in forms).
   */
   isValueHost = false

   /*# Init informations.
      This are the parameters that must be repeated to create a copy of this widget.
      The @b id field alone needs not to be repeated as it is automatically
      added in front of every initialization information as the widget is
      created to fulfil AJAX host requests.
   */
   initInfos = nil

   //# Name of the field in a data provider associated with this widget
   datafield = nil
   
   //# Text or widget used as label/prompt form or form-like widgets
   label = nil

   //# Text or widget associated with this field in form or form-like widgets
   fieldInfo = nil

   //# Thing to be added automatically to names when generating the name field.
   addName = nil

   //# Set true to put label AFTER the main widget in standard representation
   labelsOnRight = false

   //# Stylesheet for this item for automated stilesheet generation in page
   idStyles = nil
   
   //# Stylesheet for this class of items, for automated stilesheet generation in page
   classStyles = nil

   //# TODO: remove when we have automatic parentship
   _parentship = []
   
   init
      Nest.requireJS("base")      
      Nest.subscribeWidget( self )

      // TODO: use parentship in new engine to have Nest do it automagically
      self.addClassInParentship( Widget )
   end

   //# Invoked by widget creation in Nest framework
   function setup()
      self.onSetup()
      
      rend = self.renderJSMethods()
      rend += self.renderAJAXReqs()
      // Listeners go after methods, as listener usually refer to methods.
      rend += self.renderAJAXMessages()
      rend += self.renderJSListeners()
      if self.isAJAXHost
         rend += self.renderInitInfos()
      end
      
      if self.onCreate
         if self.onCreate.isCallable()
            value = self.onCreate()
         else
            value = self.onCreate
         end
         rend += "element.onCreate = function(){"+ value + ";}\n"
      end
      
      if rend: return "element=Nest.i('" + self.getFullID() + "');\n" + rend
   end

   /*# Called back at widget creation.
      This is invoked when all the structure of the widget is complete.
      Here the widget should initialize:
      - jsMethods
      - jsListeners
      - ajaxMessages
      - ajaxReqs
   */
   function onSetup()
   end

   //# Adds a child to this widget.
   function addChild( wid )
      wid.parent = self
      self.children += wid
      if self.childrenById
         self.childrenById[wid.id] = wid
      else
         self.childrenById = [ wid.id =>wid ]
      end
   end

   //# Shortcut to add multiple children
   function addChildren()
      for child in passvp()
         self.addChild( child )
      end
   end

   /*# Adds children to this widget using a list of string.
      @optparam choices An array of choices (strings).

      This method adds automatically a set of common children which
      depends on the parent subwidget type. Container classes that
      accept this automatic child addition protocol must provide
      an overload for @a Widget.makeAutoChild, which returns the
      created widget, or nil if the widget cannot be created.
      
      Each element in choice is a string with the following format:
      "value:text". If ':' is not in the choice string, then the whole text will
      be used both as a submit value and as a text.

      If the value part is preceeded by an asterisk (*), then the entry will be
      checked, selected, specially marked or put in evidence, depending on the
      type of container.

      If the text part ends with a dollar mark ('$'), then the label is placed
      at right in rendering.
   */
   function autoAddChildren( choices )
      for value in choices
         if (pos = value.find(':')) >= 0
            text = value[pos+1:]
            value = value[0:pos]
         else
            // don't copy, so the changes we do below apply to both
            text = $value
         end

         if value.startsWith( '*' )
            checked = true
            value = value[1:]
         else
            checked = false
         end

         if text.endsWith('$')
            text = text[0:-1]
            onRight = true
         else
            onRight = false
         end

         child = self.makeAutoChild( value, text, checked )
         if child
            child.labelsOnRight = onRight
            self.addChild( child )
         end
      end
   end

   /*# Callback used by autoAddChildren to create a proper child for this container.
      @param value The value of this choice when submitted.
      @param text The text or label associated with this choice.
      @optparam checked If true, the element check or highlight should be actived.
      @return A valid widget for the subclass container or nil if the widget cannot
         be created.
   */
   function makeAutoChild( value, text, checked )
      return nil
   end

   /*# Method used to set properties of the widget.
      @param props the properties to be set in the widget.
      @return the widget itself.
   */
   function set( props )
      if self.props == nil
         self.props = props
      else
         self.props += props
      end
      return self
   end

   //# Renders an XHTML representation of this widget.
   function render()
      if self.labelsOnRight
         return self.renderCore() + self.renderLabel() + self.renderInfo()
      else
         return self.renderLabel() + self.renderCore() + self.renderInfo()
      end
   end

   function renderCore()
      id = self.getFullID()
      
      // first calculate a default name, if required ...
      if 'name' in self.props
         name = id
         if self.addName: name += self.addName
         self.props['name'] = name
      end

      // and the class for the CSS
      // TODO: use the proper parentship on the new engine.
      if self.classStyles or Nest.hasOneOfClassStyles( self._parentship ): self.CSSClassID()
      
      // ... then allow the widget to self-render.
      self.onRender()

      // render attributes -- if we have a tag we're an element in the document.
      if self.tag
         rend = "<" + self.tag + " id=\"" + id + "\" "
         rend += self.renderProps()

         if self.isSelfClosing and not self.children
            rend += "/>"
         else
            rend += ">"
            rend += self.renderContent()
            rend += "</" + self.tag +">\n"
         end
      else
         rend = ""
         if self.isAJAXHost
            // in case of ajax hosting, we need a "mute div" to have a document entity with our name.
            rend +="<div id=\""+id+"\" style=\"display:none\"></div>"
         end
         
         // otherwise we're just a set of children entities.
         rend += self.renderContent()
      end

      return rend
   end


   function renderJSMethods()
      rend = ""

      for mthName, mthDef in self.jsMethods
         // Add a ; just in case
         if mthDef.isCallable()
            mthDef = mthDef()
         end
         rend += "element." + mthName + "=" + mthDef + ";\n"
      end

      return rend
   end


   function renderAJAXReqs()
      rend = ""
      for key, value in self.ajaxReqs
         forfirst
            id = self.getFullID()
            hostName = self.ajaxHostName()
         end

         req = value.render( hostName, id, key )
         rend += "element." + key + "=function(){" + req + ";};\n"
      end
      return rend
   end
   

   function renderJSListeners()
      rend = ""
      for widget, mthDef in self.jsListeners
         rend += "Nest.listen( element, '"+ widget.getFullID() + "'," + mthDef + ");\n"
      end
      return rend
   end

   /*# Renders the contents of this widget.
      @return A string with the full HTML contents of this widget rendered.

      @note A sub-widget may define renderPrompt method to differentiate
      the prompt from the main body.
   */
   function renderContent()
      rend = ""
      for child in self.children
         forfirst: rend += "\n"
         rend += child.renderInParent( self ) +"\n"
      end
      return rend
   end

   /*# Allows children to be rendered back by a parent.
      @param parent The parent where the child is being rendered.

      Override this if you want the children to have specific
      behavior when rendered in some parent.

      The default behavior is that to call directly parent.renderChild().
   */
   function renderInParent( parent )
      return parent.renderChild( self )
   end

   /*# Override this for personalized label/content/info display
      @param child The child to be rendered.

      The default is to put a br tag after each child.
   */
   function renderChild( child )
      return child.render() + "<br/>"
   end

   function renderLabel()
      if self.label
         if self.label provides render: return self.label.render()
         return self.label
      end
      return ""
   end

   function renderInfo()
      if self.fieldInfo
         if self.fieldInfo provides render: return self.fieldInfo.render()
         return self.fieldInfo
      end
      return ""
   end

   //# private
   function renderInitInfos()
      id = self.getFullID()         

      if self.initInfos
         obj = json.JSONencode( [id] + self.initInfos )
      else
         obj =  "[\"" + id +"\"]"
      end

      rend = @"element.Nest_initInfo = $(obj);\n"
      return rend
   end

   //# private
   function renderProps()
      rend = ""
      for key, value in self.props
         rend += key + "=\"" + htmlEscape(toString(value)) + "\""
         formiddle: rend += " "
      end
      return rend
   end




   //# private
   function renderAJAXMessages()
      rend = ""
      for key, value in self.ajaxMessages
         rend += "Nest.messageHandlers['" + key +"']=" + "{ object: element, method: " + value + "};\n"
      end

      return rend
   end

   /*# Returns the full ID of this widget (including the parent ones).
      @return A string representing the full ID of this widget at DOM model level.

      The full-id of a widget is its own ID preceded by a dot-separated list
      of the parent ids up to the root.
   */
   function getFullID()
      if self.parent
         pid = self.parent.getFullID()
         if pid.typeId() != StringType
            inspect( pid )
         end
         return  pid + "." + self.id
      end

      return self.id
   end

   /*# Get the topmost widget class name. */
   function parentName()
      if self.parent
         return self.parent.parentName()
      end
      return self.className()
   end

   /*# Get the topmost widget class name with ajax host capabilities. */
   function ajaxHostName()
      if self.isAJAXHost or not self.parent
         return self.className()
      else
         return self.parent.ajaxHostName()
      end
   end


   /*# Utility get ourselevs at Javascript level during render.
      Returns a string defined as document.getElementById('"+self.getFullID()+ "')
      @note getFullID() is completely defined only at render time.
   */
   function getJSSelf()
      return "document.getElementById('"+self.getFullID()+ "')"
   end
   
   /*# Utility to emit a callback message.
      @param msg The name of the message generated by the widget in the browser page.
      @param value A value associated with the message (may be any valid javascript expression).

      To be used in form
      @code
      wid.jsMethods = [
         "onclick" => wid.makeEmit( "onclick", "this.value" )
      ]
      @endcode
   */
   function makeEmit( msg, value )
      return "function(){ Nest.message(this, '" + msg + "', " + value +"); }"
   end

   function makeInvoke( method, param )
      param = json.JSONencode( param )
      id = self.getFullID()
      return @"function() { Nest.processMessage({ message:'invoke', id:\"$(id)\", method:\"$(method)\", param:$(param)});}"
   end

   function makeSetProperty( prop, value )
      id = self.getFullID()
      return @"function(){Nest.processMessage({ message:'set', id:\"$(id)\", property:\"$(prop)\", value:\"$(value)\"});}"
   end

   function makeSetStyle( prop, value )
      id = self.getFullID()
      return @"function(){Nest.processMessage({ message:'set_style', id:\"$(id)\", property:\"$(prop)\", value:\"$(value)\"});}"
   end

    /*# Utility to create the code to invoke a nest javascript local message.
      @param msg The name of the message generated by the widget in the browser page.
      @param value A value associated with the message (may be any valid javascript expression).

      @note The value member is directly placed in the javascript invocation; if it's meant to
      be a string, proper quotes must be added inside the string.
   */
   function jsEmit( msg, value )
      return "Nest.message(this, '" + msg + "', " + value +");"
   end

   function jsInvoke( method, param )
      param = json.JSONencode( param )
      id = self.getFullID()
      return @"Nest.processMessage({ message:'invoke', id:\"$(id)\", method:\"$(method)\", param:$(param)});"
   end

   function jsSetProperty( prop, value )
      id = self.getFullID()
      return @"Nest.processMessage({ message:'set', id:\"$(id)\", property:\"$(prop)\", value:\"$(value)\"});"
   end

   function jsSetStyle( prop, value )
      id = self.getFullID()
      return @"Nest.processMessage({ message:'set_style', id:\"$(id)\", property:\"$(prop)\", value:\"$(value)\"});"
   end
   
   /*# Utility to generate a method calling another method.
      @param funcname The name of the message generated by the widget in the browser page.
      @optparam ... Other values to be passed in the call.

      Can be put into any nest widget.
      @code
      wid.jsMethods = [
         "onclick" => wid.makeCall( "onclick", "this.value" )
      ]
      @endcode
   */
   function makeCall( funcname )
      v = passvp()
      if v
         vals = ",".merge(map({x=>"\""+toString(x).escape()+"\""}, v))
      else
         vals = ""
      end
      return "function(){Nest.i(\""+self.getFullID()+"\")."+funcname+"("+ vals +");}"
   end
   
   /*# Utility to generate a direct JS call to this nest widget.
      @param funcname The name of the message generated by the widget in the browser page.
      @optparam ... Other values to be passed in the call.

      Can be put into any nest widget.
      @code
      wid.jsMethods = [
         "..." => "function(){ ...." +  wid.jCall( "onclick", "this.value" ) +".something; ...}"
      ]
      @endcode
   */
   function jsCall( funcname )
      v = passvp()
      if v
         vals = ",".merge(map({x=>"\""+toString(x).escape()+"\""}))
      else
         vals = ""
      end
      return "Nest.i(\""+self.getFullID()+"\")."+funcname+"("+ vals +")"
   end
   
   /*# Called back right before rendering.
      Widget are often created and then added to a parent. This means that
      the information about their hierarcy is not ready at creation,
      but it's ready at render. This callback allows to do last setups
      before the widget is rendered.
   */
   function onRender()
   end

   /*# Sets the value of the widget before its rendering.
   */
   function setRenderValue( val )
      if self.props == nil: self.props = [=>]
      self.props['value'] = val
   end

   /*# Gets a pre-render value set in the widget.
      @return A value that is known to be associated with this widget.
      
      Possibly overridable; the default is to peek the value in the 'value' property.
      Complex widgets as containers may have different definitions of their value.
   */
   function getValue()
      if self.props and 'value' in self.props: return self.props['value']
      return nil
   end
   
   /*# Route a set of incoming post values in a widget hierarcy.
      @param vals A dictionary of routable values.
      @param top ID of the parent widget.
   */
   function routeValues( vals, top )
      //> "Routing at "+top+"<br/>"
      current = top ? top+"."+self.id : self.id
      if current in vals
         //> "Rendering "+vals[current]+"<br/>"
         self.setRenderValue( vals[current] )
      end
      //> "Subroutong... <br/>"
      for item in self.children
         item.routeValues( vals, current )
      end      
   end
   
   /*# Adds this style to the 'style' property of this widget. */
   function addStyle( style )
      if not self.props
         self.props = ["style" => style]
      else
         if "style" in self.props
            self.props["style"] += ";" + style
         else
            self.props["style"] = style
         end
      end
   end

   function ajaxMsg( msg, infos, extra )
      infos_s = infos ? json.JSONencode( infos ) : "null"
      extra_s = extra ? json.JSONencode( extra ) : "null"

      return "Nest.widgetAJAX('" + self.ajaxHostName() +
               "', '" + self.getFullID() + "', '" + msg + "', " +
               infos_s + ", " + extra_s + ");"
   end

   function ajaxMsgLiteral( msg, infos, extra )
      infos_s = infos ? infos : "null"
      extra_s = extra ? extra : "null"

      return "Nest.widgetAJAX('" + self.ajaxHostName() +
               "', '" + self.getFullID() + "', '" + msg + "', " +
               infos_s + ", " + extra_s + ");"
   end

   //===================================================
   // Data management
   //

   function setData( provider )
      if self.datafield
         provider.set( self.datafield, self.getValue() )
      end

      for child in self.children
         child.setData( provider )
      end
   end

   function getData( provider )
      if self.datafield
         // the data provider is bound to raise if the field is not valid.
         self.setRenderValue( provider.get( self.datafield ) )
      end

      for child in self.children
         child.getData( provider )
      end
   end
   
         
   
   //===================================================
   // CSS batch generator interface
   //

   function CSSClassID()
      if self.props == nil
         CSS_id = "nest_widget_" + self.className()
         self.props = ["class"=> CSS_id]
      elif "class" notin self.props
         CSS_id = "nest_widget_" + self.className()
         self.props["class"] = CSS_id
      else
         CSS_id = self.props["class"]
      end

      return CSS_id
   end

   // TODO: use parentship in new engine to have Nest do it automagically
   function addClassInParentship( cls )
      name = cls.className()
      self._parentship += name
   end

   function addStyleAsID( style )
      if self.idStyles
         self.idStyles += style
      else
         self.idStyles = [style]
      end
   end

   function addStyleAsClass( style )
      if self.classStyles
         self.classStyles += style
      else
         self.classStyles = [style]
      end
   end

   function pickClassStyles( classStyleDict )
      result = nil
      for item in self._parentship
         if item in classStyleDict
            if not result
               result = [] + classStyleDict[item]
            else
               result += classStyleDict[item]
            end
         end
      end

      if result
         if self.classStyles: result += self.classStyles
      elif self.classStyles
         result = self.classStyles
      end

      return result
   end
   
   //===================================================
   /*# Route ajax requests.
      @params The parameters generated by the remote ajax request.
      @return A dictionary that is rendered as JSON and passed back.

      The default base class implementation does nothing.
   */
   function AJAX( params )
      return [=>]
   end

   //# Generates a set-property message
   function msgSetProperty( prop, value )
      return [
         "message" => "set",
         "id" => self.getFullID(),
         "property" => prop,
         "value"=>value ]
   end

   //# Generates a set-property message
   function msgSetStyle( prop, value )
      return [
         "message" => "set_style",
         "id" => self.getFullID(),
         "property" => prop,
         "value"=>value ]
   end

   //# Generates a invoke method message
   function msgInvoke( method, data )
      return [
         "message" => "invoke",
         "id" => self.getFullID(),
         "method" => method,
         "param"=> data ]
   end

   //# Generates a generic message
   function msgGeneric( message, value )
      if value == nil: value = [=>]
      value[ "message" ] = message
      return value
   end

   //# Generates a message to reset the values of all the children
   function msgSetAllValues( arr )
      if not arr: arr = []
      if self.isValueHost
         arr.add(
            [ "message" => "set",
               "id" => self.getFullID(),
               "property" => "value",
               "value" => self.getValue() ] );
      end

      for child in self.children
         child.msgSetAllValues( arr )
      end
      
      return arr
   end
end
