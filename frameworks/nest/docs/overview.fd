/*#
@page overview Nest Overview
@after main

In this section, we'll introduce the basic components that makes
up a Nest application, as well as the concepts that must be known
by an application designer to write a Nest application.

Although not strictly necessary, it's advisable to read this
chapter prior moving to the quick start, so that the code written
there can be understood in a broader context.

@section arch Overall architecture

Nest is mainly organized into the following of elements:

- Library
- AJAX support
- Widgets
- Hooks
- Modules

The library is a set of common functions and objects that are exposed to the nest components
and to third party users, as the final application.

__Modules__ are generic plugins known and loaded by "name". They offer a minimal support
for the web application and third party module writers to integrate with Nest. The idea is
that copying a module file and its resources in place should be enough to have the module
functionalities ready for use in the final web application on a remote web site.

__Hooks__ are callback points invoked by the other elements that can be overridden by the 
host application, so that it can provide new functionalities either dynamically or statically 
- but on a per-site basis.

__AJAX__ support is a feature that integrates AJAX server-side functionalities into
the Nest framework. While Nest doesn't prevent using direct AJAX calls (either via
raw calls to server-side scripts respecting the AJAX protocol or via the WebAPI Falcon
wrapper), Nest programmers may find useful to use the nest AJAX facilities so that
the server-side function scripts can see everythign a standard Nest page can see:
session variables, services, data managers and so on.

__Widgets__ are visual elements that are rendered client-side (on the target browser),
and that have support for both dynamic HTML/css/javascript programming and AJAX automation.
Widgets can be deemed as AJAX hosts, so that they can dynamically exchange contents
with their server-side AJAX host counterpart almost transparently to the web site
programmer. Also, Widgets are extensible via sub-classing, and this feature can
be used to wrap client-side widgets (i.e. those provided by third party client-side
web programming libraries as JQuery and Mootools) into AJAX hosts. 

Nest also provides a small javascript library that implements some common functionalities
of the common AJAX features of Nest widgets and AJAX hosting; this library can be
also used stand-alone. For instance, instead of writing a Nest-side widget wrapper around
a widget in an external JS library, a web programmer may just use the Nest JS
library to send raw AJAX request to a Nest-enabled server.

@section appenv Nest application anatomy

An application is composed of __pages__, each one presenting exactly one view to the remote
guest. An entry point (generally index.fal) loads the Nest system and performs what is called
__routing__. This consists in determining which page should be delivered to the user depending
on the input variables.

The routed page is then loaded as a Falcon plugin (via the reflexive compiler interface) and
executed in the current virtual machine context. This makes all the Nest system available to
the loaded script. 

Nest modules are themselves plugins which the routed page can load through the facilities
provided by Nest. Services work as abstract processors that can process input from several
soruces and then can be shown int the final page through a method that is named __render__.

Nest Widgets are simply stand-alone classes that have facilities to generate standardized 
HTML code, having also some utilities to generate javascripts hooks and callbacks. Also,
they can be especially exposed to Nest so that they can receive and respond to AJAX
messages generated by their visible counterpart on browser side; yet, if only dynamic
javascript is needed, while connection with the AJAX server is not necessary, the Nest
framework doesn't need the widgets to be especially published. Otherwise, widgets with
AJAX capabilities must be published in the appropriate place so that Nest can load
them directly as modules.

@section sitestruct Nest site structure

Before descending in the details of the Nest routing process, it is useful to describe how
Nest site and modules are structured and layed down.

Nest system has its own installation location and structure, which is not necessarily related
to the way sites using Nest should be organized; at site developer level, the Nest module and
utilities are opaque, and all that's required is that Nest and its components are correctly
installed as a Falcon module somewhere in the **FALCON_LOAD_PATH**, or even directly in the default
Falcon module location (e.g. /usr/lib/falcon).

Also, here we'll describe the default site structure; the vast majority of this settings can
be changed, even dynamically, through configuration options that are explained later.

Consider the entry point of an application a script in a given location; usually, but not necessarily,
the script is also the default script for the given directory (e.g. index.fal).

Then, the site will be organized as follows:

@code
   /homedir
      index.fal
      /nest
         /ajax
         /pages
         /mod
         /res
         /hooks
         /widgets
@endcode

The **nest** directory is called __root in the nest tree__ or referred as __nest tree__.

- The **nest/ajax** subdirectory contains the AJAX functions, one per script.
- The **nest/pages** subdirectory contains the pages.
- The **nest/mod** subdirectory contains modules and/or their configuration.
- The **nest/res** subdirectory contains data files that can be served through a request to
  nest. Having an out-of-site resource directory can help creating modules that install their
  needed resources away from the direct reach of the web server.
- The **nest/hooks** directory contains __static hooks__, or entry points and callback functions
  that the site prefer to have statically stored as a separate module. As hooks are little more than
  callback functions, the site may just present them to the Nest system from the entry point or from
  the pages where they are relevant, but this is a simple way to setup a callback function that is
  valid throughout all the site.
- The **nest/widgets** contains those widgets that must be published as AJAX hosts. Widgets that
  don't need AJAX interaction can be declared elsewhere, for instance even in the page they are used.
  A module in widgets directory can store only one AJAX host widgets, whose class must be named
  exactly as the module (extension excluded), but it can contain any number of other non-host
  widget classes.

@note It is advisable to place the __nest tree__ outside the scope of the directories served by the web
server, if possible, to minimize security risks. The default is to search it right under the entry
point script **just** because some low-cost web hostings don't allow to write data outside the scope of the
directories served by the provided web server.

@section ov_routing Page routing

Typical applications will want to load more pages from a site, depending
on the connection status and input parameters. This process of selection of the
page that is served by Nest to the remote user is called __routing__ and can be
widely configured. However, the default mechanism is usually enough to serve the
needs of even complex web applications; it consists of serving the page named
after an input variable called **pid**. For example, an url like

@code
   http://www.mysite.com/index.fal?pid=user_settings
@endcode

would search for a falcon module named {{user_settings.fal}} or {{user_setting.ftd}}
(or their equivalent **fam** module), in the **nest/pages** directory, and run it as
a nest page.

If the "pid" variable is not given, the default routing scheme will fallback to the
page ID **home**. This is configurable as well.

@note AJAX functions are routed through the variable 'aid' and widget AJAX hosts
are routed through the 'wid' variable. Theese routing rules cannot be overridden,
while a special class called Router can be provided to change the rules used to
determine the page served by Nest.

@section ov_framing Framing

Sites, and especially web applications, are usually providing a common code that is
consistent throughout all the areas, which sourrounds the web site.

This is called __framing__. Nest doesn't force the users to use a particular framing
scheme. For example, they may use the standard falcon {{include()}} function to include
dynamically header and footer elements, or they may consistently {{load}} a set of site-specific
function which include framing facilities. We'll illustrate some of this mechanisms later
on in this document,

However, Nest provides a ready-to-use framing mechanism that fits most of the common needs
of web applications, and this is covered by this quickstart.

When the @a Nest.frame property is set to a function,
then Nest will load the page that the routing system
required and render it separately. The output of the
rendered page can be retrieved through the @a Nest.content
method.

A frame function can also be used to load services that are common through all the pages
sharing that frame.

For example, the following code can be placed on the entry point script to provide the same
headers and footers for all the pages of a site:

@code
// this is index.fal
load nest

Nest.frame = function()
            > '<html><head><title>My site</title></head><body>'
            > '<p>My site starts here...</p><hr/>'
            > Nest.content()
            > '<hr/><p>And this was My Site! ... </p></body></html>'
         end

Nest.route()
@endcode

The function set in @a Nest.frame may be also a direct __include__ that loads the
frame page. The location of those pages is always relative to the entry point.

For example, to externalize the frame in another module, it is possible to write:

@code
// this is index.fal
load nest

Nest.frame = .[include "frame.ftd"]
Nest.route()
@endcode

Then, {{frame.ftd}} would be beside index.fal, and would look like the following:
@code
<!-- This is frame.ftd -->
<html>
   <head><title>My site</title></head>
   <body>
   <p>My site starts here...</p><hr/>
   <? Nest.content() ?>
   <hr/>
   <p>And this was My Site! ... </p>
   </body>
</html>
@endcode

Framing can be disabled on specific pages adding the Falcon attibute @b nest_frame as false;
for example:
@code
<?
nest_frame: false
?>
<html>
<body>
<h1>Unframed page</h1>
<p>This page won't be framed, even if nest has a site-wide frame</p>
</body>
</html>
@endcode

@note Unframing .fal and .ftd files is useful to build simple AJAX based sites.

@section ov_services Services

Nest modular web application composition is based on the concept of __services__, that are
modules performing specific tasks and then, optionally, being rendered on the page 
shown by the browser.

*/
