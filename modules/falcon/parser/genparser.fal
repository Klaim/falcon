/*
   FALCON - Generic Parser

   FILE: parser.fal

   Generic parser (using Falcon Grammar)
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Wed, 02 Jul 2014 14:37:04 +0200

   -------------------------------------------------------------------
   (C) Copyright 2014: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

import Grammar from .grammar

/*#
   @module genparser
   @brief Generic parser
   
   This module provides funcitonality to parse a given input using an abstract
   grammar structure.
   
   The grammar structure being used to parse the text is provided by the
   @a parser.grammar module and @a parser.stdgrammars module, which helps to load in
   some well-known grammars.
*/

// Associativity constants
_anone = 0
_aleft = 1
_aright = 2

/* Open a single guess */
class _Guess
   sequence = []
   candidates = []
   prio = 0
   assoc = 0
end


/* Tau */
class _Tau(v)
   value = v
   token = nil   
end

/*#
   @brief Generic parser using an abstract grammar definition.
   
   The grammar used by this parser can be synthesized programmatically,
   or parsed from an EBNF-like definition. This functionality is provided
   by the @a parser.grammar module.

*/

class Parser(grammar)
   //# Error in running code
   static eCode = 1
   
   //# Error generated on unrecognized rule
   static eMatch = 2
   
   //# Grammar used by this parser
   grammar = grammar
   
   //# Topmost token recognized after a succesful parsing
   recon = nil
   
   /*#
      @brief Error handler function
      
      This property is assinged a function that receives the
      notification of an error in the grammar. On error, 
      it is invoked with the following parameters:
         - The line where the error happened.
         - Numeric code of the error
         - A textual description of the error that happened.
         - Extensive contextual information.
         
      If the line is 0, then the error happened while processing the
      input grammar rather than while matching the input.

      The default function writes the error notification to the process
      standard output. It can be overridden to change its behavior.
   */
   handleError = function( line, code, reason, extra )
         desc = self.describeError(code)
         desc = @"[$line] $desc($code)"
         if reason: desc += "(" + reason + ")"
         if extra: desc += ": " + extra
         printl(desc)
      end
   
   
   // Multi-tokenizer used for lexing.
   _mt = nil
   
   // Current line
   _line = nil
   
   // The guess stack
   _gs = nil
   
   // The token stack
   _ts = nil

   // The state stack
   _states = nil
   
   // the context generated by the code.
   _ctx = nil

   init
      // a formal check on grammar
      if not grammar.derivedFrom(Grammar)
         raise ParamError(901,nil,"Grammar")
      end
      
      if "main" notin grammar.states
         raise ParamError(1001,"Invalid grammar","Provided grammar has no 'main' state.")
      end
   end
   
   /*#
      @brief Parses an input stream according to the given grammar.
      @return On success, the value associated with the recognized token.
      @param idata Input data (a String or a TextReader)
      
   */
   function parse(idata)
      try
         mt = MultiTokenizer(idata)
         self._mt = mt
      catch ParamError 
         raise ParamError( 1001, "Invalid paramters", "Need a string or TextReader" )
      end

      self._reset()      

      ctx = self._runInitCode()
      if not ctx: ctx = p{}
      self._ctx = ctx
      
      // do the preamble -- we have checked the grammar "main" at init
      main = self.grammar.states["main"]
      self._enter(main)
      
       // used to reiterate the same token in different states
      take = true
      
      while mt.hasNext

         // used to reiterate the same token in different states
         if take
            tok = mt.next()
            // skip empty tokens.
            if not tok: continue
            // eat the ignored tokens.
            if tok in self._states[-1].eat: continue
         else
            take = true
         end
         
      
         > "TOK: >", tok, "<"
      end
   end
   
   //============================================================
   // Utilities
   //============================================================
   
   function describeError(code)
      switch code
         case 0: return "Error in running code"
         case 1: return "Unrecognized grammar"
         default: return ""
      end
   end
   
   function _reset()
      self._mt.giveTokens = true
      self._line = 1
      self._gs = []
      self._ts = []
      self._states = []
      
   end
   
   function _enter(state)
      self._mt.clearTokens()
      call( self._mt.add, state.tokens )
      if self._states
         oldState = self.states[-1]
         self._runCode("Postamble of " + oldState.name, oldState.postamble_code)
      end
         
      self._runCode("Preamble of " + state.name, state.preamble )
      self._states.push(state)
   end
   
   function _runInitCode()
      code = self.grammar.initcode_compiled
      if code
         try
            ctx = code()
         catch in e
            self.error( self.eCode, "Initcode", e.toString() )
         end
      end
   end
   
   function _runCode( context, code, params )
      if code
         if params
            params.insert(0,self._ctx)
         else
            params = .(self._ctx)
         end
         
         try 
            code # params
         catch in e
            self.error( self.eCode, @"Application code in \"$context\"", e.toString() )
         end
      end
   end
end
