/*
   FALCON - Generic Parser

   FILE: genparser.fal

   Generic parser.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Thu, 19 Aug 2010 01:34:20 +0200

   -------------------------------------------------------------------
   (C) Copyright 2014: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

import Syn.*
import Node,Tree from struct.tree

/*# 
   @brief A simple triplet expressing a parsing rule.
   @param token a token or RE that is used to break up the input
   @param target The target status in which the parser must be when the token is found
   @param action -- The thing to be done (a function) with the input text and the ongoing parsing
   
   The @b action can be a user-defined function, or one of the following
   functions, defined in genparser:
   
   - addToContent: Adds the identified text to the content.
   - popNode: removes the current node from the context.
   - addBelow( type, [regex], [subst] ): generate a function that will add the 
      node of the given type, settin its content as required; eventually, the content
      can be transformed as per regex-subst pair indicates.
   - addBesides( type, [regex], [subst] ): generate a function that will add the 
      node of the given type, settin its content as required; eventually, the content
      can be transformed as per regex-subst pair indicates.
      
   A user-defined @b action will receive the following parameters:
   - tree: the Tree instance passed to the parser.
   - text: The recognized text
   - parser: the parser that is performing the parsing.
   
   Each other user-defined data or context-dependent information should be held
   using a closure or a method instead of a function.
*/

class PRule( token, target, action )
   token = token
   target = target
   action = action
end

/*#
@brief Error generated by the generic parser.
*/
class ParserError( code, desc, extra ) from Error(code, desc, extra )
end


/*#
   @brief Generic parser engine.
   
   @code
   x = Parser()
   // shortcut
   PState = x.add

   PState( "start",
      // AddBelow will actually create a function that will be responsible
      // for adding the text below the forming tree
      PRule( "/*#", "faldoc_text", addBelow("FaldocBlock") ),
      PRule( "//#", "faldoc_text_eol", addBelow("FaldocBlock") ),
      // addToContent doesn't need configuration, so we can use it directly
      PRule( nil, "#stay", addToContent )
   )

   base_faldocText = .[ 
      PRule( r'@b\s\w+\b', "#stay", addBesides("b", r'@b\s+(\w)', '\1') )
      // the action is optional
      PRule("\\", "ignore")
      PRule(nil, "#stay", addBesides("text") )
      ]

   PState( "faldoc_text",
      base_faldocText,
      PRule( '*'+'/', "#pop", popNode )
   )

   PState( "faldoc_text_eol",
      base_faldocText,
      PRule( "\n", "#pop", popNode )
   )

   PState( "ignore",
      PRule( nil, "#pop", addToContent )
   )

@endcode
*/
class Parser
   // states
   states = [=>]
   
   // The parser status will be set here.
   tree = nil
   mtMap = nil
      
   // current state list
   _stateList = nil

   // This method is used to add a rule to a state.
   // It's actually a variable parameter function, with r assuming the value
   // of each rule passed after the state name, in turn.
   // r can also be an array of rules.
   function add( stateName, r )
      if r.typeId == ArrayType
         for elem in r
            self.add(stateName, elem )
         end
      else
         if not r.derivedFrom(PRule)
            raise ParamError(10001, "Parameter error", "Rule is not a PRule instance")
         end
         
         state = self.states.find(stateName, nil)
         if not state
            self.states[stateName] = [r]
         else
            state += r
         end
      end
      
      fself.redo()
   end
   

   // Start parsing
   // Text can also be a stream.
   function parse( text, enc )
      // reset the maps
      self._stateList = []
      self.mtMap = [=>]

      select text
         case StringType
            if not enc: enc = "utf8"
            reader = TextReader(StringStream(text), enc)
         case TextReader
            reader = text
         default
            raise ParamError( 10001, "Invalid parameter", "S|TextReader,[enc]" )
      end
      
      self.prepareParsing(reader)
      self.setState("start")
      tree = self._doParse(reader)
      
      return tree
   end
   
   //==========================================================
   // Private part
   //
   
   // This method fills the MultiTokenizer with callbacks that act on the forming syntactic tree.
   // The calbacks are generated on the fly, filling them with dynamic code.
   // The workhorse for that is the next function.
   function prepareParsing( reader )    
      
      for name, ruleList in self.states
         mt = MultiTokenizer( reader )         
         self.mtMap[name] = mt
         
         for r in ruleList
            f = r.action
            // the action accepts {tree, text=>}               
            action = {(text) > ^~(r.token),": ", text; ^~f(^~(self).tree, text) }
            
            // a nil or "" is an catch all token
            if not r.token
               mt.onText = action
            else
               mt.addToken( r.token, action )
            end
         end         
      end   
      
   end
   
   // Main parser loop
   function _doParse(reader)
      tree = Tree()
      self.tree = tree
      
      while not reader.eof()
         curstate = self.currentState()
         mt = self.mtMap[curstate]
         mt.next()
      end
      
      return tree
   end
   
   
   function currentState()
      if self._stateList
         return self._stateList[-1]
      end
      return "<EMPTY>"
   end
   
   function setState( newState )
      self.trace("setState", newState )
      
      states = newState.split(";")
      for s in states
         switch s
            case "#pop"
               self.popState()
            case "#stay"
               // do nothing
            default
               if s notin self.mtMap
                  self.error("State '" + s + "' not found")
               else               
                  self.trace("Descending in state", s)
                  self._stateList += s
               end
         end
      end      
   end
   
   function popState()
      if not self._stateList
         self.error("Pop state without states.")
      else
         self._stateList.remove(-1)
      end
   end
   
   function error( s )
      raise ParserError( 10001, "Parser Error", s)
   end
   
   function trace()
      >> "[P-TRC] "
      ^[fself.params] {(v) >>v, " "}
      printl()
   end
   
   function trace2()
      >> "[P-TR2] "
      ^[fself.params] {(v) >>v, " "}
      printl()
   end
end

//=====================================================================
// Callbacks
//=====================================================================

// This is an action that creates a closure that will act on the tree
// It's purpose it's that of creating a node of type 'name', and 
// eventually transform the input text via regex/subst pair.
function addBelow( name, processor )
   return { tree, text =>
      if processor 
         text = processor(text)
      end
      newNode = Node(name, text)
      tree.current.appendChild(newNode)
      tree.current = newNode
   }
end

// As above, but adds a sibling to the current node
function addBesides(name, processor )
   return { tree, text => 
      if processor 
         text = processor(text)
      end
      newNode = Node(name, text)
      tree.current.insertAfter(newNode)
      tree.current = newNode
      }
end

// As above, but adds a sibling to the current node
function addAbove(name, processor )
   return { tree, text => 
      tree.popNode()
      if processor 
         text = processor(text)
      end
      newNode = Node(name, text)
      tree.current.insertAfter(newNode)
      tree.current = newNode
      }
end

// sets the current node as the parent of the current node
function popNode(tree) 
   if tree.current.parent == nil
      raise ParseError( 10002, "Popping top node in tree" )
   end
   tree.current = tree.current.parent
end

// Adds content to the currently active node (or fills it's content field)
function addToContent(tree, text)
   if tree.current.content
      tree.current.content += text
   else
      tree.current.content = text + ""
   end
end

// Adds content to the currently active node (or fills it's content field)
function addText(text)
   return { tree => 
   if tree.current.content
      tree.current.content += text
   else
      tree.current.content = text + ""
   end
   }
end
