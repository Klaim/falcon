/*
   FALCON - Generic Parser

   FILE: creole.fal

   Read and parses creole WIKI data.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Sat, 30 Aug 2008 09:42:22 +0200

   -------------------------------------------------------------------
   (C) Copyright 2008: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

import Parser from parser.genparser as GP
import from parser.genparser

function _substTitle( t )
   return  r'^\s*=+\s*(.+?)\s*=*$'.subst(t,'\1')
end

Headers = .[
   PRule( r'^\s*======\s*(.+?)\s*=*$', "#stay", addBesides( "header6", _substTitle )
   PRule( r'^\s*=====\s*(.+?)\s*=*$', "#stay", addBesides( "header5", _substTitle )
   PRule( r'^\s*====\s*(.+?)\s*=*$', "#stay", addBesides( "header4", _substTitle)
   PRule( r'^\s*===\s*(.+?)\s*=*$', "#stay", addBesides( "header3", _substTitle)
   PRule( r'^\s*==\s*(.+?)\s*=*$',  "#stay", addBesides( "header2", _substTitle )
   PRule( r'^\s*=\s*(.+?)\s*=*$',  "#stay", addBesides( "header1", _substTitle )
   PRule( r'^\s*----*$',  "#stay", addBesides( "hr" ) )
]

Headers2 = .[
   PRule( r'^\s*======\s*(.+?)\s*=*$', "#pop",  addAbove( "header6", _substTitle ) )
   PRule( r'^\s*=====\s*(.+?)\s*=*$', "#pop", addAbove( "header5", _substTitle ) )
   PRule( r'^\s*====\s*(.+?)\s*=*$', "#pop", addAbove( "header4", _substTitle ))
   PRule( r'^\s*===\s*(.+?)\s*=*$', "#pop", addAbove( "header3", _substTitle ))
   PRule( r'^\s*==\s*(.+?)\s*=*$',  "#pop", addAbove( "header2", _substTitle ))
   PRule( r'^\s*=\s*(.+?)\s*=*$',  "#pop", addAbove( "header1", _substTitle ) )
   PRule( r'^\s*----*$',  "#pop", addAbove( "hr" ) )
]

TableStart = .[
   //PRule( '^\s*\|=\s*',  "table", {ctx =>  ctx.pushNode( Node("table") ); ctx.pushNode(Node("tr")); ctx.pushNode(Node("th"))} )
   //PRule( '^\s*\|\s*',  "table", {ctx =>  ctx.pushNode( Node("table") ); ctx.pushNode(Node("tr")); ctx.pushNode(Node("td"))} )
]


Indents = .[
   PRule( '^\s*::::\s*', "#stay", addBelow("indent4") )
   RRule( '^\s*:::\s*', "#stay", addBelow("indent3") )
   RRule( '^\s*::\s*', "#stay", addBelow("indent2") )
   RRule( '^\s*:\s*', "#stay", addBelow("indent1"))
]


SpecialEntities = .[
      PRule( '<', "#stay", addText("&lt;") )
      PRule( '>', "#stay", addText("&gt;") )
      PRule( '&', "#stay", addText("&amp;") )
      PRule( '"', "#stay", addText("&quot;") )
]


ListStart =  .[
      //ReRule( '^\s*#\s*', "list", {ctx=> ctx.setListDepth( 1, "ol") })
      //ReRule( '^\s*\*\s*', "list", {ctx=> ctx.setListDepth( 1, "ul") })
]


FormatElements = .[
   PRule( r'\*\*.*(\*\*|\n)',  "#stay", addBesides("b", { t=>t[ 2:-2 ] } ) )
   PRule( r'//.*(//|\n)',  "#stay", addBesides("i", { t=>t[ 2:-2 ] } ) )
   PRule( r'__.*(__|\n)',  "#stay", addBesides("u", { t=>t[ 2:-2 ] } ) )
   PRule( r'^^.*(^^|\n)',  "#stay", addBesides("sup", { t=>t[ 2:-2 ] } ) )
   PRule( r',,.+(,,|\n)',  "#stay", addBesides("sub", { t=>t[ 2:-2 ] } ) )
   PRule( '\\',  "#stay", addBesides("br") )
   PRule( '{{{',  "verbatim", addBelow("verbatim") )
   PRule( "~~", "#stay", addText("~") ) // escape escaped
   PRule( "~", "escape" ) // escape char
]

/*
LinkElements = .[
    PRule( '\[\[:(.*?)(\|(.*?))?(\|(.*?))?\]\]',  "#stay",
                        {ctx, ma, pg, d1, txt, d2, mx =>
                           ctx.add(
                              InfoNode("file", _options(mx, ["name"=>pg, "text"=>txt, "ext"=>true]))
                           )
                        })

   PRule( '\[\[(https?:.*?|ftp:.*?)(\|(.*?))?(\|(.*?))?\]\]',  "#stay",
                        {ctx, ma, pg, d1, txt, d2, mx =>
                           ctx.add(
                              InfoNode("link", _options(mx, ["name"=>pg, "text"=>txt, "ext"=>true]))
                           )
                        })

   
    PRule( '\[\[([^:|\]]+):(.*?)(\|(.*?))?(\|(.*?))?\]\]',  "#stay",
                        {ctx, ma, ilink, pg, d1, txt, d2, mx =>
                           ctx.add(
                              InfoNode("link", _options(mx, ["name"=>pg, "ext"=>false, "text"=>txt, "ilink"=>ilink]))
                           )
                        })
   
   PRule( '\[\[(.*?)(\|(.*?))?(\|(.*?))?\]\]',  "#stay",
                        {ctx, ma, pg, d1, txt, d2, mx =>
                           ctx.add(
                              InfoNode("link", _options(mx, ["name"=>pg, "ext"=>false, "text"=>txt]))
                           )
                        })
   PRule( 'https?://[^ ;,\?!:]+',  "#stay", {ctx, ma=> ctx.add( InfoNode("link", ["name"=>ma, "text"=>nil, "ext"=>true]))} )
   PRule( 'ftp://[^ ;,\?!:]+',  "#stay", {ctx, ma=> ctx.add( InfoNode("link", ["name"=>ma, "text"=>nil, "ext"=>true]))} )

   PRule( '\{\{(.*?)(\|(.*?))?(\|(.*?))\}\}',  "#stay", {ctx, ma, pg, d0, txt, d1, mx =>
                                                 ctx.add( InfoNode("img", _options(mx, ["name"=>pg, "alt"=> (txt? txt:pg)])))} )
   PRule( '<<(.*?)(\s+(.*?))?>>', "#stay", {ctx, ma, pname, d0, popts =>
                        ctx.add( InfoNode("plugin", ["name"=>pname, "params"=>_params(popts)], true) ) } )
]
*/

InlineElements = FormatElements + SpecialEntities //+ LinkElements

/*
   Determine the options of a optioned link
*/
function _options( mx, res )
   if not mx: return res
   
   elems = mx.split("|")
   
   ielem = 0
   le =  elems.len()
   while ielem < le
      elem = elems[ielem++]
      
      if "=" in elem
         k,v = elem.split("=",2)
         res[k] = v
      else
         res[elem] = true
      end
   end
   return res
end
   

/*
   Determine options of plugins
*/
function _params( opts )
   return opts
end


function _inlineState( limit )
   return PState(.[
            EmptyLineRule( "#pop;#pop", {ctx => ctx.popNode(); ctx.popNode()} )  // return to base
            // Putting it before allows to override
            TagRule( limit,  "#pop", {ctx => ctx.popNode()} )
         ]
         + InlineElements,
         {ctx, data=>ctx.add( data )},
         "para_continue"   // the paragraph can contiune at the end of an inline
      )
end
   

class Parser from GP
   init
      PState = self.add
      
      PState("start", 
         Headers,
         .[
         PRule( r'^\{\{\{([^\s]+)$',  "verbatim_code", {ctx, ma, lang => ctx.pushNode( InfoNode("code", ["lang"=>lang]))} )
         RRule( r'^\{\{\{$',  "verbatim_line", {ctx => ctx.pushNode( Node("pre"))} )            
         RRule( r'^\+\+\+*\s*(.*)?$',  "quote_base", {ctx, ma, link => ctx.popNode();
                                                            ctx.pushNode( InfoNode("quote", ["link"=>link]))} )
         PRule( r'\w', "para", addBelow("p")),
         ]
         
      )

      PState("para",
         PRule("\n\n", "#pop", popNode ),
            
         ]
         + TableStart
         + ListStart
         + InlineElements
         + Indents
         + Headers2,
         
        
      ),

      "quote_base" =>PState(.[
            ReRule( '^\+\+\+*$',  "#pop;#pop", {ctx => ctx.popNode();} )
            DummyRule( "quote", { ctx => ctx.pushNode( Node("para") )} )
         ]
      ),

      "quote" =>PState(.[
            EmptyLineRule( "#pop", {ctx=> ctx.popNode()})
            ReRuleLA( '^\+\+\+*$',  "#pop", {ctx => ctx.popNode()} )
         ]
         + ListStart
         + InlineElements,
         {ctx, data=>ctx.add( data )},
         "para_continue"
      ),

      "para_continue"=> PState(
         .[ DummyRule( "#pop", { ctx => ctx.add(" ")} ) ]
      ),
      
      
      "eolverbatim" =>PState(.[
         DummyRule( "#pop", { ctx => ctx.add( "\n") } )
         ]
      ),

      "table" => PState(.[
            // at the end of the line we close TD and TR
            EmptyLineRule( "#pop")
         ]
         + InlineElements
         +.[
            ReRule( '\s*\|$',  "tableBeginLine", {ctx=>  ctx.popNode(); ctx.popNode()} )
            ReRule( '\s*\|=\s*',  "#stay", {ctx=> ctx.popNode(); ctx.pushNode(Node("th"))} )
            ReRule( '\s*\|\s*',  "#stay", {ctx=> ctx.popNode(); ctx.pushNode(Node("td"))} )
            ReRule( '\s*$',  "#pop", {ctx=> ctx.popNode(); ctx.popNode(); ctx.popNode()} )
         ],
         {ctx, data=>ctx.add( data )}
      ),

      "tableBeginLine" => PState(.[
            ReRule( '^\s*\|=\s*',  "#pop", {ctx=> ctx.pushNode(Node("tr")); ctx.pushNode(Node("th"))} )
            ReRule( '^\s*\|\s*',  "#pop", {ctx=> ctx.pushNode(Node("tr")); ctx.pushNode(Node("td"))} )
            DummyRule( "#pop", {ctx=> ctx.popNode(); } )
         ]
      ),

      // Some inline states
      "bold" => _inlineState( "**" ),
      "italic" => _inlineState( "//" ),
      "superscript" => _inlineState( "^^" ),
      "subscript" => _inlineState( ",," ),
      "underline" => _inlineState( "__" ),

      "list" => PState(.[
            EmptyLineRule( "#pop;#pop", { ctx=> ctx.setListDepth( 0 ); ctx.popNode(); })
                  
            ReRule( '^\s*######\s*', "#stay", {ctx=> ctx.setListDepth(6, "ol" ) })
            ReRule( '^\s*#####\s*', "#stay", {ctx=> ctx.setListDepth(5, "ol" ) })
            ReRule( '^\s*####\s*', "#stay", {ctx=> ctx.setListDepth(4, "ol" ) })
            ReRule( '^\s*###\s*', "#stay", {ctx=> ctx.setListDepth(3, "ol" ) })
            ReRule( '^\s*##\s*', "#stay", {ctx=> ctx.setListDepth(2, "ol" )})
            ReRule( '^\s*#\s*', "#stay", {ctx=> ctx.setListDepth(1, "ol" )})

            ReRule( '^\s*\*\*\*\*\*\*\s*', "#stay", {ctx=> ctx.setListDepth(6, "ul" ) })
            ReRule( '^\s*\*\*\*\*\*\s*', "#stay", {ctx=> ctx.setListDepth(5, "ul" ) })
            ReRule( '^\s*\*\*\*\*\s*', "#stay", {ctx=> ctx.setListDepth(4, "ul" ) })
            ReRule( '^\s*\*\*\*\s*', "#stay", {ctx=> ctx.setListDepth(3, "ul" ) })
            ReRule( '^\s*\*\*\s*', "#stay", {ctx=> ctx.setListDepth(2, "ul" )})
            ReRule( '^\s*\*\s*', "#stay", {ctx=> ctx.setListDepth(1, "ul" )})
         ]
         + InlineElements,
         {ctx, data=>ctx.add( data )},
         "para_continue"
      ),
      

      "escape" =>PState(.[
            TagRule( "https://", "#pop", {ctx => ctx.add( "https://" )} ) // escaped links
            TagRule( "http://", "#pop", {ctx => ctx.add( "http://" )} ) // escaped links
            TagRule( "ftp://", "#pop", {ctx => ctx.add( "ftp://" )} ) // escaped links
            
            CharRule( "#pop", {ctx, c => if c: ctx.add(c) } )
            // force to go away if can't grab even a char
         ],
         nil,  // No unrecognised possibile
         "*#pop"  // pop if not matched at the end of the line, like ~\n
      ),

      "verbatim_line" =>PState(.[
            ReRule( '^}}}$',  "#pop", {ctx => ctx.popNode()} )
         ]
         + SpecialEntities,
         {ctx, data=>ctx.add( data )},
         "eolverbatim"
      ),

      "verbatim_code" =>PState(.[
            ReRule( '^}}}$',  "#pop", {ctx => ctx.popNode()} )
         ],
         {ctx, data=>ctx.add( data )},
         "eolverbatim"
      ),

      "verbatim" =>PState(.[
            EmptyLineRule( "#pop;#pop", {ctx => ctx.popNode(); ctx.popNode()} )  // pop if newpara
            TagRule( '}}}',  "#pop", {ctx => ctx.popNode()} )
         ]
         + SpecialEntities,
         {ctx, data=>ctx.add( data )}
      ),

      // Just to be able to add always "," at the end
      "*dummy" => nil
   ]

   function reset()
      self.initParser( "start" )
   end
end


