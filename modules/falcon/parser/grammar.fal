/*
   FALCON - Grammar Parser

   FILE: grammar.fal

   EBNF-Like grammar parser.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Wed, 02 Jul 2014 14:37:04 +0200

   -------------------------------------------------------------------
   (C) Copyright 2014: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

/*#
   @module grammar
   @brief Advanced context-free grammar definition parser.
   
   This module parses a generic EBNF-like grammar definition 
   (provided in a generic stream) and generates a structured
   representation of that grammar, which can then be used to
   parse an expression writte under the rules of the given 
   grammar.
   
   @note While the parsed grammar is functionally equivalent to
   a EBNF grammar, some conventions in are different for practical 
   purposes. In particular, the usage of "[x]" and "{x}" to indicate 
   repetition in the EBNF convention makes extremely difficult to 
   declare inline Falcon code as the rule action.
   
   @section overview Overview
   
   The formal context-free grammar definition recognized by this
   parser has several distinguishing features that set it apart from
   basic LL, LR and LARL commonly known grammars.
   
   - The grammar definition can be divided in sections, called "states", 
   which can be insolated from the rest of the grammar definition or include
   one or more states. A state transition can happen when a rule is recognized.
   Special tokens in the grammar are provided to define state transitions.
   
   - Each token (terminal and non-terminal) can be associate with a symbolic
   name, that will be used to identify that portion of data while processing
   the rule.
   
   - Each grammar rule can be associated with a portion of Falcon code that
      will receive the data being parsed.
      
   - Terminal tokens can be either strings or Falcon regular expressions 
     (r'' strings).
   
   - Each state can have associated Falcon code sections, 
     called preamble and postamble,
     that will be executed as the transition into and out from that state 
     happens.
   
   @section fdef Formal Definition
   
   Here follows a formal definition of the grammar known by this parser:
   
   @code
   GRAMMAR ::= INIT-CODE? MAIN-STATE STATE.
   
   INIT-CODE ::= CODE.
   
   MAIN-STATE ::= MAIN-STATE-DECLARATION? STATE-BODY.
   
   MAIN-STATE-DECLARATION ::= '[' 'main' ']'.
   
   STATE ::= STATE-DECLARATION STATE-BODY.      
   
   STATE-DECLARATION::= '[' NAME INCLUDES? ']' <end of line>.
   
   STATE-BODY::= PREAMBLE? POSTAMBLE? RULE* NAMED_TERMINAL* PRECEDENCE_RULE? EAT_RULE?.
   
   PREAMBLE ::= '#' CODE.
   
   POSTAMBLE ::= '=>' CODE.
   
   CODE ::= '{' <any code slice> '}'.
   
   NAME ::= <any symbolic name>.
   
   INCLUDES::= ':' NAME+.
   
   RULE ::= NAME '::=' '!'? RULE-BODY '.' .
   
   NAMED_TERMINAL ::= NAME ':-' STRING | REGEX .
   
   RULE-BODY::= ALTERNATIVE NEXT-ALTERNATIVE*.
   
   ALTERNATIVE ::= TOKEN* ACTION? TRANSITION?.
   
   ACTION ::= CODE.
   
   NEXT-ALTERNATIVE ::= '|' ALTERNATIVE.
   
   TOKEN ::=  (NAME | TERMINAL | PREDEFINED | SUB-ALTERNATIVE) REPETITION? TOKEN-SPEC?.
            
   SUB-ALTERNATIVE ::= '(' TOKEN+ ')'.
   
   PREDEFINED ::= 'eof' | 'error' | 'any'.
   
   REPETITION ::= '?' | '+' | '*'.
   
   TRANSITION ::= '=>' NAME | POP-STATE-DIRECTIVE.
   
   POP-STATE-DIRECTIVE ::= '#'+.
   
   TOKEN-SPEC ::= ':' NAME.
   
   PRECEDENCE_RULE ::= 'precedence' '::=' NAME+ ('|' NAME+)* '.' .
   
   EAT_RULE ::= 'eat' '::=' TERMINAL+ '.' .
   
   TERMINAL::= STRING | REGEX.
   
   STRING ::= "'" <any valid falcon string> "'"  | '"' <any valid falcon string> '"'.
   
   REGEX ::= <any valid Falcon regular expression>.
   @endcode
   
   Legend:
   - "name ::= definition .": The given "name" is defined as indicated up to the '.'
   - "A | B" ::= Indicates an alternative definition, A or B.
   - "( A | B )" ::= Indicates an alternative element A or B inside a definition.
   - "*": Previous token can be present, and repeated multiple times.
   - "+": Previous token must be present, and can be repeated multiple times.
   - "?": Provious token can be preset at most one time.
   - "<...>": informal description of an element.
   
   @subsection remarks Remarks
   
   - The strings parsed by this parser are always interpreted as Falcon double-quoted
     strings, even if initiated with a single quote.
   - It is possible to insert out-of-grammar comments in C-like comment blocks \/* ... *\/
   - The parser is actually flexible in recognizing preamble and postamble, and the three
     elements of a rule alternative (tokens, transition and code), 
     that can appear in any order.
   - Before the tree structure created out of the grammar definition is returned to the
     caller, the Falcon code slices and regular expressions will be compiled, and thus,
     checked for formal errors; but they won't be pre-executed, so it won't be possible
     to spot potential run-time errors.
   - Prior returning the structure, the parser will also check for the correctness of
     formal definitions: undeclared non-terminal tokens, undeclared included states and
     recursive state inclusion will be reported as error, and that will cause the the
     parsing process to fail.
   - Multiple rules starting with the same non-terminal name are considered alternatives;
     "A ::= <alt1> | <alt2> ."  and "A ::= <alt1>. A ::= <alt2>." are semantically
     equivalent.     
   - The special predefined terminal token 'eof' recognizes the end of the input data.
   - The special predefined terminal token 'error' matches the rest of the rule
     if and only if it couldn't be matched otherwise.
    
   
   @subsection idef Informal definition.
   
      The parser recognizes texts generally used to describe context-free grammars,
      with the addition of the "state" concept and with the insertion of Falcon code
      that can handle a recognized grammar. Also, a name can be given to any token,
      even terminal tokens, that are then passed to the Falcon code in a variable
      having the given name.
      
      A parser state can be useful to reduce the scope and complexity of the analisys 
      of a certain portion of text, and thus, the complexity of its definition. The ability
      to include previously declared states (or actually, also states declared afterward)
      allows for better modularity and reusability of the definitions, and the code that
      manages them.
      
      Each state actually generates a different parser, and state transition allows to
      dynamically change the parser that is in charge of recognizing a certain porion of
      input text.
      
   @section struct Target structure
   
      Once the parsing is complete, the result is an entity of type @a Gramamr,
      defined in this module.
            
      The relational structure of the generated entity is as follows:
      
      @code
      Grammar
        + states [GrammarState]
                  |- name
                  |- preamble/postamble
                  + includes [GrammarState]
                  + entries [name => DefSymbol]
                  + terminals [String|RE => DefSymbol]
                  + top DefSymbol
                        |- type
                        |- name
                        |- content (String | RE)
                        + parents [DefRule]
                        + alts [DefRule]
                                 |- line
                                 |- code
                                 |- transition
                                 |- symbol [DefSymbol]
                                 + sequence [DefEntry]
                                             |- line
                                             |- pname
                                             |- repeat
                                             + symbol (DefSymbol)
      @endcode
      
      The grammar has a list of @a GrammarState entities. Each one represents a
      grammar state, that can include other GrammarState entities (by direct reference)
      and has a top rule of type @a DefSymbol. The @a DefSymbol entity is either a terminal
      or non-terminal symbol. If it's non-terminal, it's constituted
      constituted by one or more @a DefRule (alternatives), each being basically a
      sequence of @a DefEntry entities, each holding a DefSymbol in its symbol member.
      
      A @a GrammarState entity has also a map of @a DefSymbol entities declared in the state, 
      which is organized by entity name, and a map of terminal DefSymbols. 
      The @a GrammarState.terminal map holds all the terminals that have been implicitly or
      explicitly declared, and is organized by the String or Regular Expression that is the
      actual terminal contained in the DefSymbol. The @a GrammarState.entry map holds all the
      DefSymbols that have been explicitly or implicitly declared and that can be associated
      with a symbol name. So anonymous terminals can be found in the terminal maps, while
      named symbols, even undefined ones, are found in the entry map. Anonymous non-terminal
      symbols are not referenced in this maps.

      This tree structure can be used by the final parser to generate a grammar parsing
      table, inspected, modified, rendered back to a grammar textual definition document
      and eventually serialized.

      
   @section action Actions
      Actions are code slices that a final parser generator shall use to create the actual
      parsing code.
      
      This module provides a functionality that allows to embed code snippets into the
      grammar tree, if they're Falcon code. However, the parser generator using the grammar
      generated by this module can chose to use the action code as it prefers.
      
   @section code Actions as Falcon code slices.
      
      While this parser is not in charge of running any code slice, it is necessary to
      explain how the code is meant to work here so that the parser users know the conventions
      that shall be adopted by the final result grammar parsers.
      
      The @a Grammar.compileSlices method will try to compile all the code slices,
      and place them in the members of their host structure that are meant to carry
      pre-compiled code (i.e. initcode_compiled for Grammar, preamble_compiled for GrammarState
      and so on).
      
      In case the actions are such code snippets, the utility provided follows the
      conventions here described.
      
      The initcode in Grammar is executed; its return value
      is then assumed to be the context that will be passed to all the other code slices
      with the name @b ctx. If the preamble is not present, or doesn't return a non-nil object,
      the final parser shall generate an empty prototype object ("p{}"), that will then be
      seen as @b ctx by all the other code slices.
      
      Code slices handling rule alternatives will receive @b ctx as first parameter, and the
      entities that are being given a name as further parameters. Terminal entries (regex and
      tokens, including pre-defined tokens) will be seen as string. The type of the other
      entries will be whatever the result of previous operations has assigned to them.
      
      The return value of the functions (or the expression values of single-statement 
      expressions) will be assigned as the value of the defined token.
      
      For example:
      
      @code
         SUM ::= r"[0-9]+":op1 "+" r"[0-9]+":op2 { int(op1) + int(op2) }.
      @endcode
      
      This rule will put the sum of op1 and op2 in the value of the token SUM. So,
      SUM will be aleady a number in the next alternative:
      
      @code
         SUM ::= r"[0-9]+":op1 "+" SUM:sum { int(op1) + sum }.        
      @endcode
      
      If an alternative doesn't declare a code, the declared token value is synthesized
      by applying the Falcon '+' operator to all the token values (terminal and non-terminal)
      comprised in the alternative. This might generate a runtime error in case the types
      of the values assigned to the tokens is not compatible.
      
      For instance, the following rule set:
      
      @code
         FULLTEXT ::= PART*.
         PART ::= WHITESPACE | WORD.
         WHITESPACE ::= " "+ {" "}.
         WORD ::= r"[^ ]+".
      @endcode
      
      will have the effect of putting in FULLTEXT a version of the original text stripped
      of multiple spaces between words: the FULLTEXT rule will autmatically apply the Falcon
      "+" operator to all the PART tokens it receives.
      
      Repeated tokens (tokens postfixed with '*', '+' and '?') shall be passed to the code
      as an array. For example, the following rule:
      
      @code
         SORTED::= *WORD:word_array { word_array.sort(); return word_array }.
      @endcode
      
      Will assign an array of sorted words to the SORTED token. 
      
      @note DefEntrys repeated with the '?' repetition indicator will be seen in code slices
            as arrays with 0 or 1 elements.
            
      Of course, if the value associated with the repeated token is originally an array,
      it will be incapsulated again an another array, becoming an array-of-array.
      
   @section precedence Defining precedence
   
   The special rule "precedence" is used to determine tokens precedence and associativity.
   You can define named terminals using the :- operator:
   
   @code
      EXPR ::= EXPR plus EXPR.
      
      plus :- '+'
   @endcode
   
   Notice the lack of the '.' terminator after the ':-' named terminal specifier.
   
   Once you have given a name to a terminal, you can use the @b precedence special rule
   to determine the precedence and associativity of each named terminal. 
   
   The terminals specified first will have higher precedence, and lower precedence
   operators can be specified separating each sublist with the '|' separator. Adding the
   ':right' specifier will declare the operators as right-associative, while all the other
   terminal tokens declared in the precedence list will be left-associative.
   
   Check out the following example:
   
   @code
   plus :- '+'
   minus :- '-'
   times :- '*'
   divided :- '/'
   pow  :- '^'

   precedence ::=
      pow
      | times divided:right
      | plus minus.      
   @endcode
   
   @note The proproty declaration is local to the current parser state.
   
   @section eating Removal of meaningless tokens.
   
   The special rule "eat" can contain a set of terminal unnamed tokens that are to be 
   ignored in the given state.
   
   For example:
   
   @code
   eat ::= " " "\n" "\r" "\t".
   @endcode
   
   This means that the current state must ignore all the white-spaces.
   
   @section safe_points Safe Points
   
   The '!' marker at the beginning of a production rule indicates a "safe point". 
   This means that, when the rule is recognized, that frame is considered safe and thus
   the corresponding parsing tree is generated, and the actions are invoked.
   
   Rules involving state transitions are also considered safe points.
*/


/*#
   @brief Single token (entry in a DefSymbol entry sequence)
   @param type tString, tRE, tNT  (tPredef for predefined terminals)
   @param content either a string, a re or a DefSymbol
   @param name non-terminal name, if this is a non-terminal
   @param repeat 0/nil - single, -1: asterisk, -2: plus, -3: question mark
   @param line Where the token was defined.
   
   The content is determined by the type:
   - tString or tPredef: @b content is a String
   - tRE: @b content is a RE
   - tNT: @b Content is an instance of DefSymbol
   
   @note The token name can be nil if the token content is an anonymous
   DefSymbol.
*/
class DefEntry(sym, line)
   static tSingle = 0
   static tAsterisk = -1
   static tPlus = -2
   static tQMark = -3
      
   symbol = sym
   pname = nil
   repeat = 0
   line = line ? line: 0   
   
   function dump(output, purged)
      tok = self      
      tok.symbol.dump(output, purged, true)      
      
      if tok.repeat == DefEntry.tAsterisk
         output.write( "*" )
      elif tok.repeat == DefEntry.tPlus
         output.write( "+" )
      elif tok.repeat == DefEntry.tQMark
         output.write( "?" )
      end
      
      if tok.pname and not purged
         output.write( ":" + tok.pname )
      end
   end
   
   function toString()
      ret = m""
      sym = self.symbol
      if sym.name
         ret += sym.name
      else
         if sym.type == DefSymbol.tNT
            ret += "(ANON)"
         elif sym.type == DefSymbol.tRE
            ret += sym.content.toString()
         else
            ret += '"'+sym.content.escape()+'"'
         end
      end
            
      if self.repeat == DefEntry.tAsterisk
         ret += "*"
      elif self.repeat == DefEntry.tPlus
         ret += "+"
      elif self.repeat == DefEntry.tQMark
         ret += "?"
      end
      
      return ret
   end
end


/*#
@brief Single Entry of a Non Terminal specification, or Production Rule.
@param sym The non-terminal symbol that this rule produces.
@param line The line where this rule is (initially) declared.

*/
class DefRule(sym, line, id)
   // progressive rule ID -- just for accounting reasons
   id = id
   
   // line where the definition is declared
   line = line ? line: 0
   
   //# sequence of DefEntrys
   sequence = []
   
   // raw text code
   code = nil
   
   // compiled code
   compiled = nil
   
   // transition to a different state
   transition = nil
   
   // or... pop to different states
   transpop = 0
   
   //# Target for this symbol for this rule.
   symbol = sym

   /*# Rule left priority ( first operator priority ).
      
      This is valid only after calling "pcheck()"
   */
   leftPrec = 0
   
   /*# Rule left associativity ( first operator associativity )
      
      This is valid only after calling "pcheck()"
   */
   leftAssoc = 0
   
   /*# Rule right priority ( last operator priority )
      
      This is valid only after calling "pcheck()"
   */
   rightPrec = 0
   
   /*# Rule right associativity ( last operator associativity )
      
      This is valid only after calling "pcheck()"
   */
   rightAssoc = 0
   
   _pc = false
   
   //# adds an entry to the rule
   function add(dentry)
      self.sequence += dentry      
   end
   
   /*# Checks the precedence of this rule.
      @return true if this rule has precedence operators, false otherwise.
   */
   function pcheck()
      // shortcut.
      if self._pc: return self.leftPrec != 0
       
      for dentry in self.sequence
         // the left priority is the one first priority met (0 is ok)
         if self.leftPrec == 0: self.leftPrec = dentry.symbol.prec
         if self.leftAssoc == 0: self.leftAssoc = dentry.symbol.assoc
         
         // the right priority is the last met
         if dentry.symbol.prec != 0: self.rightPrec = dentry.symbol.prec
         if dentry.symbol.assoc != 0: self.rightAssoc = dentry.symbol.assoc
      end
      
      self._pc = true
      return self.leftPrec != 0 
   end
   
   /*# 
   */
   function dump( output, purged )
   
      alt = self
      
      if self.id != nil
         output.write( @"/* ${self.id} */ " )
      end
      
      for tok in alt.sequence
         tok.dump(output, purged)
         formiddle: output.write( " " )
      end
      
      code = alt.code
      if code and not purged
         output.write( "  {"+ code + "}" )
      end
      
      if alt.transition
         output.write( " => " + alt.transition.name )
      elif alt.transpop
         output.write( " => " + ("#" * alt.transpop) )
      end
   end
end


/*#
   @brief General entry in a gramamr definition.
   
   A Terminal entry has a single content.
   
   A Non-Ternminal entry is a colleciton of 0 or more alternatives,
   each being a @a DefRule, which fully defines a certain non terminal
   pattern.
   
   @note A DefSymbol can be anonymous if it's generated out of
   a locally defined alternative (a parentezised alternative within a sequence), or
   if it's an unnamed regular expression or string terminal.
   
*/
class DefSymbol(name, type, content)
   static tUnresolved = -1
   static tString = 0
   static tRE = 1
   static tNT = 2
   static tPredef = 3
   
   static tANone = 0
   static tALeft = 1
   static tARight = 2

   //# type of this entry
   type = nil
   
   //# Name of this entry
   name = name
   
   //# Content for terminal entries.
   content = content
   
   /*# 
      @brief List of zero or more DefRule
    
     Will be initialized to an empty array ui the type of the symbol
     is non-terminal.
   */
   alts = nil      

   //# Priority of this token
   prec = 0
   
   //# Associativity of this token
   assoc = 0

   //# DefRules in which this token is used.
   parents = []
   
   /*# if true, when this symbol is recognized, the parse tree is flushed and the parsing 
      is considered complete up to this point.
   */
   complete = false
   
   init
      self.resolveAs( type )
   end
   
   function isTerminal()
      return self.type != self.tNT
   end
   
   function higher(prec, assoc)
      return self.prec > prec or (self.prec == prec and self.assoc > assoc)
   end
   
   /*# Set a non-unresolved type for this entry.
   
      If the type set is @b tNT, the @b alts member
      gets initialized to an empty array.
   */
      
   function resolveAs( type )
      self.type = type != nil ? type : self.tUnresolved 
      if type == self.tNT: self.alts = []
   end
   
   /*# Renders this definition symbol to an output stream.
      @param Output the output stream
      @param purged If true, remove code snippets from alternatives.
      @param inline If true, render this as inline, 
         otherwise render this as a definition.
   */
   function dump( output, purged, inline )
      
      // DEBUG CODE:
      if not inline
         if self.parents.len > 0
            output.write( "/* Included in: " )
            for p in self.parents
               output.write( p.symbol.name )
               formiddle: output.write(", ")
            end
            output.write( "*/\n" )
         end
      end
      // -- end DEBUG CODE
      
      if self.type == self.tPredef or self.type == self.tUnresolved
         output.write( self.name )
      elif self.type == self.tNT
         self._dumpNonTerminal(output, purged, inline)
      else
         self._dumpTerminal(output, inline)
      end         
   end
      
      
   function _dumpNonTerminal(output, purged, inline)
      
      // manage inline anonymous non terminals
      if inline 
         if self.name 
            output.write( self.name )
         else
            output.write( "(" )
         end
      else
         output.write( self.name + " ::= " )
         if self.complete
            output.write( "! " )
         end
      end               
      
      if not inline or not self.name
         for alt in self.alts
            alt.dump(output, purged )
            
            forfirst
               if self.name and self.alts.len > 1
                  output.write( "\n     " )
               end
            end
            
            formiddle
               if not inline: output.write("\n  ")
               output.write( " | " )
            end
         end
      end

      if not inline: output.write( "." )
   end
   
   
   function _dumpTerminal(output, inline)
      
      if inline
         if self.name
            output.write( self.name )
         end
      else
         output.write( self.name + " :- " )
      end
            
      
      if not inline or not self.name
         if self.type == self.tString
            output.write( '"' + self.content.escape() + '"' )
         elif self.type == self.tRE
            output.write( self.content.toString() )
         end
      end
      
      if not inline   
         a = self.assoc == self.tANone ? "N" : (self.assoc == self.tALeft ? "L" : "R")
         output.write( @"   /* p=${self.prec} a=$a */" )
      end
   end
   
   /*# Returns true if the given symbol appears in a parent rule for this symbol. */
   function isParent( symbol, traversed )
      for rp in self.parents
         if symbol == rp.symbol: return true
         candidate = rp.symbol
         if not traversed: traversed = []
         if candidate in traversed: return false
         traversed += candidate
         if rp.symbol.isParent(symbol, traversed): return true
      end
      
      return false
   end
   
end


/*#
   @brief State of a multi-state grammar definition.
*/
class GrammarState(name, line)
   name = name
   
   // master grammar states
   includes = []

   // "ID" => [DefSymbol]
   entries = [=>]
   
   // "Text"/r"RE" => Terminal
   terminals = [=>]
   
   // DefSymbol at top of the entry tree
   top = nil
   
   // "ID" => [DefRule] -- still unresolved entries.
   unresolved = [=>]
   
   // line where the state is declared
   line = line
   
   //# list of lexer tokens known to the state
   tokens = []
   
   //# list of tokens that the parser must ignore
   eat = []
   
   _precRule = nil
   
   //# Code to be exucted when entering this state
   preamble = nil
   preamble_line = nil
   preamble_compiled = nil
   
   //# Code to be executed when leaving this state
   postamble = nil
   postamble_line = nil
   postamble_compiled = nil
   
   /*#
      @brief Finds an entry in this state, or in the included states.
      @param name The name of the entry to be found.
      @return a valid DefEntry, or nil if not found.
   */
   
   function findEntry(name)
      entry = self.entries.find(name,nil)
      if entry: return entry
      // try in the include states
      for included in self.includes
         entry = included.findEntry(name)
         if entry: return entry
      end
      
      // failure
      return nil
   end
   
   
   /*#
      @brief Reverse rendering for the state grammar
      @param output A stream where to write the data
      @optparam purged set to true to hide inline code
      
      This method renders the grammar definition on the
      given output in the special EBNF-like format recognized
      by the @a GrammarParser.
     
      With the @b purged option set to true, the code snippets
      and the variable name token specifiers won't be rendered;
      this makes possible to extract a ready-to-use EBNF-like
      grammar for documentation and exposition purposes.
      
   */
   function dump( output, purged )
      if self.includes
         output.write( @"[${state.name}:" )
         for state in self.includes
            output.write( state.name )
            formiddle: output.write( "," )
         end
         output.write( "]\n" )
      else
         output.write( @"[$(name)]\n" )
      end
      
      output.write("\n") /* white line */
      
      if self.preamble and not purged
         output.write( "# {" )
         output.write( self.preamble )
         output.write( "}\n" )
      end
      
      if self.postamble and not purged
         output.write( "=> {" )
         output.write( self.postamble )
         output.write( "}\n" )
      end      
         
      // for convention, write the root on top
      root = self.top
      if root
      // all the entries are generated outline here.
         root.dump(output, purged, false)
         output.write("\n") /* white line */
      else
         output.write("/* This state has no root */\n")
      end
      
      for name, entry in self.entries
         if entry != root
            // all the entries are generated outline here.
            entry.dump( output, purged, false )
            output.write("\n") /* white line */
         end
      end
      
      if self._precRule
         self._precRule.dump(output, purged)
         output.write("\n") /* white line */
      end

      for token in self.eat
         forfirst: output.write( "eat ::= " )
         output.write( "\"" + token.escape() +"\"" )
         formiddle: output.write( " " )
         forlast: output.write( ".\n" ) 
      end
      
   end

end


/*# 
   @brief Result of a succesful parsing.   
*/
class Grammar
   //# Map of grammar states.
   states = [=>]
   
   //# Root of the grammar, or meta-rule from the main state.
   root = nil
   
   //# Code to be executed at initialization
   initcode = nil
   initcode_line = 0
   initcode_compiled = nil
   
      // List of predefined tokens
   predefined = .[
      "eof" => DefSymbol("eof",DefSymbol.tPredef)      // End of file
      "any" => DefSymbol("any",DefSymbol.tPredef)      // any non-matching text
      "error" => DefSymbol("error",DefSymbol.tPredef)  // matches everything in case of error.
   ]
   
   //# Reverse rendering for the state grammar
   function dump( output, purged )
   
      if self.initcode and not purged
         output.write( "{" )
         output.write( self.initcode )
         output.write( "}\n" )
      end
      
      for name, state in self.states         
         state.dump( output, purged )
         > /* White line */
      end
   end
   
end


/*#
   @brief Parser for formal context-free grammar definitions.
*/
class GrammarParser
   
   // grammar state being currently parsed.
   _cgs = nil
   
   // grammar being currently parsed
   _grammar = nil
   
   // internal state.
   _state = nil
   
   // forming nested non terminal stacks.
   _NTStack = nil
   
   // current line
   curLine = 0
   
   // set to true to have tracing on
   verbose = false
   
   /*#
      @brief Error handler function
      
      This property is assinged a function that receives the
      notification of an error in the grammar. On error, 
      it is invoked with the following parameters:
         - The line where the error happened.
         - A textual description of the error that happened.
         
      The default function writes the error notification to the process
      standard output. It can be overridden to change its behavior.
   */
   handleError = function( line, reason )
         > @"ERROR ($line): $reason"
      end
   
   //# Count of errors in last parsing
   errors = 0
   
   mt = nil
   
   commands = .[
               "::="
               
               "r\'" "r\"" "R'" "R\"" "=>" "/*" ":-"
               
               '"' "'" "*" "+" "?" "|" "[" "]"
               "(" ")" "#"
               ":" "." "!" "{" "}"                
               ]
               
   whiteSpaces = .[" " "\n" "\r" "\t"]
   
   // progressive ID for rules
   defRuleID = 0


   /*#
      @brief Parses a Falcon Parser Definition (FPD).
      @param source A TextReader or String from which to read the definition
      
      On success, the parser is configured and ready to parse one or
      more input sources.
   */
   function parse( source, grammar )      
      if not grammar: grammar = Grammar()         
      self._grammar = grammar
      
      self.defRuleID = 0
      
      // we'll use the parameter checking of our multitokenizer
      try
         mt = MultiTokenizer(source)
      catch ParamError 
         raise ParamError( 1001, "Invalid paramters", "Need a string or TextReader" )
      end
      
      mt.giveTokens = true
      
      self.mt = mt
      self.resetTokens()

      syms = .["start" "dfn" "quote" "defBody"
               "defPreamble" "defPostamble"
               "code" "Rafter" "escape"
               "defName1" "defName2"
               "codeQuote" "codeEsc"
               "comment"
               "defState" "defPState" "defPState2" "postState"
               "transition"
               "termName"
               ]
      call( makeEnum, map({[v] "S." + v}, syms ) )
      self._resetParsing()
      
      commands = self.commands
      self.mt = mt

      parCount = 0
      code = m""
      
      // cached token (name)
      currentDefName = nil
      // cached DefRule we're working on
      currentAlt = nil
      // cached DefSymbol at top of the NTStack.
      currentNT = nil
      
      // variables controlling quotes
      Rignore = false
      Rquote = false
      quoteType = false
      quoteText = nil
      oldState = nil
      stateName = nil
      termName = nil
      
      codeStage = 0
      // level of parenthesis inside an alternative.
      parLevel = 0
      
      // used to reiterate the same token in different states
      take = true
            
      while mt.hasNext

         // used to reiterate the same token in different states
         if take
            tok = mt.next()
         else
            take = true
         end
         
         // manage comments
         //  -- notice that in code the lexer changes state, 
         //  -- so we can't parse the comments in codeblocks.
         if tok == "/*" and self._state != ~S..quote and self._state != ~S..escape
            oldState = self._state
            self._state = ~S..comment
            mt.clearTokens()
            mt.add("*/", "\n")
         end
         
         // count lines and discard blanks
         if tok == "\n" or tok == " " or tok == "\r" or tok == "\t"
            // but if we are after a regular expression, change state
            if self._state == ~S..Rafter
               // time to create the RE
               self.commitRE( quoteText, currentNT, Rignore ?"i":"" )
               self.changeState( ~S..defsdBody )
            elif self._state == ~S..code
               code += tok
            elif self._state == ~S..quote
               quoteText += tok
            end

            // also, count line if necessary
            if tok == "\n"
               // we wait a newline after a state declararion
               if self._state == ~S..postState
                  // return to initial state
                  self.changeState(~S..start)
               end
               
               self.curLine ++
            end
            
            continue         
         // ignore white spaces and token separators.
         elif tok == "" 
            continue
         end
         
         switch self._state
         
            case ~S..start
               if tok == '{'
                  if grammar.initcode
                     self.error(self.curLine, "Global initialization code already defined" )
                  end
                  // anyhow take the code as a preamble
                  code = m""
                  codeStage = 0
                  grammar.initcode_line = self.curLine
                  self.enterCode(~S..code)
                  
               elif tok == "["
                  self.changeState( ~S..defState, tok )                  
               elif tok == "#"
                  self.changeState( ~S..defPreamble, tok )
               elif tok == "=>"
                  self.changeState( ~S..defPostamble, tok)
               elif tok in commands
                  self.xerror(self.curLine, "invalid declaration")
               else               
                  self.changeState( ~S..dfn, tok )
                  currentDefName = tok
               end
               
            
            case ~S..defPreamble, ~S..defPostamble
               if tok == '{'
                  if self._state == ~S..defPreamble
                     data = self._cgs.preamble
                     self._cgs.preamble_line = self.curLine
                     word = "preamble"
                     codeStage = 1
                  else
                     data = self._cgs.postamble
                     self._cgs.postamble_line = self.curLine
                     word = "postamble"
                     codeStage = 2
                  end
                  
                  if data
                     self.error(self.curLine, @"State $word already defined" )
                  end
                  
                  // anyhow take the code as a preamble
                  code = m""
                  self.enterCode(~S..code)
               else
                  self.xerror(self.curLine, "Expected preamble or postamble" )
               end
                              
            case ~S..defState
               if tok in commands
                  self.xerror(self.curLine, "invalid declaration")
               else
                  stateName = tok
                  self.changeState( ~S..defPState, tok )
               end
               
            case ~S..defPState            
               if tok == ":"
                  if parLevel > 0
                     self.xerror( self.curLine, "Can assign parameter names to top-level tokens only" )
                  else                     
                     // we expect state names
                     self.addGState(stateName)
                     self.changeState( ~S..defPState2, tok )
                  end
               elif tok == "]"
                  // completed state delcaration
                  self.addGState(stateName)
                  self.changeState( ~S..postState, tok )
               else
                  self.xerror(self.curLine, "Invalid state declaration")
               end               
               
            case ~S..defPState2
               if tok == "]"
                  // completed state delcaration
                  self.changeState( ~S..postState, tok )
               elif tok in commands
                  self.xerror(self.curLine, "invalid declaration")
               else
                  // a parent state for the current state
                  self.addGStateInclude(tok)
               end
               
            case ~S..dfn
               if tok == "::="
                  currentNT, currentAlt = self.pushNT(currentDefName)                  
                  self.changeState(~S..defBody, tok)
               elif tok == ":-"
                  termName = currentDefName
                  self.changeState(~S..termName, tok)
               else
                  self.xerror(self.curLine, "Need ::= after token specification.")
               end
               
            case ~S..termName
               switch tok
                  case "r\'", "R'", "r\"", "R\"", '"', "'"
                     Rignore = (tok == "R'" or tok == "R\"")
                     quoteType = (tok[-1] == '"')
                     Rquote = (tok[0] == 'R' or tok[0] == 'r')
                     quoteText = m""
                     self.enterQuote(tok)
                  default
                     self.xerror(self.curLine, "Named terminal definition must be a single string")
                  end                  
               
            case ~S..defBody
               // now things get interesting.
               switch tok
               
                  case "!"
                     currentNT.complete = true
               
                  case "."
                     // done
                     if parLevel > 0
                        self.error(self.curLine, "Unbalanced open parenthesis at rule closing")
                     else
                        self.commitNT( currentNT )
                     end
                     // anyhow reset the rule
                     self.changeState(~S..start, tok)
                     // current cache reset
                     currentAlt = currentNT = currentDefName = nil
                     
                  case "|"
                     // new alternative
                     currentAlt = DefRule( currentNT, self.curLine, ++self.defRuleID )
                     currentNT.alts += currentAlt
                     // stay in defbody state
                     
                  case "(" 
                     parLevel++
                     newNT, newAlt = self.pushNT()                     
                     topTok = DefEntry(newNT, self.curLine)                     
                     currentAlt.add(topTok)
                     newNT.parents += currentAlt
                     currentNT, currentAlt = newNT, newAlt                     
                     
                  case ")"
                     if parLevel == 0
                        self.xerror(self.curLine, "Unbalanced closed parenthesis")
                     else  
                        parLevel--
                        if currentAlt.sequence.empty
                           self.error(self.curLine, "Empty sub-alternative")
                           // but to not invalidate this rule
                        end
                        currentNT, currentAlt = self.popNT()
                     end
                     // consider this as if it was the post-name
                     self.changeState(~S..defName1, tok )
      
                  case "{"
                     code = m""
                     codeStage = 3
                     self.enterCode(~S..code)
                     
                  case "r\'", "R'", "r\"", "R\"", '"', "'"
                     Rignore = (tok == "R'" or tok == "R\"")
                     quoteType = (tok[-1] == '"')
                     Rquote = (tok[0] == 'R' or tok[0] == 'r')
                     quoteText = m""
                     self.enterQuote(tok)                     
                                          
                  case "=>"
                     self.changeState( ~S..transition, tok )
                     
                  default
                     if tok in commands
                        self.xerror(self.curLine, "Unexpected token '" + tok + "'" )
                     else
                        // the token is a named token (we don't know of what kind) in this alternative
                        self.commitDefEntry( tok, currentNT )
                        // enter in defName states
                        self.changeState( ~S..defName1, tok )
                     end
               end
               
            case ~S..defName1
               // we're past the token name, and waiting for ':' to define the name as paramter in code
               if tok == ':'
                  // wait for the real name
                  self.changeState( ~S..defName2, tok )
               elif tok == "*" or tok == "+" or tok == "?"
                  lastTok = currentAlt.sequence[-1]
                  if lastTok.repeat != DefEntry.tSingle
                     self.xerror(self.curLine, "Conflicting repetition type" )                        
                  else                     
                     switch tok
                        case "*": lastTok.repeat = DefEntry.tAsterisk 
                        case "+": lastTok.repeat = DefEntry.tPlus
                        case "?": lastTok.repeat = DefEntry.tQMark
                     end
                  end
                  // stay in this state.
               else
                  // go back to body definition and reparse the same token
                  take = false
                  self.changeState( ~S..defBody, tok )
               end
               
            case ~S..defName2
               if tok in commands
                  self.xerror(self.curLine, "Waiting for token name but received '" + tok + "'" )
               else                  
                  self.trace( "Assigning name '", tok, "' to token ", currentAlt.sequence[-1].symbol.name )
                  currentAlt.sequence[-1].pname = tok
                  self.changeState( ~S..defBody, tok )
               end
               
            case ~S..quote
               if tok == "\\"
                  self.changeState( ~S..escape, tok )
               else
                  if (quoteType and tok == '"') or (not quoteType and tok == "'")
                     if Rquote
                        self.changeState( ~S..Rafter, tok )
                     else
                        if termName
                           self.commitTerminal(termName, quoteText)
                           termName = nil
                           self.changeState( ~S..start, tok )
                        else
                           self.commitText(quoteText, currentNT )
                           self.changeState( ~S..defName1, tok )
                        end
                     end
                     self.resetTokens()
                  else
                     quoteText += tok
                  end
               end
               
            case ~S..escape
               switch tok
                  case "r": quoteText += "\r"
                  case "n": quoteText += "\n"
                  case "t": quoteText += "\t"
                  case "\\": quoteText += "\\"
                  default: quoteText += tok
               end
               
               self.changeState( ~S..quote, tok )               
                   
            case ~S..Rafter
               // time to create the RE
               if tok in commands
                  if termName
                     termName = nil
                     self.changeState( ~S..start, tok )
                     self.xerror(self.curLine, "Terminal definition cannot have more commmands" )
                     continue
                  end
                  
                  take = false   
                  opts = m""
               else
                  opts = tok                  
               end
               
               if Rignore: opts += "i"
               if termName
                  self.commitTerminal(termName, quoteText, opts )
                  termName = nil
                  self.changeState( ~S..start, tok )
               else
                  self.commitRE( quoteText, currentNT, opts )               
                  self.changeState( ~S..defName1, tok )
               end
               
            case ~S..code               
               switch tok 
                  case '}'
                     // are we done?
                     if parCount == 0
                        // reset the parser to the normal status
                        self.resetTokens()
                        
                        switch codeStage
                           case 0
                              grammar.initcode = code
                              self.changeState(~S..start, tok)
                           case 1
                              self._cgs.preamble = code
                              self.changeState(~S..start, tok)
                           case 2
                              self._cgs.postamble = code
                              self.changeState(~S..start, tok)
                           case 3
                              self.commitCode(code, currentAlt)                        
                              self.changeState(~S..defBody, tok)  
                        end
                     else
                        code += "}"
                        parCount--
                     end
                  
                  case '{'
                     code += "{"
                     parCount++
                  
                  case "\\"
                     code += "\\"
                     
                  case '"', "'"
                     code += tok
                     quoteType = tok == '"'
                     self.changeState(~S..codeQuote, tok)
                  default
                     code += tok
               end
                  
            case ~S..codeQuote
               // we always add the token.
               code += tok
               
               if tok == "\\"                  
                  self.changeState(~S..codeEsc, tok)
               elif (quoteType and tok == '"') or (not quoteType and tok == "'")
                  self.changeState(~S..code, tok)
               end
                  
            case ~S..codeEsc
               code += tok
               self.changeState(~S..codeEsc, tok)
               
            case ~S..transition
               if tok == "#"
                  if currentAlt.transition != nil
                     self.xerror( self.curLine, "Conflicting state pop after transition" )
                  else
                     currentAlt.transpop++
                  end
               elif tok == "." or tok == "{"
                  take = false
                  self.changeState(~S..defBody, tok)
               elif tok in commands
                  self.xerror( self.curLine, "Unexpected token in transition declaration" )
               else
                  if currentAlt.transition != nil
                     self.xerror( self.curLine, "Conflicting transition declaration" )
                  elif currentAlt.transpop != 0
                     self.xerror( self.curLine, "Conflicting transition declaration after state pop" )
                  else
                     currentAlt.transition = tok
                  end
               end
               
            // manage exit from comment.
            case ~S..comment
               if tok == "*/"
                  self._state = oldState
                  self.resetTokens()
               end
               
         end /* Switch */
         
      end
      
      // we should be in start state
      if self._state = ~S..start
         self.error( self.curLine, "Unterminated definition at end of file" )
      end
      
      self.reportUnresolved()
      self.resolveTransitions()
      if self.errors == 0 
         // if states are inconsistent, we can't resolve the root tokens.
         self.resolveRoots()            
      end
      
      // deref unused stuff
      self.mt = nil
      self._grammar = nil
      
      // shall generate the grammar?
      return self.errors == 0 ? grammar : nil
   end
   
   
   function resetTokens()
      self.trace( "resetTokens()" )
      self.mt.clearTokens()
      call( self.mt.add, self.commands )
      call( self.mt.add, self.whiteSpaces )
   end
   
   function enterQuote(tok)
      self.trace( "enterQuote()" )
      self.mt.clearTokens()
      self.mt.add('"', "'", "\\", "\n")
      self.changeState( ~S..quote, tok )
   end

   function enterCode(status)   
      // change the MultiTokenizer
      self.mt.clearTokens()
      self.mt.add('"', "'", "\\", "{", "}", "\n")
      parCount = 0
      self.changeState( status )
   end

   function commitNT( nt )
      self.trace( "commitNT()" )   
      if self._NTStack.empty
         self.error( self.curLine, "Internal error: committed empty stack" )
      end
      
      // check for a named terminal      
      if nt.name == "eat"
         self._cgs.eat = map( {x=>x.symbol.content}, nt.alts[0].sequence )
         self._cgs.entries -= "eat"
      elif nt.name == "precedence"
         self._calcPriority( nt )
         self._cgs.entries -= "precedence"
         self._cgs._precRule = nt
      end
      
      self._NTStack.clear()
   end
   
   /*
      Pushes a new token in the sequence of forming tokens.
      @return [DefSymbol, DefRule]
   */
   function pushNT( tokenName )
      self.trace( @"pushNT($tokenName)" )
      
      // evevntually resolve the token now
      if tokenName
         state = self._cgs
         nt = state.entries.find(tokenName,nil)
         if not nt
            // if not found, create anew...
            self.trace( @"pushNT($tokenName) -- creating new non-terminal" )
            nt = DefSymbol(tokenName, DefSymbol.tNT )
            state.entries[tokenName] = nt
         elif nt.type != DefSymbol.tNT 
            // Could be an undefined, or a previously defined terminal            
            self.trace( @"pushNT($tokenName) -- Resolved previously undefined symbol" )
            if nt.type != DefSymbol.tUnresolved
               self.xerror(self.curLine, @"Cannot redefine the type of \"${tokenName}\"" )
               // but go on as if we can.
               if not nt.alts: nt.alts = []
            else
               state.unresolved -= tokenName
               nt.resolveAs( DefSymbol.tNT )
            end
         end
      else
         // anonymous non-terminal
         nt = DefSymbol(nil, DefSymbol.tNT)
      end
      
      self._NTStack.push(nt)
      
      // add a first alternative to the new token
      alt = DefRule( nt, self.curLine, ++self.defRuleID )
      nt.alts += alt            
      
      return [nt, alt]
   end
   
   /*
      Removes the topmost NT and return the previous one.
      @return [DefSymbol, DefRule] or nil
   */
   function popNT()
      self.trace( "popNT()" )
      self._NTStack.pop()
      if self._NTStack.len
         nt = self._NTStack[-1]      
         return [nt, nt.alts[-1]]
      end
      
      return nil
   end
   
   /*
      Commits a token into the currently forming non-terminal
      name -- the name of the non-terminal 
      NT -- the forming non-terminal (a DefSymbol instance)
   */
   function commitDefEntry(name, NT)
      self.trace( "commitDefEntry(", name,")" )
   
      state = self._cgs
      symbol = state.findEntry( name )

      if not symbol
         symbol = self._grammar.predefined.find(name,nil)
      end
      // not even a predefined?
      
      if not symbol
         // create an undefined symbol
         symbol = DefSymbol(name)
         state.unresolved[name] = symbol
         state.entries[name] = symbol
      end

      self._appendToNT(NT, symbol)
   end
   
   /*
      Commits a regular expression terminal token into a forming alternative.
      text -- The regular expression text
      NT -- the forming non-terminal (a DefRule instance)
      opt -- Regular expression options
   */
   function commitRE( text, NT, opts )
      self.trace( "commitRE '", text, "'" )      
      terminals = self._cgs.terminals
      
      try
         re = RE( text, opts )
         term = terminals.find( re, nil )
         if not term
            self.trace( "commitRE -- creating new anonymous terminal for >", text, "<" )     
            term = DefSymbol(nil, DefSymbol.tRE, re )
            terminals[re] = term
         end
                  
         self._appendToNT(NT, term)
         
         //CHECK
         if re notin self._cgs.tokens: self._cgs.tokens += re
      catch ParseError in e
         self.xerror( self.curLine, "Invalid regular expression: " + e )
      end
      
      self.resetTokens()
   end

   /*
      Commits a text terminal token into a forming alternative.
      text -- The text
      alt -- The forming non-terminal rule
   */
   function commitText( text, NT )
      self.trace( "commitText '", text, "'" )
      terminals = self._cgs.terminals
      
      term = terminals.find( text, nil )
      if not term
         self.trace( "commitText -- creating new anonymous terminal for >", text, "<" )     
         term = DefSymbol(nil, DefSymbol.tString, text )
         terminals[text] = term
      end
      
      self._appendToNT(NT, term)
      
      //CHECK
      if text notin self._cgs.tokens: self._cgs.tokens += text
      self.resetTokens()      
   end
   
   /*
      Commits a declared terminal (in form of name :- value)
      name -- the name of the terminal
      text -- The text
      opts -- If not nil (even an empty string), the text is interpreted as a RE, 
              and these are the options.
   */
   function commitTerminal( name, text, opts )
      self.trace( "commitTerminal, ",name," => '", text, "' ", (opts != nil ?"(RE)":"") )  
      
      if opts != nil
         try
            text = RE( text, opts )
         catch ParseError in e
            self.xerror( self.curLine, "Invalid regular expression: " + e )
            return
         end
      end
      
      // find the terminal as a named entry
      entries = self._cgs.entries
      term = entries.find( name, nil )
      terminals = self._cgs.terminals
      if term
         if term.type != DefSymbol.tUnresolved
            self.xerror( self.curLine, "Terminal name '" + name + "' cannot be duplicated" )
            return
         end
         
         // we redefine this as resolved.
         self.trace( "commitTerminal -- Defining terminal ", name, "=> '", text, "'" )     
         term.resolveAs( opts != nil ? DefSymbol.tRE : DefSymbol.tString )
         term.content = text
         // remove from undefined list.
         self._cgs.unresolved -= name
         // redo.
         terminals[text] = term
      else         
         // was the terminal already existing?
         
         term = terminals.find( text, nil )
         if term 
            if term.name
               self.xerror( self.curLine, "Named terminal '" + name + "' had previous name '" + term.name + "'" )
               return
            else
               self.trace( "commitTerminal -- giving name to previously unnamed terminal ", name, "=> '", text, "'" )
               term.name = name
            end
         else               
            // here term is nil
            self.trace( "commitTerminal -- creating new terminal ", name, "=> '", text, "'" )
            term = DefSymbol( name, (opts != nil ? DefSymbol.tRE : DefSymbol.tString), text )
            terminals[text] = term
            entries[name] = term
         end         
      end
            
      // CHECK
      if text notin self._cgs.tokens: self._cgs.tokens += text
   end
   
   /*
      Commits a code into a forming alternative.
      text -- The text
      alt -- the forming alternative (a DefRule instance)
   */
   function commitCode( code, alt )
      self.trace( "commitCode()" )
      alt.code = code
      self.resetTokens()
   end

   
   /*
      Pick the top rule in states
   */
   function resolveRoots()
      g = self._grammar
      // every state must have exactly one token that is not referenced.
      for sname,state in g.states
         self.trace( "Picking the root node of ", state.name )
         refs = state.entries.values()
         for name, nt in state.entries 
            self._removeNTs( refs, nt )            
         end
         
         if refs.len > 1
            self.error( state.line, "Multiple roots in state " + state.name )
            for nt in refs
               self.error( state.line, "DefEntry '" + nt.name + "' is a non-unique root in state " + state.name )
            end
         elif refs.len == 0 and state.entries.len > 0
            self.error( state.line, "State " + state.name +" has no root entry"  )
         else
            state.top = refs[0]
            self.trace( "In state", state.name, "token", state.top.name, "is the root node." )
         end
      end
      
      // Create the meta-rule for the main state.
      main = g.states["main"]
      
      top = main.top
      root = DefSymbol("<root>", DefSymbol.tNT)
      eof = self._grammar.predefined["eof"]
      df = DefRule(root,0, 0)
      df.sequence = [DefEntry(top), DefEntry(eof)]
      root.alts = [df]
      top.parents = [df]
      eof.parents += root
      
      g.root = root
   end
   
   function _removeNTs( refs, nt )
      if nt.isTerminal()
         refs -= nt
         return
      end

      for alt in nt.alts
         for tok in alt.sequence
            child_nt = tok.symbol
            if child_nt.type == DefSymbol.tNT               
               if child_nt != nt and child_nt in refs
                  refs -= child_nt
                  self._removeNTs( refs, child_nt )
               end
            end
         end
      end
      
      return true
   end

   
   function reportUnresolved()
      self.trace( "Report still unresolved tokens" )
      
      grammar = self._grammar
      for sname, state in grammar.states               
         for name, undef in state.unresolved
            self.error( state.line, @"In state [${state.name}] unresolved token ${name}" )
         end
      end
   end
      
   /*
      Resolve transitions.
   */
   function resolveTransitions()
      self.trace( "Resolving transitions" )
      grammar = self._grammar
      for sname, state in grammar.states         
         // resolve transitions in alternatives.
         for name, entry in state.entries
            for alt in entry.alts
               if alt.transition != nil
                  target = grammar.states.find(alt.transition, nil)
                  if not target
                     self.error( alt.line, @"Transition target state \"${alt.transition}\" not found" )
                  else
                     alt.transition = target
                     self.trace("In non terminal ", entry.name, "Resolved transition to", target.name )
                  end
               end
            end
         end
      end
   end
   
   
   function checkStateRecursion(includes, position, parents)
      // break the recursion when done
      if position >= includes.len: return true
      
      state = includes[position]
      if state in parents
         self.error( state.line, @"State \"${state.name}\" is recursively included by a child state")
         return false
      end
      
      parents += state
      if state.includes
         if not self.checkStateRecursion(state.includes, 0, parents)
            return false
         end
      end
      
      return self.checkStateRecursion(includes, position+1, parents)
   end
   
   
   /*#
      @brief Separately compile code snippets.
      @param g The grammar whose code snippets must be compiled.
      
      If the grammar application actions are Falcon code, this
      utility can be used to dynamically compile the code into
      runnable functions.
   */
   function compileSnippets( g )
      self.trace( "compileSnippets()" )

      if g.initcode
         try
            g.initcode_compiled = compile(g.initcode)
         catch in e
            e.line += g.initcode_line
            self.error( e.line, "Compilation errors in preamble:" + e)
         end
      end

      for name,state in g.states
         state.preamble_compiled = self._compSnippet(
               state.preamble_line, state.preamble )
         
         state.postamble_compiled = self._compSnippet(
               state.postamble_line, state.postamble )
               
         // and now, compile each snippet.
         for name,entry in state.entries
            for alt in entry.alts
               // only if we have a code for this alternative
               if alt.code
                  params = []
                  for tok in alt.sequence
                     if tok.pname: params += tok.pname
                  end
                  alt.compiled = self._compSnippet(alt.line, alt.code, params)
               end
            end
         end
         
      end
   end
   
   
   function _compSnippet( line, code, params )
      if not code: return nil
      //self.trace( @"compileSnippets($line, ${code.describe()}, ${params.describe()}" )
      
      try
         fullcode = "{ctx"
         if params: fullcode = fullcode + "," + ",".merge(params)  
         fullcode = fullcode + "=> " + code + "}"
         self.trace( "Compiling " + fullcode )
         gen = compile( fullcode, nil, line )         
         // this compile a function generator; we must invoke it to get the funcion
         comp = gen()
         return comp
      catch in e
         e.line = line
         self.error( line, (@"Compilation errors in snippet at ${line}:") + e.toString())
         return nil
      end 

   end
      
   //========================================================================
   // Utilities
   //========================================================================
   
   function _appendToNT(NT, symbol)
      alt = NT.alts[-1]
      if alt notin symbol.parents: symbol.parents += alt
      token = DefEntry(symbol, self.curLine)
      alt.add(token)
   end

   function _resetParsing()
      self._state = ~S..start
      self.curLine = 1
      self.errors = 0
      self._NTStack = []
   end
   
   /** Adds a grammar state to the state definition.
   */
   function addGState( name )
      self.trace( "Adding Grammar State: ", name )
      if name in self._grammar.states
         // ignore [main] as first state declaration
         if name != "main" or self._cgs.name != "main"
            self.xerror(self.curLine, "Duplicate state declaration:", name)
         end

         // anyhow return current state (don't change it)
         return self._cgs
      end
      
      // clear to add a new state
      gstate = GrammarState(name, self.curLine)
      self._cgs = gstate
      self._grammar.states[name] = gstate
      return gstate
   end

   function addGStateInclude( name )
      state = self._cgs
      self.trace( "Adding Inclusion of Grammar State: ", name , " to ", state.name)      
      
      objState = self._grammar.states.find(name, nil)            
      
      if objState == nil
         self.error( state.line, @"In state [${state.name}] unresolved inclusion of ${name}" )                              
         return
      end
            
      // can we add the state?
      if self.checkStateRecursion( state.includes + objState, 0, [] )
         state.includes += objState
         self.trace( @"Completed include resolution of state \"${name}\"" )
      end
         
   end
   
   function changeState( newState, tok )
      self.trace( tok, ": ", self._state, "=>", newState )
      self._state = newState()
   end
   
   function trace()
      if self.verbose
         > " ".merge(map( {[v] v.toString()}, passvp() ))
      end
   end
   
   function _calcPriority( nt )
      self.trace( "Calculating precedence in state ", self._cgs.name)
      prec = nt.alts.len
      for alt in nt.alts
         nameList = m""
         for token in alt.sequence
            content = token.symbol
            if content.isTerminal()
               if token.pname == "right"
                  content.assoc = DefSymbol.tARight
               else
                  content.assoc = DefSymbol.tALeft
               end
               content.prec = prec
            end
         
            nameList += " " + content.name
         end
         self.trace( "-- Priority ", prec, " tokens:", nameList )
         prec--
      end      
   end
   
   /*
      Consume up to the limits declared as variable parameters
   */
   function consume(mt)
      limits = passvp()
      while mt.hasNext
         tok = mt.next()
         if tok == "\n"
            self.curLine ++
         end
         
         if tok in limits
            break
         end
      end
   end
         
   function error(line, reason)
      self.handleError(line, reason)      
      self.errors++
   end
   
   function xerror(line, reason)
      self.error( line, reason )
      self.consume(self.mt,".","\n")
      self._state = 0
   end
         
end

