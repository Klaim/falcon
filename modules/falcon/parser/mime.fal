/*
    FALCON - MIME Parser

    FILE: mime.fal

    Multipurpose Internet Mail Extensions parser.
    -------------------------------------------------------------------
    Author: Stanislas Marquis
    Begin: Sun, 07 Nov 2010 11:24:04 +0200

    -------------------------------------------------------------------
    (C) Copyright 2010: the FALCON developers (see list in AUTHORS file)

    See LICENSE file for licensing details.
 */


/*# @brief Class representing a MIME header field.
    @param txt String to parse.
 */
class MIMEHeaderField( txt )

    //# Header name.
    name = nil
    //# Header body (value).
    body = nil

    init
        pos = txt.find( ":" )
        if pos == -1: raise ParseError( 11000, i"Invalid MIME header field", txt )
        self.name = txt[:pos]
        self.body = txt[pos+1:].trim()
        // remove tabs and crlfs
        self.body = self.body.replace( "\t", "" ).replace( "\r", "" ).replace( "\n", " " )
    end
end


/*# @brief Class representing a MIME entity.
    @param stream A stream to parse.
    @optparam endmark In case of multipart parsing, the boundary where entity ends.

    This class parses a stream positioned at the beginning of a MIME entity.
    If the entity is nested, the endmark is not nil and parsing must stop there.

    The headers property is a list containing all the entity's headers, as
    MIMEHeaderField objects.

    The body_start and body_stop properties indicate where the body of the entity
    starts or ends, respectively, in the given stream.

    In case of a multipart entity, the parts property is a list containing the
    inner MIMEEntity objects.
 */
class MIMEEntity( stream, endmark )

    //# A list of MIMEHeaderField instances.
    headers = []
    //# The position where the body starts in the stream
    body_start = -1
    //# The position where the body ends in the stream
    body_end = -1
    //# The list of nested entities, in case of multipart
    parts = nil

    // private cache
    _encoding = nil
    _type = nil
    _type_params = nil

    init
        // detect and parse the headers
        self._parseHeaders( stream )

        if self.mainType() == "multipart"

            boundary = self.getTypeParam( "boundary" )
            if boundary == nil: raise ParseError( 11001, i"Invalid MIME entity" )
            separator = "--" + boundary
            terminator = separator + "--"
            self.parts = []

            // get the parts recursively
            while ( line = stream.grabLine() ) != oob( 0 )
                if line == terminator
                    self.body_end = self.parts[-1].body_end
                    return self
                elif line == separator
                    if self.body_start == -1: self.body_start = stream.tell()
                    ent = MIMEEntity( stream, separator )
                    self.parts += ent
                    // it may be the last one
                    stream.seek( ent.body_end )
                end
            end

            // we should not get here
            raise ParseError( 11001, i"Invalid MIME entity" )

        else
            // not a multipart entity
            self.body_start = stream.tell()

            if endmark == nil
                stream.seekEnd( 0 )
                self.body_end = stream.tell()
                return self // we're done
            end

            // nested entity, find the boundary
            pos = stream.tell()
            while ( line = stream.grabLine() ) != oob( 0 )
                if line.startsWith( endmark )
                    self.body_end = pos
                    return self // we're done
                else
                    pos = stream.tell()
                end
            end

            // we should not get here
            raise ParseError( 11001, i"Invalid MIME entity" )
        end
    end

    function _parseHeaders( stream )
        // find the first blank line and parse headers
        // we leave the stream where the body should start
        hdrs = []
        while 1
            line = stream.grabLine()
            if line == oob( 0 ): raise ParseError( 11001, i"Invalid MIME entity" )
            if line == "": break
            hdrs += line
        end
        buf = strBuffer( 4096 )
        for line in hdrs
            forfirst
                buf += line
                continue
            end
            formiddle
                if line[0] in [ "\t", " " ]
                    buf += line
                    continue
                else
                    self.headers += MIMEHeaderField( buf )
                    buf = line
                end
            end
            forlast
                if line[0] in [ "\t", " " ]
                    buf += line
                    self.headers += MIMEHeaderField( buf )
                else
                    self.headers += MIMEHeaderField( buf )
                    self.headers += MIMEHeaderField( line )
                end
            end
        end
    end

    /*# @brief Return the value of first header field whose name is given in parameter.
        @param name The header name.
        @return The value of the first MIMEHeaderField instance found, or nil if not found.
     */
    function getHeaderValue( name )
        for hf in self.headers
            if hf.name == name: return hf.body
        end
        return nil
    end

    /*# @brief Return the encoding specified in the Content-Transfer-Encoding message header.
        @return The encoding found. If no such header exists, return '7bit'.
     */
    function encoding()
        if self._encoding == nil
            v = self.getHeaderValue( "Content-Transfer-Encoding" )
            self._encoding = v == nil ? "7bit" : v
        end
        return self._encoding
    end

    function _parseContentType( txt )
        // parse the content-type header value to fill _type and _type_params
        if txt == nil
            // default
            self._type = "text/plain"
            self._type_params = []
            return
        end
        pos = txt.find( ";" )
        if pos == -1
            self._type = txt
            self._type_params = []
            return
        end
        self._type = txt[:pos].trim()
        self._type_params = [].comp( txt[pos+1:].split( ";" ), { v => v.trim() } )
    end

    /*# @brief Return the message type (of the form type/subtype) as specified in the Content-Type header.
        @return The message type. If no such header exists, return 'text/plain'.
     */
    function type()
        if self._type == nil
            self._parseContentType( self.getHeaderValue( "Content-Type" ) )
        end
        return self._type
    end

    /*# @brief Return the main type as specified in the Content-Type header.
        @return The main type. If no such header exists, return 'text'.
     */
    function mainType()
        if self._type == nil
            self._parseContentType( self.getHeaderValue( "Content-Type" ) )
        end
        return self._type.split( "/" )[0]
    end

    /*# @brief Return the subtype as specified in the Content-Type header.
        @return The subtype. If no such header exists, return 'plain'.
     */
    function subType()
        if self._type == nil
            self._parseContentType( self.getHeaderValue( "Content-Type" ) )
        end
        return self._type.split( "/" )[1]
    end

    /*# @brief Return the parameter list of the Content-Type header. This is a list of strings.
     */
    function typeParams()
        if self._type == nil
            self._parseContentType( self.getHeaderValue( "Content-Type" ) )
        end
        return self._type_params
    end

    /*# @brief Return the value of the first parameter (as returned by typeParams()) of the form name=value for the given name.
        @param name the type parameter name.
        @return The value, or nil if nothing found.

        If value is surrounded by quotes of the form ‘<...>‘ or ‘"..."‘, those are removed.
     */
    function getTypeParam( name )
        got = nil
        for p in self.typeParams()
            pos = p.find( "=" )
            if pos != -1
                if p[:pos].trim().lower() == name
                   got = p[pos+1:].trim()
                   break
                end
            else
                if p.lower() == name: return p
            end
        end
        if got in [ nil, "" ]: return nil
        // value enclosed in "" or <> ?
        if ( ( got[0] == '"' and got[-1] == '"' )
            or ( got[0] == '<' and got[-1] == '>' ) )
            got = got[1:-1]
        end
        return got == "" ? nil : got
    end

end


/*# @brief Class representing a whole MIME message.
    @param stream Stream to parse.
 */
class MIMEMessage( stream ) from MIMEEntity( stream )
end


export MIMEMessage

