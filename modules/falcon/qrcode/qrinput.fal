/*#
 * @file        qrinput.fal
 * @brief       Bit stream manipulation.
 * @begin       17-Sep-2010
 * @author      <a href="mailto:giuseppe.greco@agamura.com">Giuseppe Greco</a>
 *
 * @copyright   (C) 2010 href="http://www.falconpl.org">The Falcon Programming Language</a>
 * @legalnotice Released under FPLL 1.1 or GPL 2.0 at your choice.
 */

import QrBitStream from .qrbitstream as QrBitStream
import QrError from .qrerror as QrError
import QrMode from .qrconst as QrMode
import QrErrorCorrectionLevel from .qrconst as QrErrorCorrectionLevel
import QrSpec from .qrspec as QrSpec
import QrSpecConst from .qrspec as QrSpecConst

enum QrInputConst
    structure_header_bits = 20
    max_structured_symbols = 16
end

QrAnTable = [
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43,
     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 44, -1, -1, -1, -1, -1,
    -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
    25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
]

class QrInputItem(mode, size, data, bitStream)
    _mode = QrMode.null
    _size = 0
    _data = nil
    _bitStream = nil

    init
        if data == nil
            raise QrError(QrError.invalid_param, "data is null")
        end

        data = data[0:min(len(data), size)]

        if len(data) < size
            arrayMerge(data, arrayBuffer(size - len(data), 0))
        end

        if not QrInput.checkMode(mode, size, data)
            raise QrError(QrError.encoding_error, @i'Mode $(mode) is not suitable for encoding the specified data')
        end

        self._mode = mode
        self._size = size
        self._data = data
        self._bitStream = bitStream
    end

    function __get_mode()
        return self._mode
    end

    function __get_bitStream()
        return self._bitStream
    end

    function encodeModeNum(version)
        val = 0x1
        words = int(self._size / 3)

        bitStream = QrBitStream()
        bitStream.appendNum(4, val)
        bitStream.appendNum(QrSpec.lengthIndicator(QrMode.num, version), self._size)

        for i in [0:words]
            val  = (self._data[i * 3][*0] - "0"[*0]) * 100
            val += (self._data[i * 3 + 1][*0] - "0"[*0]) * 10
            val += self._data[i * 3 + 2][*0] - "0"[*0]
            bitStream.appendNum(10, val)
        end

        if self._size - words * 3 == 1
            val = self._data[words * 3][*0] - "0"[*0]
            bitStream.appendNum(4, val)
        elif self._size - words * 3 == 2
            val  = (self._data[words * 3][*0] - "0"[*0]) * 10
            val += self._data[words * 3 + 1][*0] - "0"[*0]
            bitStream.appendNum(7, val)
        end

        self._bitStream = bitStream
    end

    function encodeModeAn(version)
        words = int(self._size / 2)

        bitStream = QrBitStream()
        bitStream.appendNum(4, 0x02)
        bitStream.appendNum(QrSpec.lengthIndicator(QrMode.an, version), self._size)

        for i in [0:words]
            val  = int(QrInput.lookAnTable(self._data[i * 2][*0])) * 45
            val += int(QrInput.lookAnTable(self._data[i * 2 + 1][*0]))
            bitStream.appendNum(11, val)
        end

        if self._size && 1
            val = QrInput.lookAnTable(self._data[words * 2][*0])
            bitStream.appendNum(6, val)
        end

        self._bitStream = bitStream
    end

    function encodeMode8Bit(version)
        bitStream = QrBitStream()
        bitStream.appendNum(4, 0x4)
        bitStream.appendNum(QrSpec.lengthIndicator(QrMode.eight_bit, version), self._size)

        for i in [0:self._size]
            bitStream.appendNum(8, self._data[i][*0])
        end

        self._bitStream = bitStream
    end

    function encodeModeKanji(version)
        bitStream = QrBitStream()
        bitStream.appendNum(4, 0x8)
        bitStream.appendNum(QrSpec.lengthIndicator(QrMode.kanji, version), int(self._size / 2));

        for i in [0:self._size:2]
            val = (self._data[i][*0] << 8) || self._data[(i + 1)]
            if val <= 0x9FFC
                val -= 0x8140
            else
                val -= 0xC140
            end

            h = (val >> 8) * 0xC0
            val = (val && 0xFF) + h

            bitStream.appendNum(13, val)
        end

        self._bitStream = bitStream
    end

    function encodeModeStructure()
        bitStream = QrBitStream()

        bitStream.appendNum(4, 0x03)
        bitStream.appendNum(4, self._data[1][*0] - 1)
        bitStream.appendNum(4, self._data[0][*0] - 1)
        bitStream.appendNum(8, self._data[2][*0])

        self._bitStream = bitStream
    end

    function estimateBitStreamSizeOfEntry(version)
        bits = 0

        if version == 0; version = 1; end

        if self._mode == QrMode.num
            bits = QrInput.estimateBitsModeNum(self._size)
        elif self._mode == QrMode.an
            bits = QrInput.estimateBitsModeAn(self._size)
        elif self._mode == QrMode.eight_bit
            bits = QrInput.estimateBitsMode8(self._size)
        elif self._mode == QrMode.kanji
            bits = QrInput.estimateBitsModeKanji(self._size)
        elif self._mode == QrMode.structure
            return QrInputConst.structure_header_bits
        else
            return 0
        end

        l = QrSpec.lengthIndicator(self._mode, version)
        m = 1 << l
        num = int((self._size + m - 1) / m)
        bits += num * (4 + l)

        return bits
    end

    function encodeBitStream(version)
        words = QrSpec.maxWords(self._mode, version)

        if self._size > words
            inputItem1 = QrInputItem(self._mode, words, self._data)
            inputItem2 = QrInputItem(self._mode, self.size - words, self._data[words:len(self._data) - words])

            inputItem1.encodeBitStream(version)
            inputItem2.encodeBitStream(version)

            self._bitStream = QrBitStream()
            self._bitStream.append(inputItem1.bitStream)
            self._bitStream.append(inputItem2.bitStream)
        else     
            if self._mode ==  QrMode.num
                self.encodeModeNum(version)
            elif self._mode == QrMode.an
                self.encodeModeAn(version)
            elif self._mode == QrMode.eight_bit
                self.encodeMode8Bit(version)
            elif self._mode == QrMode.kanji
                self.encodeModeKanji(version)
            elif self._mode == QrMode.structure
                self.encodeModeStructure()
            else
                raise QrError(QrError.invalid_mode, @i'$(self._mode) is not supported')
            end
        end

        return self._bitStream.size
    end
end

class QrInput(version, errorCorrectionLevel)
    _version = 0
    _items = []
    _errorCorrectionLevel = 0

    init
        if version == nil; version = 0; end
        if errorCorrectionLevel == nil; errorCorrectionLevel = QrErrorCorrectionLevel.L; end

        self._version = version
        self.errorCorrectionLevel = errorCorrectionLevel
    end

    function __get_version()
        return self._version
    end

    function __set_version(version)
        if version < 0 or version > QrSpecConst.max_version
            raise QrError(QrError.invalid_version, @i'$(version) is not supported')
        end

        self._version = version
    end

    function __get_errorCorrectionLevel()
        return self._errorCorrectionLevel
    end

    function __set_errorCorrectionLevel(errorCorrectionLevel)
        if errorCorrectionLevel > QrErrorCorrectionLevel.H
            raise QrError(QrError.invalid_correction_error_level, @i'$(errorCorrectionLevel) not supported')
        end

        self._errorCorrectionLevel = errorCorrectionLevel
    end

    function appendEntry(entry)
        arrayAdd(self._items, entry)
    end

    function append(mode, size, data)
        entry = QrInputItem(mode, size, data)
        arrayAdd(self._items, entry)
    end

    function insertStructuredAppendHeader(size, index, parity)
        if size > QrInputConst.max_structured_symbols
            raise QrError(QrError.invalid_param, @i'size exceeds $(QrInputConst.max_structured_symbols)')
        end

        if index <= 0 or index > QrInputConst.max_structured_symbols
            raise QrError(QrError.invalid_param, @i'index is not between 0 and $(QrInputConst.max_structured_symbols)')
        end

        buffer = [size, index, parity]
        entry = QrInputItem(QrMode.structure, 3, buffer)
        arrayIns(self._items, 0, entry)
    end

    function calcParity()
        parity = 0

        for item in self._items
            if item.mode != QrMode.structure
                for i in [item.size - 1:0:-1]
                    parity ^= item.data[i]
                end
            end
        end

        return parity
    end

    function _checkModeNum(size, data)
        for i in [0:size]
            if (data[*i] < "0"[*0]) or (data[*i] > "9"[*0])
                return false
            end
        end

        return true
    end

    function estimateBitsModeNum(size)
        w = int(size / 3)
        bits = w * 10

        switch size - w * 3
            case 1
                bits += 4
            case 2
                bits += 7
        end

        return bits;
    end

    function lookAnTable(c)
        return c > 127 ? -1 : QrAnTable[c]
    end

    function _checkModeAn(size, data)
        for i in [0:size]
            if self.lookAnTable(data[*i]) == -1
                return false
            end
        end

        return true
    end

    function estimateBitsModeAn(size)
        w = int(size / 2)
        bits = w * 11

        if size && 1; bits += 6; end
        return bits
    end

    function estimateBitsMode8(size)
        return size * 8
    end

    function estimateBitsModeKanji(size)
        return int((size / 2) * 13)
    end

    function _checkModeKanji(size, data)
        if size && 1; return false; end

        for i in [0:size:2]
            val = (data[*i] << 8) || data[*(i + 1)]
            if val < 0x8140 or (val > 0x9FFC and val < 0xE040) or val > 0xEBBF
                return false
            end
        end

        return true
    end

    function checkMode(mode, size, data)
        if size <= 0
            raise QrError(QrError.invalid_param, i"size is less than 1")
        end

        if mode == QrMode.num
            return self._checkModeNum(size, data)
        elif mode == QrMode.an
            return self._checkModeAn(size, data)
        elif mode == QrMode.kanji
            return self._checkModeKanji(size, data)
        elif mode == QrMode.eight_bit
            return true
        elif mode == QrMode.structure
            return true
        else
            raise QrError(QrError.invalid_mode, @i'$(mode) is not supported')
        end
    end

    function estimateBitStreamSize(version)
        bits = 0

        for item in self._items
            bits += item.estimateBitStreamSizeOfEntry(version)
        end

        return bits
    end

    function estimateVersion()
        version = 0
        previous = 0

        loop
            previous = version
            bits = self.estimateBitStreamSize(previous)
            version = QrSpec.getMinVersion(int((bits + 7) / 8), self.errorCorrectionLevel)
        end not version > previous

        return version
    end

    function lengthOfCode(mode, version, bits)
        payload = bits - 4 - QrSpec.lengthIndicator(mode, version)

        if mode == QrMode.num
            chunks = int(payload / 10)
            remain = payload - chunks * 10
            size = chunks * 3
            if remain >= 7; size += 2; elif remain >= 4; size++; end
        elif mode == QrMode.an
            chunks = int(payload / 11)
            remain = payload - chunks * 11
            size = chunks * 2
            if remain >= 6; size++; end
        elif mode == QrMode.eight_bit
            size = int(payload / 8)
        elif mode == QrMode.kanji
            size = int((payload / 13) * 2)
        elif mode == QrMode.structure
            size = int(payload / 8)
        else
            size = 0
        end

        maxsize = QrSpec.maxWords(mode, version)
        if size < 0; size = 0; end
        if size > maxsize; size = maxsize; end

        return size;
    end

    function createBitStream()
        total = 0

        for item in self._items
            bits = item.encodeBitStream(self.version)
            total += bits
        end

        return total
    end

    function convertData()
        version = self.estimateVersion()

        if version > self.version
            self.version = version
        end

        loop
            bits = self.createBitStream()

            version = QrSpec.getMinVersion(int((bits + 7) / 8), self.errorCorrectionLevel)
            if version > self.version
                self.version = version
            else; break; end
        end false
    end

    function appendPaddingBit(bitStream)
        bits = bitStream.size
        maxWords = QrSpec.getDataLength(self.version, self.errorCorrectionLevel)
        maxBits = maxWords * 8

        if maxBits == bits; return; end

        if maxBits - bits < 5
            bitStream.appendNum(maxBits - bits, 0)
            return
        end

        bits += 4
        words = int((bits + 7) / 8)

        padding = QrBitStream()
        padding.appendNum(words * 8 - bits + 4, 0)
        
        paddingLen = maxWords - words
        
        if paddingLen > 0
            paddingBuffer = arrayBuffer(paddingLen)
            for i in [0:paddingLen]
                paddingBuffer[i] = (i && 1) ? 0x11 : 0xEC
            end
            
            padding.appendBytes(paddingLen, paddingBuffer)
        end

        bitStream.append(padding)
    end

    function mergeBitStream()
        self.convertData()

        bitStream = QrBitStream()

        for item in self._items
            bitStream.append(item.bitStream)
        end

        return bitStream
    end

    function getBitStream()
        bitStream = self.mergeBitStream()
        self.appendPaddingBit(bitStream)
        return bitStream
    end

    function getByteStream()
        bitStream = self.getBitStream()
        return bitStream.toByte()
    end
end

export QrInput
