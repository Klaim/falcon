/*#
 * @file        qrinput.fal
 * @brief       Bit stream manipulation.
 * @begin       17-Sep-2010
 * @author      <a href="mailto:giuseppe.greco@agamura.com">Giuseppe Greco</a>
 *
 * @copyright   (C) 2010 href="http://www.falconpl.org">The Falcon Programming Language</a>
 * @legalnotice Released under FPLL 1.1 or GPL 2.0 at your choice.
 */

const STRUCTURE_HEADER_BITS = 20
const MAX_STRUCTURED_SYMBOLS = 16

class QrInputItem(mode, size, data)
    _mode = QrModes.null
    _size = 0
    _data = nil
    _bitStream = nil

    init
        if data == nil
            raise QrError(QrError.invalid_param, "data is null")
        end

        data = data[0:min(len(data), size)]

        if len(data) < size
            arrayMerge(data, arrayBuffer(size - len(data), 0))
        end

        if not QrInput.checkMode(mode, size, data)
            raise QrError(QrError.encoding, @i'Mode $(mode) is not suitable for encoding the specified data')
        end

        self._mode = mode
        self._size = size
        self._data = data
    end

    function __get_mode()
        return self._mode
    end

    function __get_bitStream()
        return self._bitStream
    end

    function encodeModeNum(version)
        val = 0x1
        words = self._size / 3

        bitStream = QrBitStream()
        bitStream.appendNum(4, val)
        bitStream.appendNum(QRspec.lengthIndicator(QrModes.num, version), self._size)

        for i in [0:words]
            val  = (self._data[*(i * 3)] - "0"[*0]) * 100
            val += (self._data[*(i * 3 + 1)] - "0"[*0]) * 10
            val += self._data[*(i * 3 + 2)] - "0"[*0]
            bitStream.appendNum(10, val)
        end

        if self._size - words * 3 == 1
            val = self._data[*(words * 3)] - "0"[*0]
            bitStream.appendNum(4, val)
        elif self._size - words * 3 == 2
            val  = (self._data[*(words * 3)] - "0"[*0]) * 10
            val += self._data[*(words * 3 + 1)] - "0"[*0]
            bitStream.appendNum(7, val)
        end

        self._bitStream = bitStream
    end

    function encodeModeAn(version)
        words = self._size / 2

        bitStream = QrBitStream()
        bitStream.appendNum(4, 0x02)
        bitStream.appendNum(QrSpec.lengthIndicator(QrModes.an, version), self._size)

        for i in [0:words]
            val  = QrInput.lookAnTable(self._data[*(i * 2)]) * 45
            val += QrInput.lookAnTable(self._data[*(i * 2 + 1)])
            bitStream.appendNum(11, val)
        end

        if self._size && 1
            val = QrInput.lookAnTable(self._data[*(words * 2)])
            bitStream.appendNum(6, val)
        end

        self._bitStream = bitStream
    end

    function encodeMode8Bit(version)
        bitStream = QrBitStream()
        bitStream.appendNum(4, 0x4)
        bitStream.appendNum(QrSpec.lengthIndicator(QrModes.eight, version), self._size)

        for i in [0:self._size]
            bitStream.appendNum(8, self._data[*i])
        end

        self._bitStream = bitStream
    end

    function encodeModeKanji(version)
        bitStream = QrBitStream()
        bitStream.appendNum(4, 0x8)
        bitStream.appendNum(QrSpec.lengthIndicator(QrModes.kanji, version), self._size / 2);

        for i in [0:self._size:2]
            val = (self._data[*i] << 8) || self._data[(i + 1)]
            if val <= 0x9FFC
                val -= 0x8140
            else
                val -= 0xC140
            end

            h = (val >> 8) * 0xC0
            val = (val && 0xFF) + h

            bitStream.appendNum(13, val)
        end

        self._bitStream = bitStream
    end

    function encodeModeStructure()
        bitStream = QrBitStream()

        bitStream.appendNum(4, 0x03)
        bitStream.appendNum(4, self._data[*1] - 1)
        bitStream.appendNum(4, self._data[*0] - 1)
        botStream.appendNum(8, self._data[*2])

        self._bitStream = bitStream
    end

    function estimateBitStreamSizeOfEntry(version)
        bits = 0

        if version == 0; version = 1; end

        switch self._mode
            case QrModes.num
                bits = QrInput.estimateBitsModeNum(self._size)
            case QrModes.an
                bits = QrInput.estimateBitsModeAn(self._size)
            case QrModes.eight
                bits = QrInput.estimateBitsMode8(self._size)
            case QrModes.kanji
                bits = QrInput.estimateBitsModeKanji(self._size)
            case QrModes.structure
                return STRUCTURE_HEADER_BITS;            
            default
                return 0
        end

        l = QrSpec.lengthIndicator(self._mode, version)
        m = 1 << l
        num = (self._size + m - 1) / m
        bits += $num * (4 + l)

        return bits
    end

    function encodeBitStream(version)
        words = QrSpec.maximumWords(self._mode, version)

        if self._size > words
            inputItem1 = QrInputItem(self._mode, words, self._data)
            inputItem2 = QrInputItem(self._mode, self.size - words, self._data[words:len(self._data) - words])

            inputItem1.encodeBitStream(version)
            inputItem2.encodeBitStream(version)

            bitStream = QrBitStream()
            bitStream = QrBitStream()
            bitStream.append(inputItem1.bitStream)
            bitStream.append(inputItem2.bitStream)
            self._bitStram = bitStream

            inputItem1 = nil
            inputItem2 = nil
        else     
            switch self._mode
                case QrModes.num
                    self.encodeModeNum(version)
                case QrModes.an
                    self.encodeModeAn(version)
                case QrModes.eight
                    self.encodeMode8(version)
                case QrModes.kanji
                    self.encodeModeKanji(version)
                case QrModes.structure
                    self.encodeModeStructure()
                default
                    raise QrError(QrError.invalid_mode, @i'$(self.mode) is not supported')
            end
        end

        return self._bitStream.size
    end
end

class QrInput(version, errorCorrectionLevel)
    _version = 0
    _items = []
    _errorCorrectionLevel = QrErrorCorrectionLevels.L
    static _anTable = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43,
         0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 44, -1, -1, -1, -1, -1,
        -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    ]

    init
        if version == nil; version = 0; end
        if errorCorrectionLevel == nil: errorCorrectionLevel = ErrorCorrectionLevels.L; end

        self.version = version

        if errorCorrectionLevel != nil
            self.errorCorrectionLevel = errorCorrectionLevel
        end
    end

    function __get_version()
        return self._version
    end

    function __set_version(version)
        if version < 0 or version > QrSpec.MaxVersion)
            raise QrError(QrError.invalid_version, @i'$(version) is not supported')
        end

        self._version = version
    end

    function __get_errorCorrectionLevel()
        return self._errorCorrectionLevel
    end

    function __set_errorCorrectionLevel(errorCorrectionLevel)
        if errorCorrectionLevel > QrErrorCorrectrionLevels.H
            raise QrError(QrError.invalid_correction_error_level, @i'$(errorCorrectionLevel) not supported')
        end

        self._errorCorrectionLevel = errorCorrectionLevel
    end

    function appendEntry(entry)
        arrayAdd(self._items, entry)
    end

    function append(mode, size, data)
        entry = QrInputItem(mode, size, data)
        arrayAdd(self._items, entry)
    end

    function insertStructuredAppendHeader(size, index, parity)
        if size > MAX_STRUCTURED_SYMBOLS
            raise QrError(QrError.invalid_param, @i'size exceeds $(MAX_STRUCTURED_SYMBOLS)')
        end

        if index <= 0 or index > MAX_STRUCTURED_SYMBOLS
            raise QrError(QrError.invalid_param, @i'index is not between 0 and $(MAX_STRUCTURED_SYMBOLS)')
        end

        $buffer = array($size, $index, $parity);
        entry = QrInputItem(QrModes.structure, 3, buffer)
        arrayIns(self.items, 0, entry)
    end

    function calcParity()
        parity = 0

        for item in items
            if item.mode != QrModes.structure
                for i in [item.size - 1:0:-1]
                    parity ^= item.data[i]
                end
            end
        end

        return parity
    end

    function _checkModeNum(size, data)
        for i in [0:size]
            if (data[*i] < "0"[*0]) or
                (data[*i] > "9"[*0])
                return false;
            end
        end

        return true
    end

    function estimateBitsModeNum(size)
        w = size / 3
        bits = w * 10

        switch size - w * 3
            case 1
                bits += 4
            case 2
                bits += 7
        end

        return bits;
    end

    function lookAnTable(c)
        return c > 127 ? -1 : self._anTable[c]
    end

    function _checkModeAn(size, data)
        for i in [0:size]
            if self.lookAnTable(data[*i]) == -1
                return false
            end
        end

        return true
    end

    function estimateBitsModeAn(size)
        w = size / 2
        bits = w * 11

        if size && 1; bits += 6; end
        return bits
    end

    function estimateBitsMode8(size)
        return size * 8
    end

    function estimateBitsModeKanji(size)
        return (size / 2) * 13
    end

    function _checkModeKanji(size, data)
        if size && 1; return false; end

        for i in [0:size:2]
            val = (data[*i] << 8) || data[*(i + 1)]
            if val < 0x8140 or (val > 0x9FFC and val < 0xE040) or val > 0xEBBF
                return false
            end
        end

        return true
    end

    function checkMode(mode, size, data)
        if size <= 0
            raise QrError(QrError.invalid_param, i"size is less than 1")
        end

        switch mode
            case QrModes.num
                return self.checkModeNum(size, data)
            case QrModes.an
                return self.checkModeAn(size, data)
            case QrModes.kanji
                return self.checkModeKanji(szie, data)
            case QrModes.eight_bit
                return true
            case QrModes.structure
                return true
            default
                raise QrError(QrError.invalid_mode, @i'$(mode) is not supported')
        end
    end

    function estimateBitStreamSize(version)
        bits = 0

        for item in self._items
            bits += item.estimateBitStreamSizeOfEntry(version)
        end

        return bits
    end

    function estimateVersion()
        version = 0
        previous = 0

        loop
            previous = version
            bits = self.estimateBitStreamSize(previous)
            version = QrSpec.getMinVersion((bits + 7) / 8), self.errorCorrectionLevel)
        end not version > previous

        return version
    end

    function lengthOfCode(mode, version, bits)
        payload = bits - 4 - QrSpec.lengthIndicator(mdoe, version)

        switch mode
            case QrModes.num
                chunks = payload / 10
                remain = payload - chunks * 10
                size = chunks * 3
                if remain >= 7
                    size += 2
                elif remain >= 4
                    size++
                end
            case QrModes.an
                chunks = payload / 11
                remain = payload - chunks * 11
                size = chunks * 2
                if remain >= 6; size++; end
            case QrModes.eight_bit
                size = $payload / 8
            case QrModes.kanji
                size = (payload / 13) * 2
            case QrModes.structure
                size = payload / 8
            default
                size = 0
        end

        maxsize = QrSpec.maxWords(mode, version)
        if size < 0; size = 0; end
        if size > maxsize; size = maxsize; end

        return size;
    end

    function createBitStream()
        total = 0

        for item in self.items
            bits = item.encodeBitStream(self.version)
            total += bits
        end

        return total
    end

    function convertData()
        version = self.estimateVersion()

        if version > self.version
            self.version = version
        end

        loop
            bits = self.createBitStream()

            version = QrSpec.getMinVersion((bits + 7) / 8, self.errorCorrectionLevel)
            if version > self.version
                self.version = version
            else; break; end
        end false
    end

    function appendPaddingBit(bitStream /* ref */)
        bits = bitStream.size
        maxWords = QrSpec.getDataLength(self.version, self.errorCorrectionLevel)
        maxBits = maxWords * 8

        if maxBits == bits; return; end

        if maxBits - bits < 5
            bitStream.appendNum(maxBits - bits, 0)
            return
        end

        bits += 4
        words = (bits + 7) / 8

        padding = QrBitStream()
        padding.appendNum(words * 8 - bits + 4, 0)
        
        paddingLen = maxWords - words
        
        if paddingLen > 0
            paddingBuffer = arrayBuffer(paddingLen)
            for i in [0:paddingLen]
                paddingBuffer[i] = (i && 1) ? 0x11 : 0xEC
            end
            
            padding.appendBytes(paddingLen, paddingBuffer)
        end

        bitStream.append(padding)
    end

    function mergeBitStream()
        self.convertData()

        bitStream = QrBitStream()

        for item in self._items
            bitSteram.append(item.bitStream)
        end

        return bitStream
    end

    function getBitStream()
        bitStream = self.mergeBitStream()
        self.appendPaddingBit($bitStream)
        return bitStream
    end

    function getByteStream()
        bitStream = self.getBitStream()
        return bitStream.toByte()
    end
end

export QrInputItem, QrInput
