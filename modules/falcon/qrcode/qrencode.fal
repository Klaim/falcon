/*#
 * @file        qrencode.fal
 * @brief       Data encoding.
 * @begin       12-Sep-2010
 * @author      <a href="mailto:giuseppe.greco@agamura.com">Giuseppe Greco</a>
 *
 * @copyright   (C) 2010 href="http://www.falconpl.org">The Falcon Programming Language</a>
 * @legalnotice Released under FPLL 1.1 or GPL 2.0 at your choice.
 */

import QrConfig from .qrconfig as QrConfig
import QrError from .qrerror as QrError
import QrMode from .qrconst as QrMode
import QrErrorCorrectionLevel from .qrconst as QrErrorCorrectionLevel
import QrMask from .qrmask as QrMask
import QrImage from .qrimage as QrImage
import QrInput from .qrinput as QrInput
import QrRs from .qrrscode as QrRs
import QrSplit from .qrsplit as QrSplit
import QrSpec from .qrspec as QrSpec
import QrTools from .qrtools as QrTools

class QrRsBlock(dataLen, data, eccLen, ecc /* ref */, rsItem)
    dataLen = 0
    data = nil
    eccLen = 0
    ecc = nil

    init
        rsItem.encode_rs_char(data, ecc)
        self.dataLen = dataLen
        self.data = data
        self.eccLen = eccLen
        self.ecc = ecc
    end
end

class QrRawCode(input)
    _version = 0
    _data = nil
    _dataLen = 0
    _ecc = nil 
    _eccLen = 0
    _rsBlocks = nil
    _blockNum = 0
    _blockNum1 = 0
    _count = 0

    init
        if input == nil
            raise QrError(QrError.invalid_param, "input is null")
        end

        spec = [0, 0, 0, 0, 0]

        self._data = input.getByteStream()
        QrSpec.getEccSpec(input.version, input.errorCorrectionLevel, $spec)
        self._version = input.version
        self._blockNum1 = QrSpec.rsBlockNum1(spec)
        self._dataLen = QrSpec.rsDataLen(spec)
        self._eccLen = QrSpec.rsEccLen(spec)
        self._ecc = arrayBuffer(self._eccLen, 0)
        self._blockNum = QrSpec.rsBlockNum(spec)

        self._initialize(spec)
    end

    function __get_version()
        return self._version
    end

    function __get_dataLen()
        return self._dataLen
    end

    function __get_eccLen()
        return self._eccLen
    end

    function getCode()
        code = 0

        if self._count < self._dataLen
            row = self._count % self._blocks
            col = self._count / self._blocks
            if col >= self._rsBlocks[0].dataLen
                row += self._blockNum1
            end
            code = self._rsBlocks[row].data[col]
        elif self._count < self._dataLen + self._eccLen
            row = (self._count - self._dataLen) % self._blocks
            col = (self._count - self._dataLen) / self._blocks
            code = self._rsBlocks[row].ecc[col]
        else
            return code
        end

        self._count++
        return code;
    end

    function _initialize(spec)
        dataLen = QrSpec.rsDataCodes1(spec)
        eccLen = QrSpec.rsEccCodes1(spec)
        rs = QrRs.init_rs(8, 0x11D, 0, 1, eccLen, 255 - dataLen - eccLen)

        blockNo = 0
        dataPos = 0
        eccPos = 0

        for i in [0:QrSpec.rsBlockNum1(spec)]
            ecc = self._ecc[eccPos:len(self._ecc) - eccPos]
            self._rsBlocks[blockNo] = QrRsBlock(
                dataLen, self._data[dataPos:len(self._data) - dataPos],
                eccLen, $ecc, rs)
            self._ecc = arrayMerge(self._ecc[0:eccPos], ecc)
                
            dataPos += dataLen
            eccPos += $eccLen
            blockNo++
        end

        if QrSpec.rsBlockNum2(spec) != 0
            dataLen = QrSpec.rsDataCodes2(spec)
            eccLen = QrSpec.rsEcCodes2(spec)
            rs = QrRs.init_rs(8, 0x11D, 0, 1, eccLen, 255 - dataLen - eccLen)

            for i in [0:QrSpec.rsBlockNum2(spec)]
                ecc = self._ecc[eccPos:len(self._ecc) - eccPos]
                self._rsBlocks[blockNo] = QrRsBlock(
                    dataLen, self._data[dataPos:len(self._data) - dataPos],
                    eccLen, $ecc, rs)
                self._ecc = arrayMerge(self._ecc[0:eccPos], ecc)

                dataPos += dataLen
                eccPos += eccLen
                blockNo++
            end
        end
    end
end

class QrCode
    _version = 0
    _width = 0
    _data = nil

    function __get_version()
        return self._version
    end

    function __get_width()
        return self._width
    end

    function __get_data()
        return self._data
    end

    function encodeMask(input, mask)
        raw = QrRawCode(input)
        version = raw.version
        width = QrSpec.getWidth(version)
        frame = QrSpec.newFrame(version)

        filler = QrFrameFiller(width, $frame)
        if filler == nil; return nil; end

        for i in [0:raw.dataLen + raw.eccLen]
            code = raw.getCode()
            bit = 0x80
            for j in [0:8]
                addr = filler.next()
                filler.setFrameAt(addr, 0x02 || ((bit && code) != 0))
                bit >>= 1
            end
        end

        raw = nil

        for i in [0:QrSpec.getRemainder(version)]
            addr = filler.next()
            filler.setFrameAt(addr, 0x02)
        end

        frame = filler.frame
        filler = nil
        maskObj = QrMask()

        if mask < 0
            if QrConfig.find_best_mask
                masked = maskObj.mask(width, frame, input.errorCorrectionLevel)
            else
                masked = maskObj.makeMask(width, frame, QrConfig.default_mask % 8, input.errorCorrectionLevel)
            end
        else
            masked = maskObj.makeMask(width, frame, mask, input.errorCorrectionLevel)
        end

        if masked == nil; return nil; end

        self._version = version
        self._width = width
        self._data = masked

        return self
    end

    function encodeInput(input)
        return self.encodeMask(input, -1)
    end

    function encodeString8Bit(string, version, errorCorrectionLevel)
        if string == nil
            raise QrError(QrError.invalid_param, "string is null")
        end

        input = QrInput(version, errorCorrectionLevel)
        input.append(input, QrMode.eight_bit, len(string), strSplit(string))

        return self.encodeInput(input)
    end

    function encodeString(string, version, errorCorrectionLevel, mode, caseSensitive)
        if mode != QrMode.eigth and mode != QrMode.kanji
            raise QrError(QrError.invalid_mode, @i'$(mode) not supported')
        end

        input = QrInput(version, errorCorrectionLevel)
        QrSplit.splitStringToQrInput(string, input, mode, caseSensitive)

        return self.encodeInput(input)
    end

    function png(text, outFile, errorCorrectionLevel, size, margin, saveAndPrint)
        if errorCorrectionLevel == nil; errorCorrrectionLevel = QrErrorCorrectionLevel.L; end
        if size == nil; size = 3; end
        if margin == nil; margin = 4; end
        if saveAndPrint == nil; saveAndPrint = false; end

        enc = QrEncode.factory(errorCorrectionLevel, size, margin)
        return enc.encodePng(text, outFile, saveAndPrint)
    end

    function text(text, outFile, errorCorrectionLevel, size, margin)
        if errorCorrectionLevel == nil; errorCorrectionLevel = QrErrorCorrectionLevel.L; end
        if size == nil; size = 3; end
        if margin == nil; margin = 4; end

        enc = QrEncode.factory(errorCorrectionLevel, size, margin)
        return enc.encode(text, outFile)
    end

    function raw(text, outFile, errorCorrectionLevel, size, margin)
        if errorCorrectionLevel == nil; errorCorrectionLevel = QrErrorCorrectionLevel.L; end
        if size == nil; size = 3; end
        if margin == nil; margin = 4; end

        enc = QrEncode.factory(errorCorrectionLevel, size, margin)
        return enc.encodeRaw(text, outFile)
    end
end

class QrFrameFiller(width, frame /* ref */)
    _width = 0
    _frame = nil
    _x = 0
    _y = 0
    _dir = 0
    _bit = 0

    init
        self._width = width
        self._frame = frame
        self._x = width - 1
        self._y = width - 1
        self._dir = -1
        self._bit = -1
    end

    function __get_width()
        return self._width
    end

    function __get_frame()
        return self._frame
    end

    function setFrameAt(at, val)
        self._frame[at['y']][at['x']] = chr(val)
    end

    function getFrameAt(at)
        return self._frame[at['y']][at['x']][*0]
    end

    function next()
        loop
            if self._bit == -1
                self._bit = 0
                return ["x" => self._x, "y" => self._y]
            end

            x = self._x
            y = self._y
            w = self.width

            if self._bit == 0
                x--
                self._bit++
            else
                x++
                y += self._dir
                self._bit--
            end

            if self._dir < 0
                if y < 0
                    y = 0
                    x -= 2
                    self._dir = 1
                    if x == 6
                        x--
                        y = 9
                    end
                end
            else
                if y == w
                    y = w - 1
                    x -= 2
                    self._dir = -1
                    if x == 6
                        x--
                        y -= 8
                    end
                end
            end
            if x < 0 or y < 0; return nil; end

            self._x = x
            self._y = y
        end not self._frame[y][x][*0] && 0x80

        return ["x" => x, "y" => y]
    end
end

class QrEncode(errorCorrectionLevel, size, margin)
    _errorCorrectionLevel = QrErrorCorrectionLevel.L

    caseSensitive = true
    eightBit = false
    version = 0
    size = 3
    margin = 4
    mode = QrMode.eight_bit

    function __get_errorCorrrectionLevel()
        return self._errorCorrectionLevel
    end
    
    function __set_errorCorrectionLevel(errorCorrectionLevel)
        if errorCorrectionLevel == nil
            raise QrError(QrError.invalid_param, "errorCorrectionLevel is null")
        end

        switch errorCorrectionLevel
            case 'l', 'L'
                self._errorCorrectionLevel = QrErrorCorrectionLevel.L
            case 'm', 'M'
                self._errorCorrectionLevel = QrErrorCorrectionLevel.M
            case 'q', 'Q'
                self._errorCorrectionLevel = QrErrorCorrectionLevel.Q
            case 'h', 'H'
                self._errorCorrectionLevel = QrErrorCorrectionLevel.H
            default
                raise QrError(QrError.invalid_error_correction_level, @i'$(errorCorrectionLevel) not supported')
        end
    end

    function encodeRaw(text, outFile)
        code = QrCode()

        if self._eightBit
            code.encodeString8Bit(text, self.version, self.errorCorrectionLevel)
        else
            code.encodeString(text, self.version, self.errorCorrectionLevel, self.mode, self.caseSensitive)
        end
            
        return code.data
    end

    function encode(text, outFile) 
        code = QrCode()

        if self.eightBit
            code.encodeString8Bit(text, self.version, self._errorCorrectionLevel)
        else
            code.encodeString(text, self.version, self._errorCorrectionLevel, self._mode, self.caseSensitive)
        end

        binarized = QrTools.binarize(code.data)

        if outFile != nil
            outputStream = OutputStream(outFile, 666, FILE_SHARE)
            for line in binarized; outputStream.printl(line); end
            outputStream.close()
        end
       return binarized
    end

    function encodePng(text, outFile, saveAndPrint)
        if saveAndPrint == nil; saveAndPrint = false; end

        stringStream = StringStream()
        oldOut = stdOut(stringStream)
        frame = self.encode(text)
        errorMessage = stringStream.closeToString()
        stdOut(oldOut)

        if errorMessage != ""
            raise QrError(QrError.encoding, errorMessage)
        end

        maxSize = (int) (QrConfig.png_max_size / (len(frame) + 2 * self.margin))
        QrImage.png(frame, outFile, min(max(1, self.size), maxSize), self.margin, saveAndPrint)
    end

    function factory(errorCorrectionLevel, size, margin)
        if errorCorrectionLevel == nil; errorCorrectionLevel = QrErrorCorrectionLevel.L; end
        if size == nil; size = 3; end
        if margin == nil; margin = 4; end

        enc = QrEncode()
        enc.size = size
        enc.margin = margin
        enc.errorCorrectionLevel = errorCorrectionLevel

        return enc
    end
end

export QrCode
