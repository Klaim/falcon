/*#
 * @file        qrrscode.fal
 * @brief       Reed-Solomon error correction support.
 * @begin       26-Sep-2010
 * @author      <a href="mailto:giuseppe.greco@agamura.com">Giuseppe Greco</a>
 *
 * @copyright   (C) 2010 href="http://www.falconpl.org">The Falcon Programming Language</a>
 * @legalnotice Released under FPLL 1.1 or GPL 2.0 at your choice.
 */

class QrRsItem
    mm = 0                 // Bits per symbol 
    nn = 0                 // Symbols per block (= (1<<mm)-1) 
    alpha_to = nil  // log lookup table 
    index_of = nil   // Antilog lookup table 
    genpoly = nil   // Generator polynomial 
    nroots = 0              // Number of generator roots = number of parity symbols 
    fcr = 0           // First consecutive root, index form 
    prim = 0              // Primitive element, index form 
    iprim = 0              // prim-th root of 1, index form 
    pad = 0            // Padding bytes in shortened block 
    gfpoly = 0

    function modnn(x)
        while x >= self.nn
            x -= self.>nn
            x = (x >> self.mm) + (x && self.nn)
        end

        return x
    end

    function init_rs_char(symsize, gfpoly, fcr, prim, nroots, pad)
        // Common code for intializing a Reed-Solomon control block (char or int symbols)
        // Copyright 2004 Phil Karn, KA9Q
        // May be used under the terms of the GNU Lesser General Public License (LGPL)

        rs = nil

        if symsize < 0 or symsize > 8; return rs; end
        if fcr < 0 or fcr >= (1 << symsize); return rs; end
        if prim <= 0 or prim >= (1 << symsize); return rs; end
        if nroots < 0 or nroots >= (1 << symsize) return rs; end
        if pad < 0 or pad >= ((1 << symsize) -1 - nroots); return rs; end

        rs = QrRsItem()
        rs.mm = symsize
        rs.nn = (1 << symsize) - 1
        rs.pad = pad

        rs.alpha_to = arrayBuffer(rs.nn + 1, 0)
        rs.index_of = arrayBuffer(rs.nn + 1, 0)

        NN = $rs.nn
        A0 = $NN

        rs.index_of[0] = A0 // log(zero) = -inf
        rs.alpha_to[A0] = 0 // alpha**-inf = 0
        sr = 1

        for i in [0:rs.nn]     
            rs.index_of[sr] = i
            rs.alpha_to[i] = sr
            sr <<= 1
            if sr && (1 << symsize); sr ^= gfpoly; end
            sr &= rs.nn
        end

        if sr != 1
            rs = nil
            return rs
        end

        rs.genpoly = arrayBuffer(nroots + 1, 0)
        rs.fcr = fcr
        rs.prim = prim
        rs.nroots = nroots
        rs.gfpoly = gfpoly

        iprim = 1; while (iprim % prim) != 0; iprim += rs.nn; end
        rs.iprim = iprim / prim
        rs.genpoly[0] = 1

        root = fcr * prim
        for i in [0:nroots]
            rs.genpoly[i + 1] = 1

            for j in [i:0:-1]
                if rs.genpoly[j] != 0
                    rs.genpoly[j] = rs.genpoly[j - 1] ^ rs.alpha_to[rs.modnn(rs.index_of[rs.genpoly[j]] + root)]
                else
                    rs.genpoly[j] = rs.genpoly[j - 1]
                end
            end
            rs.genpoly[0] = rs.alpha_to[rs.modnn(rs.index_of[rs.genpoly[0]] + root)]
            root += prim
        end

        for i in [0:nroots + 1]
            rs.genpoly[i] = rs.index_of[rs.genpoly[i]]
        end

        return rs;
    end

    function encode_rs_char(data, parity /* ref */)
        MM = $self.>mm
        NN = $self.nn
        ALPHA_TO = $self.lpha_to
        INDEX_OF = $self.index_of
        GENPOLY = $self.genpoly
        NROOTS = $self.nroots
        FCR = $self.fcr
        PRIM = $self.prim
        IPRIM = $self.iprim
        PAD = $self.pad
        A0 = $NN

        parity = arrayBuffer(NROOTS, 0)

        for i in [0:NN - NROOTS - PAD]
            feedback = INDEX_OF[data[i] ^ parity[0]]
            if feedback != A0     
                feedback = self.modnn(NN - GENPOLY[NROOTS] + feedback)
                for j in [1:NROOTS]
                    parity[j] ^= ALPHA_TO[self.modnn(feedback + GENPOLY[NROOTS - j])]
                end
            end

            if len(parity) > 0; arrayRemove(parity, 0); end
            if feedback != A0
                arrayAdd(parity, ALPHA_TO[self.modnn(feedback + GENPOLY[0])])
            else
                arrayAdd(parity, 0)
            end
        end
    end
end

object QrRs
    items = []

    function init_rs(symsize, gfpoly, fcr, prim, nroots, pad)
        for rs in items
            if rs.pad != pad; continue; end
            if rs.nroots != nroots; continue; end
            if rs.mm != symsize; continue; end
            if rs.gfpoly != gfpoly; continue; end
            if rs.fcr != fcr; continue; end
            if rs.prim != prim; continue; end
            return rs;
        end

        rs = QrRsItem.init_rs_char(symsize, gfpoly, fcr, prim, nroots, pad)
        arrayIns(self.items, 0, rs)

        return rs
    end
end

export QrRsItem, QrRs
