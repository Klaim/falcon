/*#
 * @file        qrsplit.fal
 * @brief       Input splitting.
 * @begin       07-Oct-2010
 * @author      <a href="mailto:giuseppe.greco@agamura.com">Giuseppe Greco</a>
 *
 * @copyright   (C) 2010 href="http://www.falconpl.org">The Falcon Programming Language</a>
 * @legalnotice Released under FPLL 1.1 or GPL 2.0 at your choice.
 */

import QrError from .qrerror as QrError
import QrInput from .qrinput as QrInput
import QrMode from .qrconst as QrMode
import QrSpec from .qrspec as QrSpec

class QrSplit(data, input, mode)
    _data = nil
    _input = nil
    _mode = nil

    init
        self._data = data
        self._input = input
        self._mode = mode
    end

    function isDigitAt(str, pos)
        if pos >= len(str); return false; end
        return str[*pos] >= '0'[*0] and str[*pos] <= '9'[*0]
    end

    function isAlNumAt(str, pos)
        if pos >= len(str); return false; end
        return QrInput.lookAnTable(str[*pos]) >= 0
    end

    function identifyMode(pos)
        if pos >= len(self._data); return QrMode.null; end

        if self.isDigitAt(self._data, pos)
            return QrMode.num;
        elif self.isAlNumAt(self._data, pos)
            return QrMode.an;
        elif self._mode == QrMode.kanji                     
            word = self._data[*pos]
            //if (word >= 0x1000 and word <= 0x9FFC) or (word >= 0xE040 and word <= 0xEBBF)
            // Our kanjis are in the UNICODE range, not in shift-jis
            if word >= 0x3040 and word <= 0x4db0
               return QrMode.kanji
            end
        end
        
        return QrMode.eight_bit
    end

    function _eatNum()
        ln = QrSpec.lengthIndicator(QrMode.num, self._input.version)

        run = 0
        while self.isDigitAt(self._data, run); run++; end

        mode = self.identifyMode(run)

        if mode == QrMode.eight_bit
            dif = QrInput.estimateBitsModeNum(run) + 4 + ln \
                + QrInput.estimateBitsMode8(1) \
                - QrInput.estimateBitsMode8(run + 1)
            if dif > 0; return self._eat8(); end
        end

        if mode == QrMode.an
            dif = QrInput.estimateBitsModeNum(run) + 4 + ln \
                + QrInput.estimateBitsModeAn(1) \
                - QrInput.estimateBitsModeAn(run + 1)
            if dif > 0; return self._eatAn(); end
        end

        self._input.append(QrMode.num, run, strSplit(self._data))
        return run;
    end

    function _eatAn()
        la = QrSpec.lengthIndicator(QrMode.an, self._input.version)
        ln = QrSpec.lengthIndicator(QrMode.num, self._input.version)
        run = 0

        while self.isAlNumAt(self._data, run)
            if self.isDigitAt(self._data, run)
                q = run
                while self.isDigitAt(self._data, q); q++; end

                dif = QrInput.estimateBitsModeAn(run) \
                    + QrInput.estimateBitsModeNum(q - run) + 4 + ln \
                    - QrInput.estimateBitsModeAn(q)

                if dif < 0
                    break
                else
                    run = q
                end
            else
                run++
            end
        end

        if not self.isAlNumAt(self._data, run)
            dif = QrInput.estimateBitsModeAn(run) + 4 + la \
                + QrInput.estimateBitsMode8(1) \
                - QrInput.estimateBitsMode8(run + 1)
            if dif > 0; return self._eat8(); end
        end

        self._input.append(QrMode.an, run, strSplit(self._data))
        return run
    end

    function _eatKanji()
        run = 0
        while self.identifyMode(run) == QrMode.kanji; run += 2; end
        
        self._input.append(QrMode.kanji, run, strSplit(self._data))
        return run
    end

    function _eat8()
        la = QrSpec.lengthIndicator(QrMode.an, self._input.version)
        ln = QrSpec.lengthIndicator(QrMode.num, self._input.version)

        run = 1
        dataLen = len(self._data)
        while run < dataLen
            mode = self.identifyMode(run)
            if mode == QrMode.kanji; break; end
            if mode == QrMode.num
                q = run
                while self.isDigitAt(self._data, q); q++; end
                dif = QrInput.estimateBitsMode8(run) \
                    + QrInput.estimateBitsModeNum(q - run) + 4 + ln \
                    - QrInput.estimateBitsMode8(q)
                if dif < 0
                    break
                else
                    run = q
                end
            elif mode == QrMode.an
                q = run
                while self.isAlNumAt(self._data, q); q++; end
                dif = QrInput.estimateBitsMode8(run) \
                    + QrInput.estimateBitsModeAn(q - run) + 4 + la \
                    - QrInput.estimateBitsMode8(q)
                if dif < 0
                    break
                else
                    run = q
                end
            else
                run++
            end
        end

        self._input.append(QrMode.eight_bit, run, strSplit(self._data))
        return run
    end

    function splitString()
        while len(self._data) > 0
            if self._data == ''; break; end

            mode = self.identifyMode(0)

            if mode == QrMode.num
                length = self._eatNum()
            elif mode == QrMode.an
                length = self._eatAn()
            elif mode == QrMode.kanji
                if self._mode == QrMode.kanji
                    length = self._eatKanji()
                else
                    length = self._eat8()
                end
            else
                length = self._eat8()
            end

            if length > 0; self._data = strBack(self._data, len(self._data) - length); end
        end
    end

    function toUpper()
        stringLen = len(self._data)
        p = 0
        while p < stringLen
            mode = self.identifyMode(strBack(self._data, stringLen - p), self._mode)
            if mode == QrMode.kanji
                p += 2
            else
                if self._data[*p] >= 'a'[*0] and self._data[*p] <= 'z'[*0]
                    self._data[p] = chr(self._data[*p] - 32)
                end
                p++
            end
        end

        return self._data
    end

    function splitStringToInput(string, input, modeHint, caseSensitive)
        if caseSensitive == nil; caseSensitive = true; end
        if string == nil or string == "\x0" or string == ""
            raise QrError(QrError.invalid_param, i'string is empty')
        end

        split = QrSplit(string, input, modeHint)

        if not caseSensitive; split.toUpper(); end
        split.splitString()
    end
end

export QrSplit
