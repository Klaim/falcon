/*#
 * @file        qrsplit.fal
 * @brief       Input splitting.
 * @begin       07-Oct-2010
 * @author      <a href="mailto:giuseppe.greco@agamura.com">Giuseppe Greco</a>
 *
 * @copyright   (C) 2010 href="http://www.falconpl.org">The Falcon Programming Language</a>
 * @legalnotice Released under FPLL 1.1 or GPL 2.0 at your choice.
 */

import QrError from .qrerror as QrError
import QrInput from .qrinput as QrInput
import QrMode from .qrconst as QrMode
import QrSpec from .qrspec as QrSpec

class QrSplit(dataStr, input, modeHint)
    dataStr = nil
    input = nil
    modeHint = nil

    init
        self.dataStr = dataStr
        self.input = input
        self.modeHint = modeHint
    end

    function isDigitAt(str, pos)
        if pos >= len(str); return false; end
        return (str[*pos]) >= '0'[*0] and str[*pos] <= '9'[*0]
    end

    function isAlNumAt(str, pos)
        if pos >= len(str); return false; end
        return QrInput.lookAnTable(str[*pos]) >= 0
    end

    function identifyMode(pos)
        if pos >= len(self.dataStr); return QrMode.null; end

        c = self.dataStr[pos]

        if self.isDigitAt(self.dataStr, pos)
            return QrMode.num;
        elif self.isAlNumAt(self.dataStr, pos)
            return QrMode.an;
        elif self.modeHint == QrMode.kanji
            if pos + 1 < len(self.dataStr)
                d = self.dataStr[pos + 1]
                word = (c[*0] << 8) || d[*0]
                if (word >= 0x8140 and word <= 0x9FFC) or (word >= 0xE040 and word <= 0xEBBF)
                    return QrMode.kanji
                end
            end
        end

        return QrMode.eight_bit
    end

    function eatNum()
        ln = QrSpec.lengthIndicator(QrMode.num, self.input.version)

        p = 0
        while self.isDigitAt(self.dataStr, p); p++; end

        mode = self.identifyMode(p)

        if mode == QrMode.eight_bit
            dif = QrInput.estimateBitsModeNum(p) + 4 + ln \
                + QrInput.estimateBitsMode8(1) \
                - QrInput.estimateBitsMode8(p + 1)
            if dif > 0; return self.eat8(); end
        end

        if mode == QrMode.an
            dif = QrInput.estimateBitsModeNum(p) + 4 + ln \
                + QrInput.estimateBitsModeAn(1) \
                - QrInput.estimateBitsModeAn(p + 1)
            if dif > 0; return self.eatAn(); end
        end

        self.input.append(QrMode.num, p, strSplit(self.dataStr))
        return p;
    end

    function eatAn()
        la = QrSpec.lengthIndicator(QrMode.an, self.input.version)
        ln = QrSpec.lengthIndicator(QrMode.num, self.input.version)

        p = 0

        while self.isAlNumAt(self.dataStr, p)
            if self.isDigitAt(self.dataStr, p)
                q = p
                while self.isDigitAt(self.dataStr, q); q++; end

                dif = QrInput.estimateBitsModeAn(p) \
                    + QrInput.estimateBitsModeNum(q - p) + 4 + ln \
                    - QrInput.estimateBitsModeAn(q)

                if dif < 0
                    break
                else
                    p = q
                end
            else
                p++
            end
        end

        if not self.isAlNumAt(self.dataStr, p)
            dif = QrInput.estimateBitsModeAn(p) + 4 + la \
                + QrInput.estimateBitsMode8(1) \
                - QrInput.estimateBitsMode8(p + 1)
            if dif > 0; return self.eat8(); end
        end

        self.input.append(QrMode.an, p, strSplit(self.dataStr))
        return p
    end

    function eatKanji()
        p = 0
        while self.identifyMode(p) == QrMode.kanji; p += 2; end
        
        self.input.append(QrMode.kanji, p, strSplit(self.dataStr))
        return p
    end

    function eat8()
        la = QrSpec.lengthIndicator(QrMode.an, self.input.version)
        ln = QrSpec.lengthIndicator(QrMode.num, self.input.version)

        p = 1
        dataStrLen = len(self.dataStr)
        while p < dataStrLen
            mode = self.identifyMode(p)
            if mode == QrMode.kanji; break; end
            if mode == QrMode.num
                q = p
                while self.isDigitAt(self.dataStr, q); q++; end
                dif = QrInput.estimateBitsMode8(p) \
                    + QrInput.estimateBitsModeNum(q - p) + 4 + ln \
                    - QrInput.estimateBitsMode8(q)
                if dif < 0
                    break
                else
                    p = q
                end
            elif mode == QrMode.an
                q = p
                while self.isAlNumAt(self.dataStr, q); q++; end
                dif = QrInput.estimateBitsMode8(p) \
                    + QrInput.estimateBitsModeAn(q - p) + 4 + la \
                    - QrInput.estimateBitsMode8(q)
                if dif < 0
                    break
                else
                    p = q
                end
            else
                p++
            end
        end

        self.input.append(QrMode.eight_bit, p, strSplit(self.dataStr))
        return p
    end

    function splitString()
        while len(self.dataStr) > 0
            if self.dataStr == ''; return 0; end

            mode = self.identifyMode(0)

            if mode == QrMode.num
                length = self.eatNum()
            elif mode == QrMode.an
                length = self.eatAn()
            elif mode == QrMode.kanji
                if self.modeHint == QrMode.kanji
                    length = self.eatKanji()
                else
                    length = self.eat8()
                end
            else
                length = self.eat8()
            end

            if length > 0; self.dataStr = strBack(self.dataStr, len(self.dataStr) - length); end
        end
    end

    function toUpper()
        stringLen = len(self.dataStr)
        p = 0
        while p < stringLen
            mode = self.identifyMode(strBack(self.dataStr, stringLen - p), self.modeHint)
            if mode == QrMode.kanji
                p += 2
            else
                if self.dataStr[*p] >= 'a'[*0] and self.dataStr[*p] <= 'z'[*0]
                    self.dataStr[p] = chr(self.dataStr[*p] - 32)
                end
                p++
            end
        end

        return self.dataStr
    end

    function splitStringToInput(string, input, modeHint, caseSensitive)
        if caseSensitive == nil; caseSensitive = true; end
        if string == nil or string == "\x0" or string == ""
            raise QrError(QrError.invalid_param, i'string is empty')
        end

        split = QrSplit(string, input, modeHint)

        if not caseSensitive; split.toUpper(); end
        return split.splitString()
    end
end
export QrSplit
