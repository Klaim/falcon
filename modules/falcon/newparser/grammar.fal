/*
   FALCON - Grammar Parser

   FILE: grammar.fal

   Generic parser.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Thu, 19 Aug 2010 01:34:20 +0200

   -------------------------------------------------------------------
   (C) Copyright 2014: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

import from vfs

/*#
   @module grammar
   @brief Advanced context-free grammar definition parser.
   
   This module parses a generic EBNF-like grammar definition 
   (provided in a generic stream) and generates a structured
   representation of that grammar, which can then be used to
   parse an expression writte under the rules of the given 
   grammar.
   
   @note While the parsed grammar is functionally equivalent to
   a EBNF grammar, some conventions in are different for practical 
   purposes. In particular, the usage of "[x]" and "{x}" to indicate 
   repetition in the EBNF convention makes extremely difficult to 
   declare inline Falcon code as the rule action.
   
   @section overview Overview
   
   The formal context-free grammar definition recognized by this
   parser has several distinguishing features that set it apart from
   basic LL, LR and LARL commonly known grammars.
   
   - The grammar definition can be divided in sections, called "states", 
   which can be insolated from the rest of the grammar definition or include
   one or more states. A state transition can happen when a rule is recognized.
   Special tokens in the grammar are provided to define state transitions.
   
   - Each token (terminal and non-terminal) can be associate with a symbolic
   name, that will be used to identify that portion of data while processing
   the rule.
   
   - Each grammar rule can be associated with a portion of Falcon code that
      will receive the data being parsed.
      
   - Terminal tokens can be either strings or Falcon regular expressions 
     (r'' strings).
   
   - Each state can have associated Falcon code sections, 
     called preamble and postamble,
     that will be executed as the transition into and out from that state 
     happens.
   
   @section fdef Formal Definition
   
   Here follows a formal definition of the grammar known by this parser:
   
   @code
   GRAMMAR ::= INIT-CODE? MAIN-STATE STATE.
   
   INIT-CODE ::= CODE.
   
   MAIN-STATE ::= MAIN-STATE-DECLARATION? STATE-BODY.
   
   MAIN-STATE-DECLARATION ::= '[' 'main' ']'.
   
   STATE ::= STATE-DECLARATION STATE-BODY.      
   
   STATE-DECLARATION::= '[' NAME INCLUDES? ']' <end of line>.
   
   STATE-BODY::= PREAMBLE? POSTAMBLE? *RULE.
   
   PREAMBLE ::= '#' CODE.
   
   POSTAMBLE ::= '=>' CODE.
   
   CODE ::= '{' <any Falcon code slice> '}'.
   
   NAME ::= <any valid Falcon symbolic name>.
   
   INCLUDES::= ':' NAME+.
   
   RULE ::= NAME '::=' RULE-BODY '.' .
   
   RULE-BODY::= ALTERNATIVE NEXT-ALTERNATIVE*.
   
   ALTERNATIVE ::= TOKEN* CODE? TRANSITION?.
   
   NEXT-ALTERNATIVE ::= '|' ALTERNATIVE.
   
   TOKEN ::=  (NAME | TERMINAL | PREDEFINED | SUB-ALTERNATIVE) REPETITION? TOKEN-SPEC?.
            
   SUB-ALTERNATIVE ::= '(' TOKEN+ ')'.
   
   PREDEFINED ::= 'eof' | 'error'.
   
   REPETITION ::= '?' | '+' | '*'.
   
   TRANSITION ::= '=>' NAME | POP-STATE-DIRECTIVE.
   
   POP-STATE-DIRECTIVE ::= +'#'.
   
   TOKEN-SPEC ::= ':' NAME.
   
   TERMINAL::= STRING | REGEX.
   
   STRING ::= "'" <any valid falcon string> "'"  | '"' <any valid falcon string> '"'.
   
   REGEX ::= <any valid Falcon regular expression>.
   @endcode
   
   Legend:
   - "name ::= definition .": The given "name" is defined as indicated up to the '.'
   - "A | B" ::= Indicates an alternative definition, A or B.
   - "( A | B )" ::= Indicates an alternative element A or B inside a definition.
   - "*": Previous token can be present, and repeated multiple times.
   - "+": Previous token must be present, and can be repeated multiple times.
   - "?": Provious token can be preset at most one time.
   - "<...>": informal description of an element.
   
   @subsection remarks Remarks
   
   - The strings parsed by this parser are always interpreted as Falcon double-quoted
     strings, even if initiated with a single quote.
   - It is possible to insert out-of-grammar comments in C-like comment blocks \/* ... *\/
   - The parser is actually flexible in recognizing preamble and postamble, and the three
     elements of a rule alternative (tokens, transition and code), 
     that can appear in any order.
   - Before the tree structure created out of the grammar definition is returned to the
     caller, the Falcon code slices and regular expressions will be compiled, and thus,
     checked for formal errors; but they won't be pre-executed, so it won't be possible
     to spot potential run-time errors.
   - Prior returning the structure, the parser will also check for the correctness of
     formal definitions: undeclared non-terminal tokens, undeclared included states and
     recursive state inclusion will be reported as error, and that will cause the the
     parsing process to fail.
   - Multiple rules starting with the same non-terminal name are considered alternatives;
     "A ::= <alt1> | <alt2> ."  and "A ::= <alt1>. A ::= <alt2>." are semantically
     equivalent.     
   - The special predefined terminal token 'eof' recognizes the end of the input data.
   - The special predefined terminal token 'error' matches the rest of the rule
     if and only if it couldn't be matched otherwise.
    
   
   @subsection idef Informal definition.
   
      The parser recognizes texts generally used to describe context-free grammars,
      with the addition of the "state" concept and with the insertion of Falcon code
      that can handle a recognized grammar. Also, a name can be given to any token,
      even terminal tokens, that are then passed to the Falcon code in a variable
      having the given name.
      
      A parser state can be useful to reduce the scope and complexity of the analisys 
      of a certain portion of text, and thus, the complexity of its definition. The ability
      to include previously declared states (or actually, also states declared afterward)
      allows for better modularity and reusability of the definitions, and the code that
      manages them.
      
      Each state actually generates a different parser, and state transition allows to
      dynamically change the parser that is in charge of recognizing a certain porion of
      input text.
      
   @section code Inline code slices.
   
      All the code slices provided (preamble and postamble of states, and code slices handling
      rule alternatives) will be seen by Falcon as stand-alone anonymous functions. 
      
      While this parser is not in charge of running any code slice, it is necessary to
      explain how the code is meant to work here so that the parser users know the conventions
      that shall be adopted by the final result grammar parsers.
      
      First, if present, the preamble of the main status is executed; its return value
      is then assumed to be the context that will be passed to all the other code slices
      with the name 'CTX'. If the preamble is not present, or doesn't return a non-nil object,
      the final parser shall generate an empty prototype object ("p{}"), that will then be
      seen as CTX by all the other code slices.
      
      Code slices handling rule alternatives will receive CTX as first parameter, and the
      entities that are being given a name as further parameters. Terminal entries (regex and
      tokens, including pre-defined tokens) will be seen as string. The type of the other
      entries will be whatever the result of previous operations has assigned to them.
      
      The return value of the functions (or the expression values of single-statement 
      expressions) will be assigned as the value of the defined token.
      
      For example:
      
      @code
         SUM ::= r"[0-9]+":op1 "+" r"[0-9]+":op2 { int(op1) + int(op2) }.
      @endcode
      
      This rule will put the sum of op1 and op2 in the value of the token SUM. So,
      SUM will be aleady a number in the next alternative:
      
      @code
         SUM ::= r"[0-9]+":op1 "+" SUM:sum { int(op1) + sum }.        
      @endcode
      
      If an alternative doesn't declare a code, the declared token value is synthesized
      by applying the Falcon '+' operator to all the token values (terminal and non-terminal)
      comprised in the alternative. This might generate a runtime error in case the types
      of the values assigned to the tokens is not compatible.
      
      For instance, the following rule set:
      
      @code
         FULLTEXT ::= *PART.
         PART ::= WHITESPACE | WORD.
         WHITESPACE ::= +" " {" "}.
         WORD ::= r"[^ ]+".
      @endcode
      
      will have the effect of putting in FULLTEXT a version of the original text stripped
      of multiple spaces between words: the FULLTEXT rule will autmatically apply the Falcon
      "+" operator to all the PART tokens it receives.
      
      Repeated tokens (tokens prefixed with '*', '+' and '?') shall be passed to the code
      as an array. For example, the following rule:
      
      @code
         SORTED::= *WORD:word_array { word_array.sort(); return word_array }.
      @endcode
      
      Will assign an array of sorted words to the SORTED token. 
      
      @note Tokens repeated with the '?' repetition indicator will be seen in code slices
            as arrays with 0 or 1 elements.
            
      Of course, if the value associated with the repeated token is originally an array,
      it will be incapsulated again an another array, becoming an array-of-array.
      
   @section struct Target structure
   
      Once the parsing is complete, the result is an entity of type @a Gramamr,
      defined in this module.
            
      The relational structure of the generated entity is as follows:
      
      @code
      Grammar
        + states [GrammarState]
                  |- name
                  |- preamble/postamble
                  + includes [GrammarState]
                  + top NonTerminal
                         + alts [NTAlt]
                                 | line
                                 | code
                                 | transition
                                 + sequence [Token]
                                             | line
                                             | name
                                             | repeat
                                             | type
                                             + content (NonTerminal|String)
      @endcode
      
      The grammar has a list of @a GrammarState entities. Each one represents a
      grammar state, that can include other GrammarState entities (by direct reference)
      and has a top rule of type @a NonTerminal. The @a NonTerminal entity is
      constituted by one or more @a NTAlt (alternatives), each being basically a
      sequence of @a Token entities. Depending on their type, tokens can be terminal,
      in which case their content is a string, or a regular expression, or can be
      non-terminal, in which case their content is child @a NonTerminal entity.

      This tree structure can be used by the final parser to generate a grammar parsing
      table, inspected, modified, rendered back to a grammar textual definition document
      and eventually serialized.
*/

/*# @beginmodule grammar */


/*#
   @brief Single token (entry in a NonTerminal entry sequence)
   @param type tString, tRE, tNT  (tPredef for predefined terminals)
   @param content either a string, a re or a NonTerminal
   @param name non-terminal name, if this is a non-terminal
   @param repeat 0/nil - single, -1: asterisk, -2: plus, -3: question mark
   @param line Where the token was defined.
   
   The content is determined by the type:
   - tString or tPredef: @b content is a String
   - tRE: @b content is a RE
   - tNT: @b Content is an instance of NonTerminal
   
   @note The token name can be nil if the token content is an anonymous
   NonTerminal.
*/
class Token(type, content, name, line)
   static tString = 0
   static tRE = 1
   static tNT = 2
   static tPredef = 3
   // sub alternative
   static tSubAlt = 4
   
   static tSingle = 0
   static tAsterisk = -1
   static tPlus = -2
   static tQMark = -3
   
   type = type
   content = content
   name = name
   pname = nil
   repeat = 0
   resolved = false
   line = line ? line: 0
   
   function dump(output)
      tok = self
      
      if tok.type == Token.tString
         output.write( '"' + tok.content.escape() + '"' )
      elif tok.type == Token.tRE
         output.write( tok.content.toString() )
      elif tok.name == nil
         // anonymous non-terminal token
         output.write( "( " )
         tok.content.dump(output, true)
         output.write( " )" )         
      else
         output.write( tok.name )
      end
      
      if tok.repeat == Token.tAsterisk
         output.write( "*" )
      elif tok.repeat == Token.tPlus
         output.write( "+" )
      elif tok.repeat == Token.tQMark
         output.write( "?" )
      end
      
      if tok.pname
         output.write( ":" + tok.pname )
      end
   end
   
end


/*#
@brief Single Entry of a Non Terminal specification.

Each alternative definition will have its own NTDef
   - line: Line at which this alternative is declared
*/
class NTAlt(line)   
   // line where the definition is declared
   line = line ? line: 0
   
   // sequence of Tokens
   sequence = []
   
   // raw text code
   code = nil
   
   // compiled code
   compiled = nil
   
   // transition to a different state
   transition = nil
   
   // or... pop to different states
   transpop = 0
   
   function dump( output )
   
      alt = self
      
      for tok in alt.sequence
         tok.dump(output)
         formiddle: output.write( " " )
      end
      
      code = alt.code
      if code
         output.write( "  {"+ code + "}" )
      end
      
      if alt.transition
         output.write( " => " + alt.transition.name )
      elif alt.transpop
         output.write( " => " + ("#" * alt.transpop) )
      end
   end
end


/*#
   @b Non terminal entry in a gramamr definition.
   
   A nonterminal is a colleciton of 0 or more alternatives,
   each being a @a NTAlt, which fully defines a certain non terminal
   pattern.
   
   @note A NonTerminal can be anonymous if it's generated out of
   a locally defined alternative (a parentezised alternative within a sequence).
   
*/
class NonTerminal(name)
   name = name
   // list of zero or more NTAlt
   alts = []
   

   function dump(output, singleLine)
      entry = self
      
      // manage inline anonymous non terminals
      if entry.name
         output.write( entry.name + " ::= " )
      end
      
      for alt in entry.alts         
         alt.dump(output)
         
         forfirst
            if not singleLine and entry.alts.len > 1
               output.write( "\n     " )
            end
         end
         
         formiddle
            if not singleLine: output.write("\n  ")
            output.write( " | " )
         end
      end
      
      if entry.name: output.write( "." )
   end
end


/*#
   @brief State of a multi-state grammar definition.
*/
class GrammarState(name, line)
   name = name
   
   // master grammar states
   includes = []

   // "ID" => [NonTerminal]
   entries = [=>]
   
   // NonTerminal at top of the entry tree
   top = nil
   
   // "ID" => [NTAlt] -- still unresolved entries.
   unresolved = [=>]
   
   // line where the state is declared
   line = line
   
   //# list of lexer tokens known to the state
   tokens = nil
   
   //# Code to be exucted when entering this state
   preamble = nil
   
   preamble_compiled = nil
   
   //# Code to be executed when leaving this state
   postamble = nil
   
   preamble_compiled = nil
   
   // Reverse rendering for the state grammar
   function dump( output )
      if self.includes
         output.write( @"[${state.name}:" )
         for state in self.includes
            output.write( state.name )
            formiddle: output.write( "," )
         end
         output.write( "]\n" )
      else
         output.write( @"[$(name)]\n" )
      end
      
      output.write("\n") /* white line */
      
      if self.preamble
         output.write( "# {" )
         output.write( self.preamble )
         output.write( "}\n" )
      end
      
      if self.postamble
         output.write( "=> {" )
         output.write( self.postamble )
         output.write( "}\n" )
      end      
         
      // for convention, write the root on top
      root = self.top
      if root
         root.dump(output)
         output.write("\n") /* white line */
      else
         output.write("/* This state has no root */\n")
      end
      
      for name, entry in self.entries
         if entry != root
            entry.dump( output )
            output.write("\n") /* white line */
         end
      end      
   end

end


/*# 
   @brief Result of a succesful parsing.   
*/
class Grammar
   //# Map of grammar states.
   states = [=>]
   
   //# Code to be executed at initialization
   initcode = nil
   
   initcode_compiled = nil
   
   //# Reverse rendering for the state grammar
   function dump( output )
   
      if self.initcode
         output.write( "{" )
         output.write( self.initcode )
         output.write( "}\n" )
      end
      
      for name, state in self.states         
         state.dump( output )
         > /* White line */
      end
   end
   
end


/*#
   @brief Parser for formal context-free grammar definitions.
*/
class GrammarParser
   
   // grammar state being currently parsed.
   _cgs = nil
   
   // grammar being currently parsed
   _grammar = nil
   
   // internal state.
   _state = nil
   
   // forming nested non terminal stacks.
   _NTStack = nil
   
   // current line
   curLine = 0
   
   // List of predefined tokens
   predefined = .[
      "eof"       // End of file
      "error"     // matches everything in case of error.
   ]
   
   /*#
      @brief Error handler function
      
      This property is assinged a function that receives the
      notification of an error in the grammar. On error, 
      it is invoked with the following parameters:
         - The line where the error happened.
         - A textual description of the error that happened.
         
      The default function writes the error notification to the process
      standard output. It can be overridden to change its behavior.
   */
   handleError = function( line, reason )
         > @"ERROR ($line): $reason"
      end
   
   //# Count of errors in last parsing
   errors = 0
   
   mt = nil

   /*#
      @brief Parses a Falcon Parser Definition (FPD).
      @param source A TextReader or String from which to read the definition
      
      On success, the parser is configured and ready to parse one or
      more input sources.
   */
   function parse( source, grammar )
      
      if not grammar: grammar = Grammar()         
      self._grammar = grammar
      
      // we'll use the parameter checking of our multitokenizer
      try
         mt = MultiTokenizer(source)
      catch ParamError 
         raise ParamError( 1001, "Invalid paramters", "Need a string or TextReader" )
      end
      
      commands = .["::=" "/*" "r\'" "r\"" "R'" "R\"" ":" "." "{" "}" 
                   '"' "'" "*" "+" "?" "|" "[" "]"
                   "(" ")"
                   "=>" "#"
                   ]
      whiteSpaces = .[" " "\n" "\r" "\t"]
      call( mt.add, commands )
      call( mt.add, whiteSpaces )
      mt.giveTokens = true

      syms = .["start" "dfn" "quote" "defBody"
               "defPreamble" "defPostamble"
               "code" "Rafter" "escape"
               "defName1" "defName2"
               "codeQuote" "codeEsc"
               "comment"
               "defState" "defPState" "defPState2" "postState"
               "transition"
               ]
      call( makeEnum, map({[v] "S." + v}, syms ) )
      self._resetParsing()
      
      self.mt = mt

      parCount = 0
      code = m""
      
      // cached token (name)
      currentToken = nil
      // cached NTAlt we're working on
      currentAlt = nil
      // cached NonTerminal at top of the NTStack.
      currentNT = nil
      
      // variables controlling quotes
      Rignore = false
      Rquote = false
      quoteType = false
      quoteText = nil
      oldState = nil
      stateName = nil
      
      codeStage = 0
      // level of parenthesis inside an alternative.
      parLevel = 0
      
      // used to reiterate the same token in different states
      take = true
      
      while mt.hasNext

         // used to reiterate the same token in different states
         if take
            tok = mt.next()
         else
            take = true
         end
         
         // manage comments
         //  -- notice that in code the lexer changes state, 
         //  -- so we can't parse the comments in codeblocks.
         if tok == "/*"
            oldState = self._state
            self._state = ~S..comment
            mt.clearTokens()
            mt.add("*/", "\n")
         end
         
         // count lines and discard blanks
         if tok == "\n" or tok == " " or tok == "\r" or tok == "\t"
            // but if we are after a regular expression, change state
            if self._state == ~S..Rafter
               // time to create the RE
               self.commitRE( quoteText, currentAlt, Rignore ?"i":"" )
               self.changeState( ~S..defBody )
            elif self._state == ~S..code
               code += tok
            elif self._state == ~S..quote
               quoteText += tok
            end

            // also, count line if necessary
            if tok == "\n"
               // we wait a newline after a state declararion
               if self._state == ~S..postState
                  // return to initial state
                  self.changeState(~S..start)
               end
               
               self.curLine ++
            end
            
            continue         
         // ignore white spaces and token separators.
         elif tok == "" 
            continue
         end
         
         switch self._state
         
            case ~S..start
               if tok == '{'
                  if grammar.initcode
                     self.error(self.curLine, "Global initialization code already defined" )
                  end
                  // anyhow take the code as a preamble
                  code = m""
                  codeStage = 0
                  self.enterCode(~S..code)
                  
               elif tok == "["
                  self.changeState( ~S..defState, tok )                  
               elif tok == "#"
                  self.changeState( ~S..defPreamble, tok )
               elif tok == "=>"
                  self.changeState( ~S..defPostamble, tok)
               elif tok in commands
                  self.xerror(self.curLine, "invalid declaration")
               else               
                  self.changeState( ~S..dfn, tok )
                  currentToken = tok
               end
               
            
            case ~S..defPreamble, ~S..defPostamble
               if tok == '{'
                  if self._state == ~S..defPreamble
                     data = self._cgs.preamble
                     word = "preamble"
                     codeStage = 1
                  else
                     data = self._cgs.postamble
                     word = "postamble"
                     codeStage = 2
                  end
                  
                  if data
                     self.error(self.curLine, @"State $word already defined" )
                  end
                  
                  // anyhow take the code as a preamble
                  code = m""
                  self.enterCode(~S..code)
               else
                  self.xerror(self.curLine, "Expected preamble or postamble" )
               end
                              
            case ~S..defState
               if tok in commands
                  self.xerror(self.curLine, "invalid declaration")
               else
                  stateName = tok
                  self.changeState( ~S..defPState, tok )
               end
               
            case ~S..defPState            
               if tok == ":"
                  if parLevel > 0
                     self.xerror( self.curLine, "Can assign parameter names to top-level tokens only" )
                  else                     
                     // we expect state names
                     self.addGState(stateName)
                     self.changeState( ~S..defPState2, tok )
                  end
               elif tok == "]"
                  // completed state delcaration
                  self.addGState(stateName)
                  self.changeState( ~S..postState, tok )
               else
                  self.xerror(self.curLine, "Invalid state declaration")
               end               
               
            case ~S..defPState2
               if tok == "]"
                  // completed state delcaration
                  self.changeState( ~S..postState, tok )
               elif tok in commands
                  self.xerror(self.curLine, "invalid declaration")
               else
                  // a parent state for the current state
                  self.addGStateInclude(tok)
               end
               
            case ~S..dfn
               if tok != "::="
                  self.xerror(self.curLine, "Need ::= after token specification.")
               else
                  currentNT, currentAlt = self.pushNT(currentToken)
                  self.changeState(~S..defBody, tok)
               end
               
            case ~S..defBody
               // now things get interesting.
               switch tok
               
                  case "."
                     // done
                     if parLevel > 0
                        self.error(self.curLine, "Unbalanced open parenthesis at rule closing")
                     else
                        self.commitNT()
                     end
                     // anyhow reset the rule
                     self.changeState(~S..start, tok)
                     // current cache reset
                     currentAlt = currentNT = currentToken = nil
                     
                  case "|"
                     // new alternative
                     currentAlt = NTAlt( self.curLine )
                     currentNT.alts += currentAlt
                     // stay in defbody state
                     
                  case "(" 
                     parLevel++
                     topTok = Token(Token.tNT, nil, nil, self.curLine)
                     currentAlt.sequence += topTok
                     currentNT, currentAlt = self.pushNT()
                     topTok.content = currentNT
                     
                     
                  case ")"
                     if parLevel == 0
                        self.xerror(self.curLine, "Unbalanced closed parenthesis")
                     else  
                        parLevel--
                        if currentAlt.sequence.empty
                           self.error(self.curLine, "Empty sub-alternative")
                           // but to not invalidate this rule
                        end
                        currentNT, currentAlt = self.popNT()
                     end
                     // consider this as if it was the post-name
                     self.changeState(~S..defName1, tok )
      
                  case "{"
                     code = m""
                     codeStage = 3
                     self.enterCode(~S..code)
                     
                  case "r\'", "R'", "r\"", "R\"", '"', "'"
                     Rignore = (tok == "R'" or tok == "R\"")
                     quoteType = (tok[-1] == '"')
                     Rquote = (tok[0] == 'R' or tok[0] == 'r')
                     quoteText = m""
                     self.changeState( ~S..quote, tok )
                                          
                  case "=>"
                     self.changeState( ~S..transition, tok )
                     
                  default
                     if tok in commands
                        self.xerror(self.curLine, "Unexpected token '" + tok + "'" )
                     else
                        // the token is a non-terminal in this alternative
                        self.commitToken( tok, currentAlt )
                        // enter in defName states
                        self.changeState( ~S..defName1, tok )
                     end
               end
               
            case ~S..defName1
               // we're past the token name, and waiting for ':' to define the name as paramter in code
               if tok == ':'
                  // wait for the real name
                  self.changeState( ~S..defName2, tok )
               elif tok == "*" or tok == "+" or tok == "?"
                  lastTok = currentAlt.sequence[-1]
                  if lastTok.repeat != Token.tSingle
                     self.xerror(self.curLine, "Conflicting repetition type" )                        
                  else                     
                     switch tok
                        case "*": lastTok.repeat = Token.tAsterisk 
                        case "+": lastTok.repeat = Token.tPlus
                        case "?": lastTok.repeat = Token.tQMark
                     end
                  end
                  // stay in this state.
               else
                  // go back to body definition and reparse the same token
                  take = false
                  self.changeState( ~S..defBody, tok )
               end
               
            case ~S..defName2
               if tok in commands
                  self.xerror(self.curLine, "Waiting for token name but received '" + tok + "'" )
               else                  
                  self.trace( "Assigning name '", tok, "' to token ", currentAlt.sequence[-1].name )
                  currentAlt.sequence[-1].pname = tok
                  self.changeState( ~S..defBody, tok )
               end
               
            case ~S..quote
               if tok == "\\"
                  self.changeState( ~S..escape, tok )
               else
                  if (quoteType and tok == '"') or (not quoteType and tok == "'")
                     if Rquote
                        self.changeState( ~S..Rafter, tok )
                     else
                        self.commitText(quoteText, currentAlt )
                        self.changeState( ~S..defName1, tok )
                     end
                  else
                     quoteText += tok
                  end
               end
               
            case ~S..escape
               quoteText += tok
               self.changeState( ~S..quote, tok )
               
                   
            case ~S..Rafter
               // time to create the RE
               if tok in commands
                  take = false   
                  opts = m""
               else
                  opts = tok                  
               end
               
               if Rignore: opts += "i"
               self.commitRE( quoteText, currentAlt, opts )               
               self.changeState( ~S..defName1 )
               
            case ~S..code               
               switch tok 
                  case '}'
                     // are we done?
                     if parCount == 0
                        // reset the parser to the normal status
                        mt.clearTokens()
                        call( mt.add, commands )
                        call( mt.add, whiteSpaces )
                        
                        switch codeStage
                           case 0
                              grammar.initcode = code
                              self.changeState(~S..start, tok)
                           case 1
                              self._cgs.preamble = code
                              self.changeState(~S..start, tok)
                           case 2
                              self._cgs.postamble = code
                              self.changeState(~S..start, tok)
                           case 3
                              self.commitCode(code, currentAlt)                        
                              self.changeState(~S..defBody, tok)  
                        end
                     else
                        code += "}"
                        parCount--
                     end
                  
                  case '{'
                     code += "{"
                     parCount++
                  
                  case "\\"
                     code += "\\"
                     
                  case '"', "'"
                     code += tok
                     quoteType = tok == '"'
                     self.changeState(~S..codeQuote, tok)
                  default
                     code += tok
               end
                  
            case ~S..codeQuote
               // we always add the token.
               code += tok
               
               if tok == "\\"                  
                  self.changeState(~S..codeEsc, tok)
               elif (quoteType and tok == '"') or (not quoteType and tok == "'")
                  self.changeState(~S..code, tok)
               end
                  
            case ~S..codeEsc
               code += tok
               self.changeState(~S..codeEsc, tok)
               
            case ~S..transition
               if tok == "#"
                  if currentAlt.transition != nil
                     self.xerror( self.curLine, "Conflicting state pop after transition" )
                  else
                     currentAlt.transpop++
                  end
               elif tok == "." or tok == "{"
                  take = false
                  self.changeState(~S..defBody, tok)
               elif tok in commands
                  self.xerror( self.curLine, "Unexpected token in transition declaration" )
               else
                  if currentAlt.transition != nil
                     self.xerror( self.curLine, "Conflicting transition declaration" )
                  elif currentAlt.transpop != 0
                     self.xerror( self.curLine, "Conflicting transition declaration after state pop" )
                  else
                     currentAlt.transition = tok
                  end
               end
               
            // manage exit from comment.
            case ~S..comment
               if tok == "*/"
                  self._state = oldState
                  mt.clearTokens()
                  call(mt.add, commands)
                  call(mt.add, whiteSpaces)
               end
               
         end /* Switch */
         
      end
      
      // we should be in start state
      if self._state = ~S..start
         self.error( self.curLine, "Unterminated definition at end of file" )
      end
      
      // and check for undefined
      if self.resolveStates()
         // if states are inconsistent, we can't resolve tokens across states
         self.resolveTokens()
         if self.errors == 0 
            // And if nodes are consistent, we can try to resolve the roots
            self.resolveRoots()
         end
      end
      
      // deref unused stuff
      self.mt = nil
      self._grammar = nil
      
      // shall generate the grammar?
      return self.errors == 0 ? grammar : nil
   end

   function enterCode(status)   
      // change the MultiTokenizer
      self.mt.clearTokens()
      self.mt.add('"', "'", "\\", "{", "}", "\n")
      parCount = 0
      self.changeState( status )
   end

   function commitNT()
      self.trace( "commitNT()" )
      if self._NTStack.empty
         self.error( self.curLine, "Internal error: committed empty stack" )
      end
      self._NTStack.clear()
   end
   
   /*
      Pushes a new token in the sequence of forming tokens.
      @return [NonTerminal, NTAlt]
   */
   function pushNT( tokenName )
      self.trace( @"pushNT($tokenName)" )
      
      // evevntually resolve the token now
      if tokenName
         state = self._cgs
         nt = state.entries.find(tokenName,nil)
         if not nt
            // if not found, create anew...
            nt = NonTerminal(tokenName, self.curLine )
            state.entries[tokenName] = nt
            // ... and try to see if it was waited for.
            
            // now, were we in wait of this non-terminal?
            undefs = state.unresolved.find(tokenName, nil)
            // if we were, assign this nonterminal to all the previously undefined tokens
            for utok in undefs
               utok.content = nt
            end
            state.unresolved -= tokenName
         end
      else
         // anonymous non-terminal
         nt = NonTerminal( nil, self.curLine )
      end
      
      self._NTStack.push(nt)
      
      // add a first alternative to the new token
      alt = NTAlt( self.curLine )
      nt.alts += alt            
      
      return [nt, alt]
   end
   
   /*
      Removes the topmost NT and return the previous one.
      @return [NonTerminal, NTAlt] or nil
   */
   function popNT()
      self.trace( "popNT()" )
      self._NTStack.pop()
      if self._NTStack.len
         nt = self._NTStack[-1]      
         return [nt, nt.alts[-1]]
      end
      
      return nil
   end
   
   /*
      Commits a non terminal token into a forming alternative.
      name -- the name of the non-terminal 
      alt -- the forming alternative (a NTAlt instance)
   */
   function commitToken(name, alt)
      self.trace( "commitToken", name )
   
      state = self._cgs
      nt = state.entries.find( name, nil )
      // for the token -- if the non terminal is undefined, nt will be nil
      type = name in self.predefined ? Token.tPredef : Token.tNT
      token = Token( type, nt, name, self.curLine )
      
      if not nt
         // of course, we won't find predefined symbols
         if type != Token.tPredef 
            // it's undefined, add to the undefined list         
            undefList = state.unresolved.find(name, nil)
            // do we already have a undefined list for this non-terminal name?
            if not undefList
               // if not add an entry
               undefList = []
               state.unresolved[name] = undefList
            end
         
            undefList += token
         end
      end
      
      alt.sequence += token
   end
   
   /*
      Commits a regular expression terminal token into a forming alternative.
      text -- The regular expression text
      alt -- the forming alternative (a NTAlt instance)
      opt -- Regular expression options
   */
   function commitRE( text, alt, opts )
      self.trace( "commitRE '", text )
      
      try
         re = RE( text, opts )
         alt.sequence += Token(Token.tRE, re, nil, self.curLine )
      catch in e
         self.xerror( self.curLine, "Invalid regular expression: " + e )
      end
   end

   /*
      Commits a text terminal token into a forming alternative.
      text -- The text
      alt -- the forming alternative (a NTAlt instance)
   */
   function commitText( text, alt )
      self.trace( "commitText '", text )
      alt.sequence += Token(Token.tString, text, nil, self.curLine )
   end
   
   /*
      Commits a code into a forming alternative.
      text -- The text
      alt -- the forming alternative (a NTAlt instance)
   */
   function commitCode( code, alt )
      self.trace( "commitCode()" )
      alt.code = code
   end

   /*
      Changes name-oriented state inclusion into object references,
      and check for formal errors (i.e. loops).
   */
   function resolveStates()
      self.trace( "Resolving states" )
      
      grammar = self._grammar
      
      for sname, state in grammar.states 
         objs = nil
         inc = state.includes
         self.trace( @"Resolving inclusion for state \"${sname}\"" )
         
         // initially, states are just names.
         for name in inc
            self.trace( @"Resolving included state \"${name}\"" )
            
            // if we have something to do, create an array
            forfirst: objs = []
            
            objState = grammar.states.find(name, nil)            
            if objState == nil
               self.error( state.line, @"In state [${state.name}] unresolved inclusion of ${element.name}" )                              
            else
               objs += objState
            end            
         end
         
         if objs
            state.includes = objs
            self.trace( @"Completed include resolution of state \"${sname}\"" )
         end
         
         // now do a formal check for recursive definitions
         if not self.checkStateRecursion( state.includes, 0, [] )
            return false
         end
      end
      
      return true
   end
   
   /*
      Pick the top rule in states
   */
   function resolveRoots()
      // every state must have exactly one token that is not referenced.
      for sname,state in self._grammar.states
         self.trace( "Picking the root node of ", state.name )
         refs = state.entries.values()
         for name, nt in state.entries       
            self.removeNTs( refs, nt )            
         end
         
         if refs.len > 1
            self.error( state.line, "Multiple roots in state " + state.name )
            for nt in refs
               self.error( state.line, "Token '" + nt.name + "' is a non-unique root in state " + state.name )
            end
         elif refs.len == 0 and state.entries.len > 0
            self.error( state.line, "State " + state.name +" has no root entry"  )
         else
            state.top = refs[0]
            self.trace( "In state", state.name, "token", state.top.name, "is the root node." )
         end
      end
   end
   
   function removeNTs( refs, nt )
      
      for alt in nt.alts
         for tok in alt.sequence
            if tok.type == Token.tNT
               child_nt = tok.content
               if child_nt != nt and child_nt in refs
                  refs -= child_nt
                  self.removeNTs( refs, child_nt )
               end
            end
         end
      end
      
      return true
   end

   /*
      Checks for undefined tokens.
   */
   function resolveTokens()
      self.trace( "Resolving tokens" )
      grammar = self._grammar
      for sname, state in grammar.states         
         for name, undefs in state.unresolved
            self.trace( @"Searching token \"${name}\" in includes" )
            tok = self.findInIncludes(name, state)
            if tok
               self.trace( @"Token \"${name}\" resolved in includes" )
               for element in undefs
                  element.content = tok
               end
            else
               self.error( state.line, @"In state [${state.name}] unresolved token ${name}" )
            end         
         end

         // resolve transitions in alternatives.
         for name, entry in state.entries
            for alt in entry.alts
               if alt.transition != nil
                  target = grammar.states.find(alt.transition, nil)
                  if not target
                     self.error( alt.line, @"Transition target state \"${alt.transition}\" not found" )
                  else
                     alt.transition = target
                     self.trace("In non terminal ", entry.name, "Resolved transition to", target.name )
                  end
               end
            end
         end
      end
   end
   
   
   function checkStateRecursion(includes, position, parents)
      // break the recursion when done
      if position >= includes.len: return true
      
      state = includes[position]
      if state in parents
         self.error( state.line, @"State \"${state.name}\" is recursively included by a child state")
         return false
      end
      
      parents += state
      if state.includes
         if not self.checkStateRecursion(state.includes, 0, parents)
            return false
         end
      end
      
      return self.checkStateRecursion(includes, position+1, parents)
   end
   
   function findInIncludes(name, state)
      for pstate in state.includes
         tok = pstate.entries.find( name, nil )
         if tok: return tok
         tok = self.findInIncludes(name, pstate)
         if tok: return tok
      end
      
      return nil
   end
      
   //========================================================================
   // Utilities
   //========================================================================
   
   function _resetParsing()
      self._state = ~S..start
      self.curLine = 1
      self.errors = 0
      self._NTStack = []
   end
   
   /** Adds a grammar state to the state definition.
   */
   function addGState( name )
      self.trace( "Adding Grammar State: ", name )
      if name in self._grammar.states
         // ignore [main] as first state declaration
         if name != "main" or self._cgs.name != "main"
            self.xerror(self.curLine, "Duplicate state declaration:", name)
         end

         // anyhow return current state (don't change it)
         return self._cgs
      end
      
      // clear to add a new state
      gstate = GrammarState(name, self.curLine)
      self._cgs = gstate
      self._grammar.states[name] = gstate
      return gstate
   end

   function addGStateInclude( name )
      self.trace( "Adding Inclusion of Grammar State: ", name , "to", self._cgs.name)
      self._cgs.includes += name
   end
   
   function changeState( newState, tok )
      self.trace( tok, ": ", self._state, "=>", newState )
      self._state = newState()
   end
   
   function trace()
      //> " ".merge(map( {[v] v.toString()}, passvp() ))
   end
   
   /*
      Consume up to the limits declared as variable parameters
   */
   function consume(mt)
      limits = passvp()
      while mt.hasNext
         tok = mt.next()
         if tok == "\n"
            self.curLine ++
         end
         
         if tok in limits
            break
         end
      end
   end
         
   function error(line, reason)
      self.handleError(line, reason)      
      self.errors++
   end
   
   function xerror(line, reason)
      self.error( line, reason )
      self.consume(self.mt,".","\n")
      self._state = 0
   end
         
end

if args.len == 0
   > "Usage: <file>"
   return 1
end

parsed = InputStream(args[0])

x = GrammarParser()
grammar = x.parse( TextReader(parsed, "utf8") )

> "Errors: ", x.errors

if grammar: grammar.dump(VMProcess.current.stdOut())
> "Done"

