/*
   FALCON - The Falcon Programming Language.
   FILE: lib.fal

   QR Code library back end.
   -----------------------------------------------------------------------------
   Author: Giuseppe Greco
   Begin: Wed, 27 Oct 2010 13:11:50 +0200

   -----------------------------------------------------------------------------
   (C) Copyright 2010: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/


/*# @beginignore */

import from gd2
load bufext

//------------------------------------------------------------------------------

const MaxInt = 2147483647
const FrameBaseName = "frame"
const MaskBaseName = "mask"

//------------------------------------------------------------------------------

enum QrMode
   null = -1
   num = 0
   an = 1
   bin = 2
   kanji = 3
   struct = 4
end

enum QrEcl
   L = 0
   M = 1
   Q = 2
   H = 3
end

//------------------------------------------------------------------------------

class QrError(code, desc, extra) from Error(code, desc, extra)
   functionality_not_supported = 10000
   invalid_param = 10001
   invalid_version = 10002
   version_not_found = 10003
   invalid_ecl = 10004
   invalid_mode = 10005
   invalid_mask = 10006
   encoding_error = 10007

   _desc = [
      self.functionality_not_supported => i"Functionality not supported",
      self.invalid_param => i"Invalid parameter",
      self.invalid_version => i"Invalid version",
      self.version_not_found => i"Version not found",
      self.invalid_ecl => i"Invalid error correction level",
      self.invalid_mode => i"Invalid mode",
      self.invalid_mask => i"Invalid mask",
      self.encoding_error => i"Encoding error"
   ]

   init
      if code in self._desc
         self.description = self._desc[code]
      end
   end
end

//------------------------------------------------------------------------------

enum QrInputConst
   struct_header_size = 20
end

QrAnTable = [
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43,
    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 44, -1, -1, -1, -1, -1,
   -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
   25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
]

class QrInputItem(mode, size, data, bitBuf)
   _mode = QrMode.null
   _size = 0
   _data = nil
   _bitBuf = nil

   init
      if data == nil
         raise QrError(QrError.invalid_param, i"data is null")
      end

      dataLength = len(data)
      if size and size < dataLength
         data[size:] = "\x0" * (size - dataLength)
      end

      if not QrInput.verifyMode(mode, size, data)
         raise QrError(QrError.encoding_error, @i"Mode $(mode) is not suitable for encoding the specified data")
      end

      self._mode = mode
      self._size = size
      self._data = data
      self._bitBuf = bitBuf
   end

   function __get_mode()
      return self._mode
   end

   function __get_bitBuf()
      return self._bitBuf
   end

   function estimateBitBufferSize(version)
      size = 0
      if version == 0: version = 1

      if self._mode == QrMode.num
         size = QrInput.estimateNumSize(self._size)
      elif self._mode == QrMode.an
         size = QrInput.estimateAnSize(self._size)
      elif self._mode == QrMode.bin
         size = QrInput.estimateBinSize(self._size)
      elif self._mode == QrMode.kanji
         size = QrInput.estimateKanjiSize(self._size)
      elif self._mode == QrMode.struct
         return QrInputConst.struct_header_size
      else
         return 0
      end

      length = QrSpec.getLengthIndicator(self._mode, version)
      w = 1 << length
      num = int((self._size + w - 1) / w)
      size += num * (length + 4)

      return size
   end

   function encodeBitBuffer(version)
      words = QrSpec.getMaxWords(self._mode, version)

      if self._size > words
         inputItem1 = QrInputItem(self._mode, words, self._data)
         inputItem2 = QrInputItem(self._mode, self.size - words, self._data[words:len(self._data) - words])

         inputItem1.encodeBitBuffer(version)
         inputItem2.encodeBitBuffer(version)

         self._bitBuf = BitBuf()
         inputItem1.bitBuf.readToBuf(self._bitBuf)
         inputItem2.bitBuf.readToBuf(self._bitBuf)
      else
         if self._mode ==  QrMode.num
            self._encodeNum(version)
         elif self._mode == QrMode.an
            self._encodeAn(version)
         elif self._mode == QrMode.bin
            self._encodeBin(version)
         elif self._mode == QrMode.kanji
            self._encodeKanji(version)
         elif self._mode == QrMode.struct
            self._encodeStruct()
         else
            raise QrError(QrError.invalid_mode, @i"$(self._mode) is not supported")
         end
      end

      return self._bitBuf.sizeBits()
   end

   /* private part */

   function _encodeNum(version)
      val = 0x1
      words = int(self._size / 3)
      zero = "0"[*0]

      bitBuf = BitBuf()
      bitBuf.bitCount(4).writeBits(val)
      bitBuf.bitCount(QrSpec.getLengthIndicator(QrMode.num, version)).writeBits(self._size)

      // cache function reference to improve performance 
      funcWriteBits = bitBuf.bitCount(10).writeBits

      for i in [0:words]
         val  = (self._data[*(i * 3)] - zero) * 100
         val += (self._data[*(i * 3 + 1)] - zero) * 10
         val += self._data[*(i * 3 + 2)] - zero
         funcWriteBits(val)
      end

      if self._size - words * 3 == 1
         val = self._data[*(words * 3)] - zero
         bitBuf.bitCount(4).writeBits(val)
      elif self._size - words * 3 == 2
         val  = (self._data[*(words * 3)] - zero) * 10
         val += self._data[*(words * 3 + 1)] - zero
         bitBuf.bitCount(7).writeBits(val)
      end

      self._bitBuf = bitBuf
   end

   function _encodeAn(version)
      words = self._size >> 1

      bitBuf = BitBuf()
      bitBuf.bitCount(4).writeBits(0x02)
      bitBuf.bitCount(QrSpec.getLengthIndicator(QrMode.an, version)).writeBits(self._size)

      // cache function references to improve performance 
      funcWriteBits = bitBuf.bitCount(11).writeBits
      funcLookAnTable = QrInput.lookAnTable

      for i in [0:words]
         val  = funcLookAnTable(self._data[*(i * 2)]) * 45
         val += funcLookAnTable(self._data[*(i * 2 + 1)])
         funcWriteBits(val)
      end

      if self._size && 1
         val = funcLookAnTable(self._data[*(words * 2)])
         bitBuf.bitCount(6).writeBits(val)
      end

      self._bitBuf = bitBuf
   end

   function _encodeBin(version)
      bitBuf = BitBuf()
      bitBuf.bitCount(4).writeBits(0x4)
      bitBuf.bitCount(QrSpec.getLengthIndicator(QrMode.bin, version)).writeBits(self._size)

      // cache function reference to improve performance 
      funcWriteBits = bitBuf.bitCount(8).writeBits

      for i in [0:self._size]
         funcWriteBits(self._data[*i])
      end
      
      self._bitBuf = bitBuf
   end

   function _encodeKanji(version)
      bitBuf = BitBuf()
      /*
      bitBuf.bitCount(4).writeBits(0x8)
      bitBuf.bitCount(QrSpec.getLengthIndicator(QrMode.kanji, version)).writeBits(int(self._size / 2))

      // cache function reference to improve performance 
      funcWriteBits = bitBuf.bitCount(13).writeBits

      for i in [0:self._size]
         val = self._data[i][*0]

         if val <= 0x9ffc
            val -= 0x8140
         else
            val -= 0xc140
         end

         h = (val >> 8) * 0xc0
         val = (val && 0xff) + h

         funcWriteBits(val)
      end

      self._bitBuf = bitBuf
      */

      // TODO: Kanji mode requires shift-jis do be used.
      // ATM we don't have it. Just adding the Unicode.

      bitBuf.bitCount(4).writeBits(0x8)
      bitBuf.bitCount(QrSpec.getLengthIndicator(QrMode.kanji, version)).writeBits(int(self._size))

      // cache function reference to improve performance 
      funcWriteBits = bitBuf.bitCount(13).writeBits

      for i in [0:self._size]
         funcWriteBits(self._data[*i])
      end

      self._bitBuf = bitBuf
   end

   function _encodeStruct()
      bitBuf = BitBuf()

      bitBuf.bitCount(4).writeBits(0x03)
      bitBuf.bitCount(4).writeBits(self._data[*1] - 1)
      bitBuf.bitCount(4).writeBits(self._data[*0] - 1)
      bitBuf.bitCount(8).writeBits(self._data[*2])

      self._bitBuf = bitBuf
   end

end

class QrInput(version, ecl)
   _version = 0
   _items = []
   _ecl = 0

   init
      if version == nil: version = 0
      if ecl == nil: ecl = QrEcl.L

      self._version = version
      self.ecl = ecl
   end

   function __get_version()
      return self._version
   end

   function __set_version(version)
      if version < 0 or version > QrSpecConst.max_version
         raise QrError(QrError.invalid_version, @i"$(version) is not supported")
      end

      self._version = version
   end

   function __get_ecl()
      return self._ecl
   end

   function __set_ecl(ecl)
      if ecl > QrEcl.H
         raise QrError(QrError.invalid_ecl, @i"$(ecl) is not supported")
      end

      self._ecl = ecl
   end

   function appendEntry(entry)
      arrayAdd(self._items, entry)
   end

   function append(mode, size, data)
      entry = QrInputItem(mode, size, data)
      arrayAdd(self._items, entry)
   end

   function lookAnTable(char)
      return char > 127 ? -1 : QrAnTable[char]
   end

   function estimateNumSize(run)
      w = int(run / 3)
      size = w * 10

      switch run - w * 3
         case 1
            size += 4
         case 2
            size += 7
      end

      return size;
   end

   function estimateAnSize(run)
      size  = (run >> 1) * 11
      if run && 1: size += 6
      return size
   end

   function estimateBinSize(run)
      return run << 3
   end

   function estimateKanjiSize(run)
      return (run >> 1) * 13
   end

   function verifyMode(mode, size, data)
      if size <= 0
         raise QrError(QrError.invalid_param, i"size is less than 1")
      end

      if mode == QrMode.num
         return self._verifyNum(size, data)
      elif mode == QrMode.an
         return self._verifyAn(size, data)
      elif mode == QrMode.kanji
         return self._verifyKanji(size, data)
      elif mode == QrMode.bin
         return true
      elif mode == QrMode.struct
         return true
      else
         raise QrError(QrError.invalid_mode, @i"$(mode) is not supported")
      end
   end

   function getByteStream()
      bitBuf = self._mergeBitBuffer()
      self._appendPaddingBits(bitBuf)
      // return bitBuf.toMemBuf()

      // The following piece of code  is a temporary workaround; it is going to
      // be removed as soon as BitBuf.toMemBuf() works correctly.

      size = bitBuf.size()
      if size == 0: return []
      data = arrayBuffer(size , 0)

      // cache function reference to improve performance 
      funcRead8 = bitBuf.r8

      bitBuf.rposBits(0)
      i = 0; while bitBuf.readableBits() > 0
         data[i++] = funcRead8()
      end

      return data
   end

   /* private part */

   function _appendPaddingBits(bitBuf)
      size = bitBuf.sizeBits()
      maxWords = QrSpec.getDataLength(self.version, self.ecl)
      maxSize = maxWords << 3

      if maxSize == size: return

      if maxSize - size < 5
         bitBuf.bitCount(maxSize - size).writeBits(0)
         return
      end

      size += 4
      words = (size + 7) >> 3

      padding = BitBuf()
      padding.bitCount(words * 8 - size + 4).writeBits(0)
      paddingLength = maxWords - words

      if paddingLength > 0
         paddingBuffer = arrayBuffer(paddingLength)

         // cache function reference to improve performance 
         funcWrite8 = padding.w8

         for i in [0:paddingLength]
            paddingBuffer[i] = (i && 1) ? 0x11 : 0xec
            funcWrite8(paddingBuffer[i]);
         end
      end

      padding.readToBuf(bitBuf)
   end

   function _convertData()
      version = self._estimateVersion()

      if version > self.version
         self.version = version
      end

      loop
         size = self._createBitBuffer()
         version = QrSpec.getMinVersion((size + 7) >> 3, self.ecl)

         if version > self.version
            self.version = version
         else; break; end
      end false
   end

   function _createBitBuffer()
      size = 0

      for item in self._items
         size += item.encodeBitBuffer(self.version)
      end

      return size
   end

   function _mergeBitBuffer()
      self._convertData()

      bitBuf = BitBuf()
      for item in self._items
        item.bitBuf.readToBuf(bitBuf)
      end

      return bitBuf
   end

   function _estimateVersion()
      version = previous = 0

      loop
         previous = version
         size = self._estimateBitBufferSize(previous)
         version = QrSpec.getMinVersion((size + 7) >> 3, self.ecl)
      end not version > previous

      return version
   end

   function _estimateBitBufferSize(version)
      size = 0

      for item in self._items
         size += item.estimateBitBufferSize(version)
      end

      return size
   end

   function _verifyNum(size, data)
      zero = "0"[*0]
      nine = "9"[*0]

      for i in [0:size]
         if (data[*i] < zero) or (data[*i] > nine): return false
      end

      return true
   end

   function _verifyAn(size, data)
      // cache function reference to improve performance 
      funcLookAnTable = self.lookAnTable

      for i in [0:size]
         if funcLookAnTable(data[*i]) == -1: return false
      end

      return true
   end

   function _verifyKanji(size, data)
      for i in [0:size]
         val = data[*i]
         /*
         if val < 0x8140 or (val > 0x9ffc and val < 0xe040) or val > 0xebbf
            return false
         end
         */
         if val < 0x3000: return false
      end

      return true
   end
end

//------------------------------------------------------------------------------

enum QrMaskConst
   n1 = 3
   n2 = 3
   n3 = 40
   n4 = 10
end

class QrMask(maker)
   _runLength = nil
   _maker = maker

   _mask = [
      [innerfunc (x, y); return (x + y) && 1; end],
      [innerfunc (x, y); return y && 1; end],
      [innerfunc (x, y); return x % 3; end],
      [innerfunc (x, y); return (x + y) % 3; end],
      [innerfunc (x, y); return (int(y / 2) + int(x / 3)) && 1; end],
      [innerfunc (x, y); return ((x * y) && 1) + (x * y) % 3; end],
      [innerfunc (x, y); return (((x * y) && 1) + (x * y) % 3) && 1; end],
      [innerfunc (x, y); return (((x * y) % 3) + ((x + y) && 1)) && 1; end]
   ]

   init
      self._runLength = arrayBuffer(QrSpecConst.max_width + 1, 0)
   end

   function createMaskNo(maskNo, width, frame, mask, generateBitMaskOnly)
      if generateBitMaskOnly == nil: generateBitMaskOnly = false
      bitMask = []

      if self._maker.cache_dir
         filename = self._maker.cache_dir \
         + "/" + MaskBaseName + "_" + maskNo \
         + "/" + MaskBaseName + "_" + width \
            + "_" + maskNo + ".dat"
         if fileType(filename) != FileStat.NOTFOUND
            inputStream = InputStream(filename)
            bitMask = deserialize(inputStream)
            inputStream.close()
         else
            bitMask = self._generateBitMask(maskNo, width, frame)
            if fileType(self._maker.cache_dir + "/" + MaskBaseName + "_" + maskNo) == FileStat.NOTFOUND
                dirMake(self._maker.cache_dir + "/" + MaskBaseName + "_" + maskNo)
            end

            outputStream = OutputStream(filename)
            serialize(bitMask, outputStream)
            outputStream.close()
         end
      else
         bitMask = self._generateBitMask(maskNo, width, frame)
      end

      if generateBitMaskOnly: return
      mask = clone(frame)
      maskNo = 0

      for y in [0:width]
         bitMaskRow = bitMask[y]
         frameRow = frame[y]
         for x in [0:width]
            if bitMaskRow[x] == "\x1"
               mask[y][x] = chr(frameRow[*x] ^^ bitMaskRow[*x])
            end
            maskNo += mask[y][*x] && 1
         end
      end

      return maskNo
   end

   function createMask(width, frame, maskNo, ecl)
      masked = arrayBuffer(width)
      for i in [0:width]; masked[i] = "\x0" * width; end

      self.createMaskNo(maskNo, width, frame, $masked)
      self._writeFormatInformation(width, masked, maskNo, ecl)
      return masked
   end

   function mask(width, frame, ecl)
      minDemerit = MaxInt
      bestMask = []
      checkedMasks = [0, 1, 2, 3, 4, 5, 6, 7]

      if self._maker.find_from_random != 0
         count = 8 - (self._maker.find_from_random % 9)
         for i in [0:count]
            pos = random(0, len(checkedMasks) - 1)
            arrayRemove(checkedMasks, pos)
         end
      end

      bestMask = frame

      for i in checkedMasks
         mask = arrayBuffer(width)
         for j in [0:width]; mask[j] = "\x0" * width; end

         demerit = blacks = 0
         blacks = self.createMaskNo(i, width, frame, $mask)
         blacks += self._writeFormatInformation(width, mask, i, ecl)
         blacks  = int(100 * blacks / (width * width))
         demerit = int(int(abs(blacks - 50) / 5) * QrMaskConst.n4)
         demerit += self._evaluateSymbol(width, mask)

         if demerit < minDemerit
            minDemerit = demerit
            bestMask = mask
         end
      end

      return bestMask
   end

   /* private part */

   function _calculateN1N3(length)
      demerit = 0

      for i in [0:length]
         if self._runLength[i] >= 5
            demerit += (QrMaskConst.n1 + (self._runLength[i] - 5))
         end
         if i && 1
            if (i >= 3) and (i < (length - 2)) and (self._runLength[i] % 3 == 0)
               fact = int(self._runLength[i] / 3)
               if (self._runLength[i - 2] == fact) and \
                  (self._runLength[i - 1] == fact) and \
                  (self._runLength[i + 1] == fact) and \
                  (self._runLength[i + 2] == fact)
                  if (self._runLength[i - 3] < 0) or (self._runLength[i - 3] >= (fact << 2))
                     demerit += QrMaskConst.n3
                  elif ((i + 3) >= length) or (self._runLength[i + 3] >= (fact << 2))
                     demerit += QrMaskConst.n3
                  end
               end
            end
         end
      end

      return demerit
   end

   function _evaluateSymbol(width, frame)
      head = demerit = 0

      // cache function reference to improve performance 
      funcCalculateN1N3= self._calculateN1N3

      for y in [0:width]
         head = 0
         self._runLength[0] = 1
         currRow = frame[y]
         prevRow = frame[y -1]

         for x in [0:width]
            if x > 0 and y > 0
               b22 = currRow[*x] && currRow[*(x - 1)] && prevRow[*x] && prevRow[*(x - 1)]
               w22 = currRow[*x] || currRow[*(x - 1)] || prevRow[*x] || prevRow[*(x - 1)]
               if (b22 || (w22 ^^ 1)) && 1: demerit += QrMaskConst.n2
            end
            if x == 0 and (currRow[*x] && 1)
               self._runLength[0] = -1
               head = 1
               self._runLength[head] = 1
            elif x > 0
               if (currRow[*x] ^^ currRow[*(x - 1)]) && 1
                  head++
                  self._runLength[head] = 1
               else
                  self._runLength[head]++
               end
            end
         end

         demerit += funcCalculateN1N3(head + 1)
      end

      for x in [0:width]
         head = 0
         self._runLength[0] = 1

         for y in [0:width]
            if y == 0 and (frame[y][*x] && 1)
               self._runLength[0] = -1
               head = 1
               self._runLength[head] = 1
            elif y > 0
               if (frame[y][*x] ^^ frame[y - 1][*x]) && 1
                  head++
                  self._runLength[head] = 1
               else
                  self._runLength[head]++
               end
            end
         end

         demerit += funcCalculateN1N3(head + 1)
      end

      return demerit
   end

   function _generateBitMask(maskNo, width, frame)
      bitMask = arrayBuffer(width)

      for y in [0:width]
         bitMaskRow = "\x0" * width
         frameRow = frame[y]
         for x in [0:width]
            if not frameRow[*x] && 0x80 and self._mask[maskNo](x, y) == 0
               bitMaskRow[x] = "\x1"
            end
         end
         bitMask[y] = bitMaskRow
      end

      return bitMask
   end

   function _writeFormatInformation(width, frame, maskNo, ecl)
      blacks = 0
      format = QrSpec.getFormatInfo(maskNo, ecl)

      for i in [0:8]
         if format && 1
            blacks += 2
            val = chr(0x85)
         else
            val = chr(0x84)
         end

         frame[8][width - 1 - i] = val
         if i < 6
            frame[i][8] = val
         else
            frame[i + 1][8] = val
         end
         format >>= 1
      end

      for i in [0:7]
         if format && 1
            blacks += 2
            val = chr(0x85)
         else
            val = chr(0x84)
         end

         frame[width - 7 + i][8] = val
         if i == 0
            frame[8][7] = val
         else
            frame[8][6 - i] = val
         end
         format >>= 1
      end

      return blacks
   end
end

//------------------------------------------------------------------------------

class QrRsItem(symSize, gfPoly, fcr, prim, nRoots, pad)
   _nn = 0
   _alphaTo = nil
   _indexOf = nil
   _genPoly = nil
   _iPrim = 0

   mm = 0
   nRoots = 0
   fcr = 0
   prim = 0
   pad = 0
   gfPoly = 0

   init
      // Common code for intializing a Reed-Solomon control block (char or int symbols)
      // Copyright 2004 Phil Karn, KA9Q
      // May be used under the terms of the GNU Lesser General Public License (LGPL)

      if (symSize < 0 or symSize > 8) \
         or (fcr < 0 or fcr >= (1 << symSize)) \
         or (prim <= 0 or prim >= (1 << symSize)) \
         or (nRoots < 0 or nRoots >= (1 << symSize)) \
         or (pad < 0 or pad >= ((1 << symSize) -1 - nRoots))
         raise QrError(QrError.encoding_error, i"error initializing Reed-Solomon control block")
      end

      self.mm = symSize
      self._nn = (1 << symSize) - 1
      self.pad = pad

      self._alphaTo = arrayBuffer(self._nn + 1, 0)
      self._indexOf = arrayBuffer(self._nn + 1, 0)

      self._indexOf[0] = self._nn
      self._alphaTo[self._nn] = 0
      sr = 1

      for i in [0:self._nn]
         self._indexOf[sr] = i
         self._alphaTo[i] = sr
         sr <<= 1
         if sr && (1 << symSize): sr ^= gfPoly
         sr &= self._nn
      end

      if sr != 1
         raise QrError(QrError.encoding_error, i"polynominal is not primitive")
      end

      self._genPoly = arrayBuffer(nRoots + 1, 0)
      self.fcr = fcr
      self.prim = prim
      self.nRoots = nRoots
      self.gfPoly = gfPoly

      iprim = 1; while (iprim % prim) != 0; iprim += self._nn; end
      self._iPrim = int(iprim / prim)
      self._genPoly[0] = 1

      root = fcr * prim
      for i in [0:nRoots]
         self._genPoly[i + 1] = 1

         for j in [i:1:-1]
            if self._genPoly[j] != 0
               self._genPoly[j] = self._genPoly[j - 1] ^^ \
               self._alphaTo[self._modnn(self._indexOf[self._genPoly[j]] + root)]
            else
               self._genPoly[j] = self._genPoly[j - 1]
            end
         end
         self._genPoly[0] = self._alphaTo[self._modnn(self._indexOf[self._genPoly[0]] + root)]
         root += prim
      end

      for i in [0:nRoots + 1]
         self._genPoly[i] = self._indexOf[self._genPoly[i]]
      end
   end
   

   function encodeChar(data)
      parity = arrayBuffer(self.nRoots, 0)

      for i in [0:self._nn - self.nRoots - self.pad]
         feedback = self._indexOf[data[i] ^^ parity[0]]
         if feedback != self._nn
            feedback = self._modnn(self._nn - self._genPoly[self.nRoots] + feedback)
            for j in [1:self.nRoots]
               parity[j] ^= self._alphaTo[self._modnn(feedback + self._genPoly[self.nRoots - j])]
            end
         end

         if len(parity) > 0: arrayRemove(parity, 0)
         if feedback != self._nn
            arrayAdd(parity, self._alphaTo[self._modnn(feedback + self._genPoly[0])])
         else
            arrayAdd(parity, 0)
         end
      end

      return parity
   end

   /* private part */

   function _modnn(val)
      while val >= self._nn
         val -= self._nn
         val = (val >> self.mm) + (val && self._nn)
      end

      return val
   end
end

class QrRs
   _items = []

   function getItem(symSize, gfPoly, fcr, prim, nRoots, pad)
      for rs in self._items
         if rs.pad != pad: continue
         if rs.nRoots != nRoots: continue
         if rs.mm != symSize: continue
         if rs.gfPoly != gfPoly: continue
         if rs.fcr != fcr: continue
         if rs.prim != prim: continue
         return rs;
      end

      rs = QrRsItem(symSize, gfPoly, fcr, prim, nRoots, pad)
      arrayIns(self._items, 0, rs)

      return rs
   end
end

//------------------------------------------------------------------------------

class QrSplit(data, input, mode)
   _data = nil
   _input = nil
   _mode = nil

   init
      self._data = data
      self._input = input
      self._mode = mode
   end

   function splitStringToInput(string, input, mode, caseSensitive)
      if caseSensitive == nil: caseSensitive = true
      if string == nil or string == "\x0" or string == ""
         raise QrError(QrError.invalid_param, i"string is empty")
      end

      split = QrSplit(string, input, mode)

      if not caseSensitive: split.toUpper()
      split.splitString()
   end

   function splitString()
      while len(self._data) > 0
         if self._data == "": break

         mode = self._identifyMode(0)

         if mode == QrMode.num
            length = self._eatNum()
         elif mode == QrMode.an
            length = self._eatAn()
         elif mode == QrMode.kanji
            if self._mode == QrMode.kanji
               length = self._eatKanji()
            else
               length = self._eatBin()
            end
         else
            length = self._eatBin()
         end

         if length > 0: self._data = strBack(self._data, len(self._data) - length)
      end
   end

   function toUpper()
      stringLength = len(self._data)
      a = "a"[*0]
      z = "z"[*0]

      i = 0; while i < stringLength
         mode = self._identifyMode(strBack(self._data, stringLength - i), self._mode)
         if mode == QrMode.kanji
            i += 2
         else
            if self._data[*i] >= a and self._data[*i] <= z
               self._data[i] = chr(self._data[*i] - 32)
            end
            i++
         end
      end

      return self._data
   end

   /* private part */

   function _eatNum()
      length = QrSpec.getLengthIndicator(QrMode.num, self._input.version)
      run = 0; while self._isDigitAt(self._data, run); run++; end
      mode = self._identifyMode(run)

      if mode == QrMode.bin
         if QrInput.estimateNumSize(run) + 4 + length \
            + QrInput.estimateBinSize(1) \
            - QrInput.estimateBinSize(run + 1) > 0
            return self._eatBin()
         end
      end

      if mode == QrMode.an
         if QrInput.estimateNumSize(run) + 4 + length \
            + QrInput.estimateAnSize(1) \
            - QrInput.estimateAnSize(run + 1) > 0
            return self._eatAn()
         end
      end

      self._input.append(QrMode.num, run, self._data)
      return run;
   end

   function _eatAn()
      lengthAn= QrSpec.getLengthIndicator(QrMode.an, self._input.version)
      lengthNum = QrSpec.getLengthIndicator(QrMode.num, self._input.version)

      run = 0; while self._isAlNumAt(self._data, run)
         if self._isDigitAt(self._data, run)
            q = run
            while self._isDigitAt(self._data, q); q++; end

            if QrInput.estimateAnSize(run) \
               + QrInput.estimateNumSize(q - run) + 4 + lengthNum \
               - QrInput.estimateAnSize(q) < 0
               break
            else
               run = q
            end
         else
            run++
         end
      end

      if not self._isAlNumAt(self._data, run)
         if QrInput.estimateAnSize(run) + 4 + lengthAn \
            + QrInput.estimateBinSize(1) \
            - QrInput.estimateBinSize(run + 1) > 0
            return self._eatBin()
         end
      end

      self._input.append(QrMode.an, run, self._data)
      return run
   end

   function _eatKanji()
      run = 0; while self._identifyMode(run) == QrMode.kanji; run += 2; end
      self._input.append(QrMode.kanji, run, self._data)
      return run
   end

   function _eatBin()
      lengthAn = QrSpec.getLengthIndicator(QrMode.an, self._input.version)
      lengthNum = QrSpec.getLengthIndicator(QrMode.num, self._input.version)

      // cache function references to improve performance 
      funcIdentifyMode = self._identifyMode
      funcIsAlNumAt = self._isAlNumAt
      funcIsDigitAt = self._isDigitAt
      funcEstimateAnSize = QrInput.estimateAnSize
      funcEstimateNumSize = QrInput.estimateNumSize
      funcEstimateBinSize = QrInput.estimateBinSize

      dataLength = len(self._data)
      run = 1; while run < dataLength
         mode = funcIdentifyMode(run)
         if mode == QrMode.kanji: break
         if mode == QrMode.num
            q = run
            while funcIsDigitAt(self._data, q); q++; end
            if funcEstimateBinSize(run) \
               + funcEstimateNumSize(q - run) + 4 + lengthNum \
               - funcEstimateBinSize(q) < 0
               break
            else
               run = q
            end
         elif mode == QrMode.an
            q = run
            while funcIsAlNumAt(self._data, q); q++; end
            if funcEstimateBinSize(run) \
               + funcEstimateAnSize(q - run) + 4 + lengthAn \
               - funcEstimateBinSize(q) < 0
               break
            else
               run = q
            end
         else
            run++
         end
      end

      self._input.append(QrMode.bin, run, self._data)
      return run
   end

   function _identifyMode(pos)
      if pos >= len(self._data): return QrMode.null

      if self._isDigitAt(self._data, pos)
         return QrMode.num;
      elif self._isAlNumAt(self._data, pos)
         return QrMode.an;
      elif self._mode == QrMode.kanji
         if pos + 1 < len(self._data)
            word = self._data[*pos] << 8 || self._data[*(pos + 1)]
            // if (word >= 0x8140 and word <= 0x9ffc) or (word >= 0xe040 and word <= 0xebbf)
            // Our kanjis are in the UNICODE range, not in shift-jis
            if word >= 0x3040 and word <= 0x4db0
               return QrMode.kanji
            end
         end
      end

      return QrMode.bin
   end

   function _isDigitAt(str, pos)
      if pos >= len(str): return false
      return str[*pos] >= "0"[*0] and str[*pos] <= "9"[*0]
   end

   function _isAlNumAt(str, pos)
      if pos >= len(str): return false
      return QrInput.lookAnTable(str[*pos]) >= 0
   end
end

//------------------------------------------------------------------------------

object QrImage
   function png(frame, outFile, pixelPerPoint, outerFrame)
      img = self._image(frame, pixelPerPoint, outerFrame)
      img.Png(outFile)
   end

   function jpg(frame, outFile, pixelPerPoint, outerFrame, quality)
      if quality == nil: quality = 85

      img = self._image(frame, pixelPerPoint, outerFrame)
      img.Jpeg(outFile, quality)
   end

   /* private part */

   function _image(frame, pixelPerPoint, outerFrame)
      if frame == nil
         raise QrError(QrError.invalid_param, i"frame is null")
      end

      if pixelPerPoint == nil: pixelPerPoint = 4
      if outerFrame == nil: outerFrame = 4

      height = len(frame)
      width = len(frame[0])

      imgHeight = height + 2 * outerFrame
      imgWidth = width + 2 * outerFrame

      baseImg = gd2.GdImage(imgWidth, imgHeight)
      col = .[
         baseImg.ColorAllocate(255, 255, 255)
         baseImg.ColorAllocate(0, 0, 0)
      ]
      baseImg.Fill(0, 0, col[0])

      // cache function reference to improve performance 
      funcSetPixel = baseImg.SetPixel

      for y in [0:height]
         row = frame[y]
         for x in [0:width]
            if row[x] == "1"
               funcSetPixel(x + outerFrame, y + outerFrame, col[1])
            end
         end
      end

      targetImg = gd2.GdImage(imgWidth * pixelPerPoint, imgHeight * pixelPerPoint)
      targetImg.CopyResized(baseImg, 0, 0, 0, 0, \
         imgWidth * pixelPerPoint, \
         imgHeight * pixelPerPoint, \
         imgWidth, imgHeight)

      return targetImg
   end
end

//------------------------------------------------------------------------------

class QrRsBlock(dataLength, data, ecc, rsItem)
   dataLength = 0
   data = nil
   ecc = nil

   init
      self.dataLength = dataLength
      self.data = data
      self.ecc = ecc = rsItem.encodeChar(data)
   end
end

class QrRawCode(input)
   _version = 0
   _data = nil
   _dataLength = 0
   _ecc = nil
   _eccLength = 0
   _rsBlocks = []
   _blockNum = 0
   _blockNum1 = 0
   _count = 0
   _rs = QrRs()

   init
      if input == nil
         raise QrError(QrError.invalid_param, i"input is null")
      end

      self._data = input.getByteStream()
      self._version = input.version
      spec = QrSpec.getEccSpec(input.version, input.ecl)
      self._blockNum1 = QrSpec.rsBlockNum1(spec)
      self._dataLength = QrSpec.rsDataLength(spec)
      self._eccLength = QrSpec.rsEccLength(spec)
      self._ecc = arrayBuffer(self._eccLength, 0)
      self._blockNum = QrSpec.rsBlockNum(spec)
      self._initialize(spec)
   end

   function __get_version()
      return self._version
   end

   function __get_dataLength()
      return self._dataLength
   end

   function __get_eccLength()
      return self._eccLength
   end

   function getCode()
      code = 0

      if self._count < self._dataLength
         row = self._count % self._blockNum
         col = self._count / self._blockNum
         if col >= self._rsBlocks[0].dataLength
            row += self._blockNum1
         end
         code = self._rsBlocks[row].data[col]
      elif self._count < self._dataLength + self._eccLength
         row = (self._count - self._dataLength) % self._blockNum
         col = (self._count - self._dataLength) / self._blockNum
         code = self._rsBlocks[row].ecc[col]
      else
         return code
      end

      self._count++
      return code
   end

   /* private part */

   function _initialize(spec)
      dataPos = eccPos = 0
      ecc = nil
      self._rsBlocks = []

      dataLength = QrSpec.rsDataCodes1(spec)
      eccLength = QrSpec.rsEccCodes1(spec)
      rs = self._rs.getItem(8, 0x11d, 0, 1, eccLength, 255 - dataLength - eccLength)

      for i in [0:QrSpec.rsBlockNum1(spec)]
         arrayAdd(self._rsBlocks, QrRsBlock(dataLength, self._data[dataPos:], $ecc, rs))
         self._ecc = self._ecc[0:eccPos] + ecc[0:]
         dataPos += dataLength
         eccPos += eccLength
      end

      if QrSpec.rsBlockNum2(spec) != 0
         dataLength = QrSpec.rsDataCodes2(spec)
         eccLength = QrSpec.rsEccCodes2(spec)
         rs = self._rs.getItem(8, 0x11d, 0, 1, eccLength, 255 - dataLength - eccLength)

         for i in [0:QrSpec.rsBlockNum2(spec)]
            arrayAdd(self._rsBlocks, QrRsBlock(dataLength, self._data[dataPos:], $ecc, rs))
            self._ecc = self._ecc[0:eccPos] + ecc[0:]
            dataPos += dataLength
            eccPos += eccLength
         end
      end
   end
end

class QrFrameFiller(width, frame)
   _width = 0
   _frame = nil
   _x = 0
   _y = 0
   _dir = 0
   _bit = 0

   init
      self._width = width
      self._frame = frame
      self._x = width - 1
      self._y = width - 1
      self._dir = -1
      self._bit = -1
   end

   function __get_width()
      return self._width
   end

   function __get_frame()
      return self._frame
   end

   function setFrameAt(at, val)
      self._frame[at["y"]][at["x"]] = chr(val)
   end

   function getFrameAt(at)
      return self._frame[at["y"]][*at["x"]]
   end

   function next()
      x = self._x
      y = self._y

      loop
         if self._bit == -1
            self._bit = 0
            return ["x" => self._x, "y" => self._y]
         end

         if self._bit == 0
            x--
            self._bit++
         else
            x++
            y += self._dir
            self._bit--
         end

         if self._dir < 0
            if y < 0
               y = 0
               x -= 2
               self._dir = 1
               if x == 6
                  x--
                  y = 9
               end
            end
         else
            if y == self.width
               y = self.width - 1
               x -= 2
               self._dir = -1
               if x == 6
                  x--
                  y -= 8
               end
            end
         end

         if x < 0 or y < 0
            raise QrError(QrError.encoding_error, i"error masking frame")
         end

         self._x = x
         self._y = y
      end (self._frame[y][*x] && 0x80) == 0

      return ["x" => x, "y" => y]
   end
end

//------------------------------------------------------------------------------

class QrTools
   function binarize(frame)
      frameLength = len(frame)
      for row in frame
         for i in [0:frameLength]
            row[i] = (row[*i] && 1) ? "1" : "0"
         end
      end

      return frame
   end

   function buildCache(dir)
      if dir == nil or dir == ""
         raise QrError(QrError.invalid_param, i"dir is null or empty")
      end

      mask = QrMask()
      spec = QrSpec()

      for version in [1:QrSpecConst.max_version + 1]
         frame = spec.createFrame(version, dir)
         filename = dir + "/" + FrameBaseName + "_" + version + ".png"
         QrImage.png(self.binarize(frame), filename, 1, 0)

         width = len(frame)
         bitMask = arrayBuffer(width)
         for i in [0:width]; bitMask[i] = "\x0" * width; end

         for maskNo in [0:8]
            mask.createMaskNo(maskNo, width, frame, $bitMask, true)
         end
      end
   end
end

//------------------------------------------------------------------------------

enum QrSpecConst
   max_version = 40
   max_width = 177
end

enum QrCapConst
   width = 0
   words = 1
   reminder = 2
   ec = 3
end

QrLengthTable = [
   [10, 12, 14],
   [ 9, 11, 13],
   [ 8, 16, 16],
   [ 8, 10, 12]
]

QrCapacity = [
   [  0,    0, 0, [   0,    0,    0,    0]],
   [ 21,   26, 0, [   7,   10,   13,   17]], // 1
   [ 25,   44, 7, [  10,   16,   22,   28]],
   [ 29,   70, 7, [  15,   26,   36,   44]],
   [ 33,  100, 7, [  20,   36,   52,   64]],
   [ 37,  134, 7, [  26,   48,   72,   88]], // 5
   [ 41,  172, 7, [  36,   64,   96,  112]],
   [ 45,  196, 0, [  40,   72,  108,  130]],
   [ 49,  242, 0, [  48,   88,  132,  156]],
   [ 53,  292, 0, [  60,  110,  160,  192]],
   [ 57,  346, 0, [  72,  130,  192,  224]], //10
   [ 61,  404, 0, [  80,  150,  224,  264]],
   [ 65,  466, 0, [  96,  176,  260,  308]],
   [ 69,  532, 0, [ 104,  198,  288,  352]],
   [ 73,  581, 3, [ 120,  216,  320,  384]],
   [ 77,  655, 3, [ 132,  240,  360,  432]], //15
   [ 81,  733, 3, [ 144,  280,  408,  480]],
   [ 85,  815, 3, [ 168,  308,  448,  532]],
   [ 89,  901, 3, [ 180,  338,  504,  588]],
   [ 93,  991, 3, [ 196,  364,  546,  650]],
   [ 97, 1085, 3, [ 224,  416,  600,  700]], //20
   [101, 1156, 4, [ 224,  442,  644,  750]],
   [105, 1258, 4, [ 252,  476,  690,  816]],
   [109, 1364, 4, [ 270,  504,  750,  900]],
   [113, 1474, 4, [ 300,  560,  810,  960]],
   [117, 1588, 4, [ 312,  588,  870, 1050]], //25
   [121, 1706, 4, [ 336,  644,  952, 1110]],
   [125, 1828, 4, [ 360,  700, 1020, 1200]],
   [129, 1921, 3, [ 390,  728, 1050, 1260]],
   [133, 2051, 3, [ 420,  784, 1140, 1350]],
   [137, 2185, 3, [ 450,  812, 1200, 1440]], //30
   [141, 2323, 3, [ 480,  868, 1290, 1530]],
   [145, 2465, 3, [ 510,  924, 1350, 1620]],
   [149, 2611, 3, [ 540,  980, 1440, 1710]],
   [153, 2761, 3, [ 570, 1036, 1530, 1800]],
   [157, 2876, 0, [ 570, 1064, 1590, 1890]], //35
   [161, 3034, 0, [ 600, 1120, 1680, 1980]],
   [165, 3196, 0, [ 630, 1204, 1770, 2100]],
   [169, 3362, 0, [ 660, 1260, 1860, 2220]],
   [173, 3532, 0, [ 720, 1316, 1950, 2310]],
   [177, 3706, 0, [ 750, 1372, 2040, 2430]]  //40
]

QrEccTable = [
   [[ 0,  0], [ 0,  0], [ 0,  0], [ 0,  0]],
   [[ 1,  0], [ 1,  0], [ 1,  0], [ 1,  0]], // 1
   [[ 1,  0], [ 1,  0], [ 1,  0], [ 1,  0]],
   [[ 1,  0], [ 1,  0], [ 2,  0], [ 2,  0]],
   [[ 1,  0], [ 2,  0], [ 2,  0], [ 4,  0]],
   [[ 1,  0], [ 2,  0], [ 2,  2], [ 2,  2]], // 5
   [[ 2,  0], [ 4,  0], [ 4,  0], [ 4,  0]],
   [[ 2,  0], [ 4,  0], [ 2,  4], [ 4,  1]],
   [[ 2,  0], [ 2,  2], [ 4,  2], [ 4,  2]],
   [[ 2,  0], [ 3,  2], [ 4,  4], [ 4,  4]],
   [[ 2,  2], [ 4,  1], [ 6,  2], [ 6,  2]], //10
   [[ 4,  0], [ 1,  4], [ 4,  4], [ 3,  8]],
   [[ 2,  2], [ 6,  2], [ 4,  6], [ 7,  4]],
   [[ 4,  0], [ 8,  1], [ 8,  4], [12,  4]],
   [[ 3,  1], [ 4,  5], [11,  5], [11,  5]],
   [[ 5,  1], [ 5,  5], [ 5,  7], [11,  7]], //15
   [[ 5,  1], [ 7,  3], [15,  2], [ 3, 13]],
   [[ 1,  5], [10,  1], [ 1, 15], [ 2, 17]],
   [[ 5,  1], [ 9,  4], [17,  1], [ 2, 19]],
   [[ 3,  4], [ 3, 11], [17,  4], [ 9, 16]],
   [[ 3,  5], [ 3, 13], [15,  5], [15, 10]], //20
   [[ 4,  4], [17,  0], [17,  6], [19,  6]],
   [[ 2,  7], [17,  0], [ 7, 16], [34,  0]],
   [[ 4,  5], [ 4, 14], [11, 14], [16, 14]],
   [[ 6,  4], [ 6, 14], [11, 16], [30,  2]],
   [[ 8,  4], [ 8, 13], [ 7, 22], [22, 13]], //25
   [[10,  2], [19,  4], [28,  6], [33,  4]],
   [[ 8,  4], [22,  3], [ 8, 26], [12, 28]],
   [[ 3, 10], [ 3, 23], [ 4, 31], [11, 31]],
   [[ 7,  7], [21,  7], [ 1, 37], [19, 26]],
   [[ 5, 10], [19, 10], [15, 25], [23, 25]], //30
   [[13,  3], [ 2, 29], [42,  1], [23, 28]],
   [[17,  0], [10, 23], [10, 35], [19, 35]],
   [[17,  1], [14, 21], [29, 19], [11, 46]],
   [[13,  6], [14, 23], [44,  7], [59,  1]],
   [[12,  7], [12, 26], [39, 14], [22, 41]], //35
   [[ 6, 14], [ 6, 34], [46, 10], [ 2, 64]],
   [[17,  4], [29, 14], [49, 10], [24, 46]],
   [[ 4, 18], [13, 32], [48, 14], [42, 32]],
   [[20,  4], [40,  7], [43, 22], [10, 67]],
   [[19,  6], [18, 31], [34, 34], [20, 61]]  //40
]

QrAlignmentPattern = [
   [ 0,  0],
   [ 0,  0], [18,  0], [22,  0], [26,  0], [30,  0], // 1- 5
   [34,  0], [22, 38], [24, 42], [26, 46], [28, 50], // 6-10
   [30, 54], [32, 58], [34, 62], [26, 46], [26, 48], //11-15
   [26, 50], [30, 54], [30, 56], [30, 58], [34, 62], //16-20
   [28, 50], [26, 50], [30, 54], [28, 54], [32, 58], //21-25
   [30, 58], [34, 62], [26, 50], [30, 54], [26, 52], //26-30
   [30, 56], [34, 60], [30, 58], [34, 62], [30, 54], //31-35
   [24, 50], [28, 54], [32, 58], [26, 54], [30, 58]  //35-40
]

QrVersionPattern = [
   0x07c94, 0x085bc, 0x09a99, 0x0a4d3, 0x0bbf6, 0x0c762, 0x0d847, 0x0e60d,
   0x0f928, 0x10b78, 0x1145d, 0x12a17, 0x13532, 0x149a6, 0x15683, 0x168c9,
   0x177ec, 0x18ec4, 0x191e1, 0x1afab, 0x1b08e, 0x1cc1a, 0x1d33f, 0x1ed75,
   0x1f250, 0x209d5, 0x216f0, 0x228ba, 0x2379f, 0x24b0b, 0x2542e, 0x26a64,
   0x27541, 0x28c69
]

QrFormatInfo = [
   [0x77c4, 0x72f3, 0x7daa, 0x789d, 0x662f, 0x6318, 0x6c41, 0x6976],
   [0x5412, 0x5125, 0x5e7c, 0x5b4b, 0x45f9, 0x40ce, 0x4f97, 0x4aa0],
   [0x355f, 0x3068, 0x3f31, 0x3a06, 0x24b4, 0x2183, 0x2eda, 0x2bed],
   [0x1689, 0x13be, 0x1ce7, 0x19d0, 0x0762, 0x0255, 0x0d0c, 0x083b]
]

class QrSpec
   frames = nil

   function getDataLength(version, ecl)
      return QrCapacity[version][QrCapConst.words] - QrCapacity[version][QrCapConst.ec][ecl]
   end

   function getEccLength(version, ecl)
      return QrCapacity[version][QrCapConst.ec][ecl]
   end

   function getWidth(version)
      return QrCapacity[version][QrCapConst.width]
   end

   function getRemainder(version)
      return QrCapacity[version][QrCapConst.reminder]
   end

   function getMinVersion(size, ecl)
      for i in [1:QrSpecConst.max_version + 1]
         if QrCapacity[i][QrCapConst.words] - \
            QrCapacity[i][QrCapConst.ec][ecl] >= size
            return i
         end
      end

      raise QrError(QrError.version_not_found)
   end

   function getLengthIndicator(mode, version)
      if mode == QrMode.struct: return 0
      length = 0

      if version <= 9
         length = 0
      elif version <= 26
         length = 1
      else
         length = 2
      end

      return QrLengthTable[mode][length]
   end

   function getMaxWords(mode, version)
      if mode == QrMode.struct: return 3
      length = 0

      if version <= 9
         length = 0
      elif version <= 26
         length = 1
      else
         length = 2
      end

      words = (1 << (QrLengthTable[mode][length])) - 1
      if mode == QrMode.kanji: words <<= 1

      return words
   end

   function getEccSpec(version, ecl)
      spec = [0, 0, 0, 0, 0]

      b1 = QrEccTable[version][ecl][0]
      b2 = QrEccTable[version][ecl][1]
      dataLength = self.getDataLength(version, ecl)
      eccLength  = self.getEccLength(version, ecl)

      if b2 == 0
         spec[0] = b1
         spec[1] = int(dataLength / b1)
         spec[2] = int(eccLength / b1)
         spec[3] = 0
         spec[4] = 0
      else
         spec[0] = b1
         spec[1] = int(dataLength / (b1 + b2))
         spec[2] = int(eccLength  / (b1 + b2))
         spec[3] = b2
         spec[4] = spec[1] + 1
      end

      return spec
   end

   function putAlignmentMarker(frame, x, y)
      finder = [
         "\xa1\xa1\xa1\xa1\xa1",
         "\xa1\xa0\xa0\xa0\xa1",
         "\xa1\xa0\xa1\xa0\xa1",
         "\xa1\xa0\xa0\xa0\xa1",
         "\xa1\xa1\xa1\xa1\xa1"
      ]

      x -= 2
      y -= 2

      for i in [0:5]
         self._applyPattern(frame, x, y + i, finder[i])
      end
   end

   function getVersionPattern(version)
      if version < 7 or version > QrSpecConst.max_version
         raise QrError(QrError.invalid_version, @i"$(version) is not supported")
      end

      return QrVersionPattern[version -7]
   end

   function getFormatInfo(mask, ecl)
      if mask < 0 or mask > 7;
         raise QrError(QrError.invalid_mask, @i"$(mask) is not supported")
      end

      if ecl < QrEcl.L or ecl > QrEcl.H
         raise QrError(QrError.invalid_ecl, @i"$(ecl) not supported")
      end

      return QrFormatInfo[ecl][mask]
   end

   function putFinderPattern(frame, x, y)
      finder = [
         "\xc1\xc1\xc1\xc1\xc1\xc1\xc1",
         "\xc1\xc0\xc0\xc0\xc0\xc0\xc1",
         "\xc1\xc0\xc1\xc1\xc1\xc0\xc1",
         "\xc1\xc0\xc1\xc1\xc1\xc0\xc1",
         "\xc1\xc0\xc1\xc1\xc1\xc0\xc1",
         "\xc1\xc0\xc0\xc0\xc0\xc0\xc1",
         "\xc1\xc1\xc1\xc1\xc1\xc1\xc1"
      ]

      for i in [0:7]
         self._applyPattern(frame, x, y + i, finder[i])
      end
   end

   function createFrame(version, cacheDir)
      if cacheDir == "": cacheDir = nil
      if version < 1 or version > QrSpecConst.max_version
         raise QrError(QrError.invalid_version, @i"$(version) is not supported")
      end

      arrayLength = version + 1

      if self.frames == nil
         self.frames = arrayBuffer(arrayLength, nil)
      elif len(self.frames) < arrayLength
         arrayResize(self.frames, arrayLength)
      end

      if self.frames[version] == nil
         if cacheDir
             filename = cacheDir + "/" + FrameBaseName + "_" + version + ".dat"

            if fileType(cacheDir) == FileStat.NOTFOUND
               dirMake(cacheDir, true)
               fileChmod(cacheDir, 0755)
            end

            if fileType(filename) != FileStat.NOTFOUND
               inputStream = InputStream(filename)
               deserialized = deserialize(inputStream)
               inputStream.close()
               self.frames[version] = deserialized
            else
               frame = self._createFrame(version)
               outputStream = OutputStream(filename)
               serialize(frame, outputStream)
               outputStream.close()
               self.frames[version] = frame
            end
         else
            self.frames[version] = self._createFrame(version)
         end
      end

      if self.frames[version] == nil
         raise QrError(QrError.encoding_error, i"error creating frame")
      end

      return self.frames[version]
   end

   function rsBlockNum(spec); return spec[0] + spec[3]; end
   function rsBlockNum1(spec); return spec[0]; end
   function rsDataCodes1(spec); return spec[1]; end
   function rsEccCodes1(spec); return spec[2]; end
   function rsBlockNum2(spec); return spec[3]; end
   function rsDataCodes2(spec); return spec[4]; end
   function rsEccCodes2(spec); return spec[2]; end
   function rsDataLength(spec); return (spec[0] * spec[1]) + (spec[3] * spec[4]); end
   function rsEccLength(spec); return (spec[0] + spec[3]) * spec[2]; end

   /* private part */

   function _applyPattern(frame, x, y, pattern, length)
      substr = strFront(frame[y], x)
      srcLength = len(frame[y])
      parLength = len(substr)

      if length == nil
         parLength += len(pattern)
         substr += pattern
      elif length > 0
         parLength += length
         substr += strFront(pattern, length)
      end

      delta = srcLength - parLength
      if delta > 0: substr += strBack(frame[y], delta)

      return (frame[y] = substr)
   end

   function _createFrame(version)
      width = QrCapacity[version][QrCapConst.width]
      frame = arrayBuffer(width)
      for i in [0:width]; frame[i] = "\x0" * width; end

      self.putFinderPattern(frame, 0, 0)
      self.putFinderPattern(frame, width - 7, 0)
      self.putFinderPattern(frame, 0, width - 7)

      offset = width - 7
      for y in [0:7]
         frame[y][7] = "\xc0"
         frame[y][width - 8] = "\xc0"
         frame[offset][7] = "\xc0"
         offset++
      end

      pattern = "\xc0" * 8
      self._applyPattern(frame, 0, 7, pattern)
      self._applyPattern(frame, width - 8, 7, pattern)
      self._applyPattern(frame, 0, width - 8, pattern)

      pattern = "\x84" * 9
      self._applyPattern(frame, 0, 8, pattern)
      self._applyPattern(frame, width - 8, 8, pattern, 8)

      offset = width - 8
      for y in [0:8]
         frame[y][8] = "\x84"
         frame[offset][8] = "\x84"
         offset++
      end

      for i in [1:width - 15]
         frame[6][7 + i] = frame[7 + i][6] = chr(0x90 || (i && 1))
      end

      self._putAlignmentPattern(version, frame, width)

      if version >= 7
         versionPattern = self.getVersionPattern(version)

         v = versionPattern
         for x in [0:6]
            for y in [0:3]
               frame[(width - 11) + y][x] = chr(0x88 || (v && 1))
               v >>= 1
            end
         end

         v = versionPattern
         for y in [0:6]
            for x in [0:3]
               frame[y][x + (width - 11)] = chr(0x88 || (v && 1))
               v >>= 1
            end
         end
      end

      frame[width - 8][8] = "\x81"
      return frame
   end

   function _putAlignmentPattern(version, frame, width)
      if version < 2: return

      d = QrAlignmentPattern[version][1] - QrAlignmentPattern[version][0]
      if d < 0
         w = 2
      else
         w = int((width - QrAlignmentPattern[version][0]) / d + 2)
      end

      if w * w - 3 == 1
         x = QrAlignmentPattern[version][0]
         y = QrAlignmentPattern[version][0]
         self.putAlignmentMarker(frame, x, y)
         return
      end

      x = QrAlignmentPattern[version][0]
      for i in [1:w - 1]
         self.putAlignmentMarker(frame, 6, x)
         self.putAlignmentMarker(frame, x, 6)
         x += d
      end

      y = QrAlignmentPattern[version][0]
      for i in [0:w - 1]
         x = QrAlignmentPattern[version][0]
         for j in [0:w - 1]
            self.putAlignmentMarker(frame, x, y)
            x += d
         end
         y += d
      end
   end
end
