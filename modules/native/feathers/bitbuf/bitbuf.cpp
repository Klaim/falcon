/*
   FALCON - The Falcon Programming Language.
   FILE: bitbuf.cpp

   Buffering extensions
   Bit-perfect buffer class
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Mon, 08 Jul 2013 13:22:03 +0200

   -------------------------------------------------------------------
   (C) Copyright 2013: the FALCON developers (see list in AUTHORS file)

         Licensed under the Falcon Programming Language License,
      Version 1.1 (the "License"); you may not use this file
      except in compliance with the License. You may obtain
      a copy of the License at

         http://www.falconpl.org/?page_id=license_1_1

      Unless required by applicable law or agreed to in writing,
      software distributed under the License is distributed on
      an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      KIND, either express or implied. See the License for the
      specific language governing permissions and limitations
      under the License.

*/

/** \file
   Main module file, providing the module object to
   the Falcon engine.
*/

#include <falcon/module.h>
#include <falcon/class.h>
#include <falcon/ov_names.h>
#include "bitbuf_ext.h"
#include "bitbuf_mod.h"
#include "buffererror.h"

/*#
@module feathers.bitbuf Bit-orieted read/write buffer.
@brief

This module provides a bit-precise stream-like growable memory buffer class
and support classes.

This is a rewrite of the Falcon 0.9 bufext feathers module.

@beginmodule feathers.bitbuf
*/


/*#
@class BitBuf
@brief Flexible memory buffer optimized for bit-precise binary mangling

The BitBuf class is a bit-precise stream-like growable memory buffer class.
It is designed to receive multiple writes efficiently and then to provide
an efficient random access to the written bits.

As long as the current
write position and data to be written are byte aligned, writes are performed
byte-wise (and so, very efficiently). The write performance may degrade when
there is the need to write a wide amount of data starting from an arbitrary
bit.

Data is written in a sequence of memory chunks that can be allocated in
a constant time. Adding more data doesn't require to grow and copy the
whole buffer.

Read and read/write pointer move operations cause a "consolidation", that
consists into writing all the data on a sequential memory area. This data
can be efficiently written when it's accessed byte-wise. Arbitrary bit
access and fetching of multiple bytes starting from an arbitrary bit
positions are much less efficient.

@note BitBuf can still receive new appended data after consolidation. When
subsequent read or pointer move operations are required, a new consolidation
will take place.

The BitBuf class provides support to write and read 8, 16, 32 and 64 bits
integers at from/to arbitrary bit positions in the stream. Also,
support for byte endian order transformation is provided.

\section BitBuf_clone Cloning

BitBuf class supports the @a BOM.clone operation; however, clone operations
cause consolidation of the source BitBuf.

\section BitBuf_stream Serialization

BitBuf class supports serialization via @a Storer. Once stored, the BitBuf
can be restored elsewhere, regenerating a BitBuf instance that can still
be written and enlarged.

\section BitBuf_sync Synchronization.

BitBuf provides a simple inner synchronization mutex that prevents
concurrent writes to break the buffer. However, it's necessary to use a
script level @a Shared resource (for instance, a @a Mutex) to coordinate
multiple writes that are to be seen atomically by the script.

*/


/*#
@class BufferError
@brief Error generated by buffer I/O related failures.
@optparam code A numeric error code.
@optparam description A textual description of the error code.
@optparam extra A descriptive message explaining the error conditions.
@from Error code, description, extra

*/

Falcon::Module *bufext_module_init(void)
{
   // initialize the module
   Falcon::Module *self = new Falcon::Module("bitbuf");

   //============================================================
   // API declarations
   //

   self->addConstant( "NATIVE_ENDIAN", (Falcon::int64)Falcon::Ext::BitBuf::e_endian_same );
   self->addConstant( "LITTLE_ENDIAN", (Falcon::int64)Falcon::Ext::BitBuf::e_endian_little );
   self->addConstant( "BIG_ENDIAN",    (Falcon::int64)Falcon::Ext::BitBuf::e_endian_big );
   self->addConstant( "REVERSE_ENDIAN",(Falcon::int64)Falcon::Ext::BitBuf::e_endian_reverse );

   Falcon::Class *bitbuf = Falcon::Ext::init_classbitbuf();

   self->addMantra( bitbuf, true );
   self->addMantra( new Falcon::Ext::ClassBitBufError, true );

   return self;
}

FALCON_MODULE_DECL
{
    return bufext_module_init();
}

/* end of bitbuf.cpp */
