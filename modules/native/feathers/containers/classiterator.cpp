/* -------------------------------------------------------------------
 * FALCON - The Falcon Programming Language.
 * FILE: classiterator.cpp
 *
 * -------------------------------------------------------------------
 * Author: Giancarlo Niccolai
 * Begin: Sat, 01 Feb 2014 12:56:12 +0100
 *
 * -------------------------------------------------------------------
 * (C) Copyright 2014: The above AUTHOR
 *
 * See LICENSE file for licensing details.
 */

#define SRC "modules/native/feathers/containers/classiterator.cpp"

#include "classiterator.h"
#include "iterator_mod.h"
#include "container_mod.h"
#include "classcontainer.h"
#include "errors.h"

#include <falcon/pstep.h>
#include <falcon/function.h>
#include <falcon/vmcontext.h>
#include <falcon/itemarray.h>
#include <falcon/string.h>
#include <falcon/item.h>


/*#
 @beginmodule containers
*/

namespace Falcon {
using namespace Mod;

namespace {
//=======================================================================================
// Class Iterator
//

/*#
 @class Iterator
 @brief Class generated by container for iterations.

 This class cannot be directly instantiated.
 @prop hasCurrent A current element has been loaded, and @a Iterator.current() can be called.
 @prop hasNext The @a Iterator.next() member can be called.
 @prop isReverse True if this iterator is moving from the last element to the first.
*/

/*#
 @method next Iterator
 @brief Advance the iterator and return the next element.
 @return The next element.
 @raise ContainerError if there isn't a next element.
*/
FALCON_DECLARE_FUNCTION( next, "" )
FALCON_DEFINE_FUNCTION_P1( next )
{
   Iterator* cnt = ctx->tself<Iterator>();
   Item item;
   if( ! cnt->next(item) )
   {
      throw FALCON_SIGN_ERROR( ContainerError, FALCON_ERROR_CONTAINERS_EOF );
   }
   ctx->returnFrame(item);
}

/*#
 @method current Iterator
 @brief Get the current element pointed by the iterator.
 @return The current element that is the element that was last returned by next.
 @raise ContainerError if there isn't a current element.

 If the container is an associative container, the value associated with the key
 is returned instead.
*/
FALCON_DECLARE_FUNCTION( current, "" )
FALCON_DEFINE_FUNCTION_P1( current )
{
   Iterator* cnt = ctx->tself<Iterator>();
   Item item;
   if( ! cnt->current(item) )
   {
      throw FALCON_SIGN_ERROR( ContainerError, FALCON_ERROR_CONTAINERS_EOF );
   }
   ctx->returnFrame(item);
}


/*#
 @method reset Iterator
 @brief Rewinds the iterator to the first position.
*/
FALCON_DECLARE_FUNCTION( reset, "" )
FALCON_DEFINE_FUNCTION_P1( reset )
{
   Iterator* cnt = ctx->tself<Iterator>();
   cnt->reset();
   ctx->returnFrame();
}


/*#
 @method erase Iterator
 @brief Remove the current element,.
 @raise ContainerError if there isn't a next element.

 The iterator is advanced to the next element.
*/
FALCON_DECLARE_FUNCTION( erase, "" )
FALCON_DEFINE_FUNCTION_P1( erase )
{
   Iterator* iter = ctx->tself<Iterator>();
   Container* cnt = iter->container();

   if( ! cnt->erase(iter) )
   {
      throw FALCON_SIGN_ERROR( ContainerError, FALCON_ERROR_CONTAINERS_EOF );
   }
   ctx->returnFrame();
}

/*#
 @method insert Iterator
 @brief Inserts one or more items at the current position.
 @param item The items to be inserted
 @optparam ... more items to be inserted
 @raise ContainerError If the current container doesn't suppor positional inertions.

*/
FALCON_DECLARE_FUNCTION( insert, "item:X, ..." )
FALCON_DEFINE_FUNCTION_P( insert )
{
   if( pCount == 0 )
   {
      throw paramError(__LINE__, SRC);
   }

   Iterator* iter = ctx->tself<Iterator>();
   Container* cnt = iter->container();

   for( int32 i = 0; i < pCount; ++i )
   {
      if( ! cnt->insert( iter, *ctx->param(i) ) )
      {
         throw FALCON_SIGN_ERROR( ContainerError, FALCON_ERROR_CONTAINERS_NOINS );
      }
   }
   ctx->returnFrame();
}


static void get_hasCurrent(const Class*, const String&, void* inst, Item& value )
{
   Iterator* iter = static_cast<Iterator*>(inst);
   Item current;
   value.setBoolean(iter->current(current));
}

static void get_hasNext(const Class*, const String&, void* inst, Item& value )
{
   Iterator* iter = static_cast<Iterator*>(inst);
   value.setBoolean(iter->hasNext());
}

static void get_isReverse(const Class*, const String&, void* inst, Item& value )
{
   Iterator* iter = static_cast<Iterator*>(inst);
   value.setBoolean(iter->isReverse());
}

}


ClassIterator::ClassIterator():
         Class("Iterator")
{
   addMethod( new FALCON_FUNCTION_NAME(next) );
   addMethod( new FALCON_FUNCTION_NAME(current) );
   addMethod( new FALCON_FUNCTION_NAME(insert) );
   addMethod( new FALCON_FUNCTION_NAME(erase) );
   addMethod( new FALCON_FUNCTION_NAME(reset) );

   addProperty("hasCurrent", &get_hasCurrent );
   addProperty("hasNext", &get_hasNext );
   addProperty("isReverse", &get_isReverse );
}


ClassIterator::~ClassIterator()
{}


void ClassIterator::describe( void* instance, String& target, int, int ) const
{
   Iterator* iter = static_cast<Iterator*>(instance);
   target = "Iterator for " + iter->container()->handler()->name();
}


void* ClassIterator::createInstance() const
{
   return 0;
}

void ClassIterator::dispose( void* instance ) const
{
   Iterator* iter = static_cast<Iterator*>(instance);
   delete iter;
}

void* ClassIterator::clone( void* instance ) const
{
   Iterator* iter = static_cast<Iterator*>(instance);
   return iter->clone();
}

void ClassIterator::gcMarkInstance( void* instance, uint32 mark ) const
{
   Iterator* iter = static_cast<Iterator*>(instance);
   iter->gcMark(mark);
}

bool ClassIterator::gcCheckInstance( void* instance, uint32 mark ) const
{
   Iterator* iter = static_cast<Iterator*>(instance);
   return iter->currentMark() >= mark;
}


}

/* end of classiterator.cpp */
