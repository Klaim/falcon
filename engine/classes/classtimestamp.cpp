/* FALCON - The Falcon Programming Language.
 * FILE: classtimestamp.cpp
 * 
 * Extra functions
 * Interface extension functions
 * -------------------------------------------------------------------
 * Author: Giancarlo Niccolai
 * Begin: Sun, 24 Feb 2013 22:37:06 +0100
 * 
 * -------------------------------------------------------------------
 * (C) Copyright 2013: FALCON AUTHORS
 * 
 * Licensed under the Falcon Programming Language License,
 * Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain
 * a copy of the License at
 * 
 * http://www.falconpl.org/?page_id=license_1_1
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#undef SRC
#define SRC "engine/classes/classtimestamp.cpp"

#include <falcon/engine.h>
#include <falcon/vmcontext.h>
#include <falcon/timestamp.h>
#include <falcon/function.h>
#include <falcon/classes/classtimestamp.h>

#include <falcon/error.h>
#include <falcon/stderrors.h>
#include <falcon/vmcontext.h>

namespace Falcon { 

namespace  {
/*#
    @class TimeStamp
    @brief Representation of times in the system.
    @optparam msSinceEpoch Relative number of milliseconds since epoch.

    The TimeStamp class can be used to retrieve the system time and date.
    It is also used by other entities in the RTL to return informations
    about the date (i.e. the @a FileStat).

    The instance is created empty and unset, unless the @b date parameter
    is provided. In that case, the new instance is copied from a previously
    created one.

    The provided parameter may also be a "long opaque format" generated by
    the @a TimeStamp.toLongFormat method.

    To update the instance with the current system time, use @a TimeStamp.currentTime

    @prop year Timestamp year, absolute value.
    @prop month Month of the year, starting from 1.
    @prop day Day of month, starting from 1.
    @prop hour Hour in range 0 - 23.
    @prop minute Minute in range 0 - 59.
    @prop second Second in range 0 - 59.
    @prop msec Millisecond in range 0 - 999.
    @prop timezone A timezone. Setting this property changes the reported timestamp.
    @prop displacement The displacement with respect to UTC time in minutes. Setting this property changes the reported timestamp.

    @prop dayOfWeek Day of the week (0=monday, 6=sunday)
    @prop weekOfYear (1-53)
    @prop dayOfYear Day of the year.
    @prop msSinceEpoch Milliseconds elapsed since epoch (1/1/1970);
             can be used to compare, sum or subtract dates, and can be negative. It is relative to set timezone (set timezone to
             none or UTC for neutral time and epoch transformation).

    @prop msInSeconds (static) Constant keeping the number of milliseconds in seconds (1000)
    @prop msInMinutes (static) Constant keeping the number of milliseconds in seconds (60,000)
    @prop msInHours (static) Constant keeping the number of milliseconds in hours (3,600,000)
    @prop msInDays (static) Constant keeping the number of milliseconds in days (3,600,000*24)

@note This class has type dignity and a numeric type id.

@section timestamp_timezone Time zones
   Timezone are a symbolic representation of a fixed amount of displacement times.

   The following constants define a timezone:

 - local: Special local zone (unassigned, but relative to current location).
 - UTC or GMT
 - E1 to E12 (+1h to +12h)

 - W1 to W12 (-1h to -12h)
 - EDT
 - EST
 - CDT
 - CST
 - MDT
 - MST
 - PDT
 - PST

 - NFT
 - ACDT
 - ACST
 - HAT
 - NST

 - NONE: No/neutral/unknown timezone.

*/

FALCON_DECLARE_FUNCTION(_constructor, "msSinceEpoch:[N]")
void Function__constructor::invoke ( ::Falcon::VMContext* ctx, int32 )
{
   Item *date = ctx->param(0);
   TimeStamp* self = static_cast<TimeStamp*>(ctx->self().asInst());

   if ( date != 0 ) {
      if( date->isOrdinal()) {
         self->date().addMilliseconds( date->forceInteger() );
      }
      else {
         throw paramError(__LINE__, SRC);
      }
   }
   ctx->returnFrame(ctx->self());
}

/*#
   @method current TimeStamp
   @brief Fills this item with current time.
   @return self

   Fills the value of the date with the current local time on the system.
   The timezone is set accordingly
*/
FALCON_DECLARE_FUNCTION(setCurrent, "")
void Function_setCurrent::invoke ( ::Falcon::VMContext* ctx, int32 )
{
   TimeStamp* self = static_cast<TimeStamp*>(ctx->self().asInst());
   self->currentTime();
   ctx->returnFrame(Item(methodOf(),self));
}


/*#
   @method strftime TimeStamp
   @brief Converts the current timestamp to a string.
   @param format Format used to render this timestamp.
   @return The format expanded.


*/
FALCON_DECLARE_FUNCTION(strftime, "format:S")
void Function_strftime::invoke ( ::Falcon::VMContext* ctx, int32 )
{
   TimeStamp* self = static_cast<TimeStamp*>(ctx->self().asInst());

   Item* i_format = ctx->param(0);
   if( i_format == 0 || ! i_format->isString() )
   {
      throw paramError( __LINE__, SRC );
   }

   const String& format = *i_format->asString();
   String* str = new String;

   if( ! self->strftime(*str, format, 0) )
   {
      delete str;
      throw FALCON_SIGN_XERROR( ParamError, e_param_range, .extra("Invalid strftime format") );
   }

   ctx->returnFrame(FALCON_GC_HANDLE(str));
}


/*#
 @method compare TimeStamp
 @brief Compare another TimeStamp against this one.
 @param ts The TimeStamp to be compared.
 @return -1, 0 or 1.

 The given timestamp is compared to this object. If this object is greater than
 the target timestamp, 1 is returned; if it's smaller (before), -1 is returned.
 If the two timestamp are exactly the same, 0 is returned.
*/
FALCON_DECLARE_FUNCTION(compare, "ts:TimeStamp")
void Function_compare::invoke ( ::Falcon::VMContext* ctx, int32 )
{
   Item* i_ts = ctx->param(0);

   Class* tsCls = 0;
   void* data = 0;
   if( i_ts == 0 || (! i_ts->asClassInst(tsCls, data)) || ! tsCls->isDerivedFrom(methodOf()) )
   {
      throw paramError(__LINE__,SRC);
   }

   TimeStamp* other = static_cast<TimeStamp*>(tsCls->getParentData(methodOf(),data));
   TimeStamp* self = static_cast<TimeStamp*>(ctx->self().asInst());
   ctx->returnFrame( self->compare(*other) );
}


/*#
 @method fromRFC2822 TimeStamp
 @brief Sets this date from a RFC 2822 string.
 @param date A string containing a date in RFC 2822 format.
 @raise ParamError if the input string is not valid.
 @return self

 RFC 2822 format is the textual descriptive format used in Internet
 transactions. It's composed with:
 - Day of the week signature
 - Month signature
 - Day in the current month
 - 4 digits year
 - Time in HH:MM:SS format
 - Timezone name or displacement.

 A sample looks like:
 @code
    Thu, 01 May 2008 23:52:34 +0200
 @endcode

 If the given string is not a valid timestamp in the RFC 2822 format, the function
 will return false.

 @note Part of this timestamp may be corrupted after a faulty try; be sure to save
 this TimeStamp before trying the conversion, if it is needed.
*/
FALCON_DECLARE_FUNCTION(fromRFC2822, "date:String")
void Function_fromRFC2822::invoke ( ::Falcon::VMContext* ctx, int32 )
{
 Item *i_string = ctx->param(0);
 if( i_string == 0 || ! i_string->isString() )
 {
    throw paramError(__LINE__, SRC);
 }

 TimeStamp* self = static_cast<TimeStamp*>(ctx->self().asInst());
 bool ok = TimeStamp::fromRFC2822( *self, *i_string->asString() );
 if( !ok )
 {
    throw FALCON_SIGN_XERROR( ParamError, e_param_range, .extra("Invalid RFC2822 format") );
 }

 ctx->returnFrame(ctx->self());
}


/*#
 @method toRFC2822 TimeStamp
 @brief Format this TimeStamp in RFC 2822 format.
 @return A string with this timestamp converted, or nil if this TimeStamp is not valid.

 @see TimeStamp.fromRFC2822
*/
FALCON_DECLARE_FUNCTION(toRFC2822, "")
void Function_toRFC2822::invoke ( ::Falcon::VMContext* ctx, int32 )
{
   TimeStamp* self = static_cast<TimeStamp*>(ctx->self().asInst());

   String *str = new String( String(32) );
   self->toRFC2822( *str );
   ctx->returnFrame(FALCON_GC_HANDLE(str));
}


/*#
 @method changeZone TimeStamp
 @brief Change the time zone in this timestamp, maintaing the same absolute time value.
 @param zone The new time zone.

 This methods shifts forward or backward this timestamp according with the relative
 shift between the @a TimeStamp.timezone member and the @b zone parameter. After the
 shift is performed, the new zone is set in the timezone property of this object.

 For example, to convert the local time in GMT:
 @code
    now = currentTime()
    > "Local time: ", now
    now.changeZone( TimeStamp.GMT )
    > "GMT: ", now
 @endcode

 As assigning a new time zone to the @b timezone property is not subject to any control,
 it is possible to set an arbitrary time and timezone by normal assignment, and then
 convert it to another time zone using this method.

 For example:
 @code
    a_gmt_time = decodeTime( "..." )
    // let's say we know the timestamp is GMT.
    a_gmt_time.timezone = TimeStamp.GMT

    // to convert in local time:
    localTime = a_gmt_time
    localTime.changeZone( TimeStamp.local )
 @endcode

 The "local" zone is a special zone which is automatically converted in the system
 timezone.
*/
FALCON_DECLARE_FUNCTION(changeZone, "tz:N")
void Function_changeZone::invoke ( ::Falcon::VMContext* ctx, int32 )
{
   Item *i_tz = ctx->param(0);
   if( i_tz == 0 || ! i_tz->isOrdinal() )
   {
      throw paramError( __LINE__, SRC );
   }

   int tz = (int) i_tz->forceInteger();
   if ( tz < 0 || tz >= 32 )
   {
      throw new ParamError( ErrorParam( e_param_range, __LINE__, SRC ).origin( ErrorParam::e_orig_runtime ).
               extra( "Invalid timezone" ) );
   }

   TimeStamp* self = static_cast<TimeStamp*>(ctx->self().asInst());

   self->changeTimeZone( (TimeStamp::TimeZone) tz );
   ctx->returnFrame();
}



/*#
 @method changeDisplacement TimeStamp
 @brief Change the zone displacement in this timestamp, maintaing the same absolute time value.
 @param disp The new displacement, in minutes.

 This methods shifts forward or backward this timestamp according with the relative
 shift between the @a TimeStamp.displacement member and the @b disp parameter. After the
 shift is performed, the new displacement is set.

 For example, to convert the local time in UTC:
 @code
    now = currentTime()
    > "Local time: ", now
    now.changeDisplacement( -120 )
    > "2 hours ago: ", now
 @endcode

 As assigning a new time zone to the @b timezone property is not subject to any control,
 it is possible to set an arbitrary time and timezone by normal assignment, and then
 convert it to another time zone using this method.

 For example:
 @code
    a_gmt_time = decodeTime( "..." )
    // let's say we know the timestamp is UTC.
    a_gmt_time.displacement = 0

    // to convert in to UTC+2
    localTime = a_gmt_time
    localTime.changeDisplacement( 120 )
 @endcode

The static method TimeStamp.getTZDisplacement can be used to determine the displacement
of any codified time zone, including the "local" time zone.
*/
FALCON_DECLARE_FUNCTION(changeDisplacement, "disp:N")
void Function_changeDisplacement::invoke ( ::Falcon::VMContext* ctx, int32 )
{
   Item *i_tz = ctx->param(0);
   if( i_tz == 0 || ! i_tz->isOrdinal() )
   {
      throw paramError( __LINE__, SRC );
   }

   int tz = (int) i_tz->forceInteger();
   TimeStamp* self = static_cast<TimeStamp*>(ctx->self().asInst());
   if ( ! self->changeDisplacement( tz ) )
   {
      throw new ParamError( ErrorParam( e_param_range, __LINE__, SRC ).origin( ErrorParam::e_orig_runtime ).
               extra( "Invalid displacement" ) );
   }

   ctx->returnFrame();
}

/*#
 @method changeDST TimeStamp
 @brief Change the zone DST (daylight saving time) status.
 @param dst True to set DST displacement.

 This methods shifts forward or backward this timestamp according with the relative
 shift between the previous and set values of the DST status.
*/
FALCON_DECLARE_FUNCTION(changeDST, "dst:B")
void Function_changeDST::invoke ( ::Falcon::VMContext* ctx, int32 )
{
   Item *i_tz = ctx->param(0);
   if( i_tz == 0 )
   {
      throw paramError( __LINE__, SRC );
   }

   TimeStamp* self = static_cast<TimeStamp*>(ctx->self().asInst());
   self->changeDST( i_tz->isTrue() );
   ctx->returnFrame();
}


//typedef void (*setter)( const Class* cls, const String& name, void *instance, const Item& value );
// typedef void (*getter)( const Class* cls, const String& name, void *instance, Item& value );
 /*#
    @property isLeapYear TimeStamp
    @brief Checks if the year in this TimeStamp is a LeapYear.

    Returns true if year member of this timestamp is leap, false otherwise.
    Calculation is reliable only for years past 1700.
 */
static void get_isLeapYear( const Class*, const String&, void *instance, Item& value )
{
   TimeStamp* self = static_cast<TimeStamp*>(instance);
   value.setBoolean(self->isLeapYear());
}

 /*#
    @property dayOfWeek TimeStamp
    @brief Returns the weekday in which this TimeStamp falls.

    This is the day of week calculated on this object. The returned number is in
    range 0 to 6 included, 0 being Sunday and 6 being Saturday. The function is
    reliable only for dates past January the first 1700.
 */
static void get_dayOfWeek( const Class*, const String&, void *instance, Item& value )
{
   TimeStamp* self = static_cast<TimeStamp*>(instance);
   value.setInteger(self->dayOfWeek());
}

/*#
   @property dayOfYear TimeStamp
   @brief Returns the days passed since the beginning of the year in this TimeStamp

   Returns the day in the year represented by the current object. The returned
   number will range between 1 for January the first and 365 or 366 (if the current year is
   leap) for December the 31th.
*/
static void get_dayOfYear( const Class*, const String&, void *instance, Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  value.setInteger(self->dayOfYear());
}

static void get_weekOfYear( const Class*, const String&, void *instance, Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  value.setInteger(self->weekOfYear(true));
}


static void get_msSinceEpoch( const Class*, const String&, void *instance, Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  value.setInteger(self->msSinceEpoch());
}

static void set_msSinceEpoch( const Class*, const String&, void *instance, const Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  if( ! value.isOrdinal() )
  {
     throw FALCON_SIGN_XERROR(ParamError, e_inv_prop_value, .extra("I"));
  }

  self->msSinceEpoch( value.forceInteger() );
}

static void get_year( const Class*, const String&, void *instance, Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  value.setInteger(self->year());
}

static void set_year( const Class*, const String&, void *instance, const Item& value )
{
   TimeStamp* self = static_cast<TimeStamp*>(instance);
   if( ! value.isOrdinal() )
   {
      throw FALCON_SIGN_XERROR(ParamError, e_inv_prop_value, .extra("I"));
   }
   self->year(value.forceInteger());
}

static void get_month( const Class*, const String&, void *instance, Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  value.setInteger(self->month());
}

static void set_month( const Class*, const String&, void *instance, const Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  if( ! value.isOrdinal() )
  {
     throw FALCON_SIGN_XERROR(ParamError, e_inv_prop_value, .extra("I"));
  }
  if( ! self->month(value.forceInteger()) )
  {
     throw FALCON_SIGN_XERROR(ParamError, e_inv_prop_value, .extra("Month out of range"));
  }
}

static void get_day( const Class*, const String&, void *instance, Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  value.setInteger(self->day());
}

static void set_day( const Class*, const String&, void *instance, const Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  if( ! value.isOrdinal() )
  {
     throw FALCON_SIGN_XERROR(ParamError, e_inv_prop_value, .extra("I"));
  }
  if( ! self->day(value.forceInteger()) )
  {
     throw FALCON_SIGN_XERROR(ParamError, e_inv_prop_value, .extra("Day out of range"));
  }
}

static void get_hour( const Class*, const String&, void *instance, Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  value.setInteger(self->hour());
}

static void set_hour( const Class*, const String&, void *instance, const Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  if( ! value.isOrdinal() )
  {
     throw FALCON_SIGN_XERROR(ParamError, e_inv_prop_value, .extra("I"));
  }
  if( ! self->hour(value.forceInteger()) )
  {
     throw FALCON_SIGN_XERROR(ParamError, e_inv_prop_value, .extra("Hour out of range"));
  }
}


static void get_minute( const Class*, const String&, void *instance, Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  value.setInteger(self->minute());
}

static void set_minute( const Class*, const String&, void *instance, const Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  if( ! value.isOrdinal() )
  {
     throw FALCON_SIGN_XERROR(ParamError, e_inv_prop_value, .extra("I"));
  }
  if( ! self->minute(value.forceInteger()) )
  {
     throw FALCON_SIGN_XERROR(ParamError, e_inv_prop_value, .extra("Minute out of range"));
  }
}


static void get_second( const Class*, const String&, void *instance, Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  value.setInteger(self->second());
}

static void set_second( const Class*, const String&, void *instance, const Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  if( ! value.isOrdinal() )
  {
     throw FALCON_SIGN_XERROR(ParamError, e_inv_prop_value, .extra("I"));
  }
  if( ! self->second(value.forceInteger()) )
  {
     throw FALCON_SIGN_XERROR(ParamError, e_inv_prop_value, .extra("Second out of range"));
  }
}


static void get_millisecond( const Class*, const String&, void *instance, Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  value.setInteger(self->msec());
}

static void set_millisecond( const Class*, const String&, void *instance, const Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  if( ! value.isOrdinal() )
  {
     throw FALCON_SIGN_XERROR(ParamError, e_inv_prop_value, .extra("I"));
  }
  if( ! self->msec(value.forceInteger()) )
  {
     throw FALCON_SIGN_XERROR(ParamError, e_inv_prop_value, .extra("Millisecond out of range"));
  }
}


static void get_displacement( const Class*, const String&, void *instance, Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  value.setInteger(self->displacement());
}

static void set_displacement( const Class*, const String&, void *instance, const Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  if( ! value.isOrdinal() )
  {
     throw FALCON_SIGN_XERROR(ParamError, e_inv_prop_value, .extra("I"));
  }
  if( ! self->displacement(value.forceInteger()) )
  {
     throw FALCON_SIGN_XERROR(ParamError, e_inv_prop_value, .extra("Millisecond out of range"));
  }
}


static void get_dst( const Class*, const String&, void *instance, Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  value.setBoolean(self->isDST());
}

static void set_dst( const Class*, const String&, void *instance, const Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  self->setDST(value.isTrue());
}


static void get_timezone( const Class*, const String&, void *instance, Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  value.setInteger(self->timeZone());
}

static void set_timezone( const Class*, const String&, void *instance, const Item& value )
{
  TimeStamp* self = static_cast<TimeStamp*>(instance);
  if( ! value.isOrdinal() )
  {
     throw FALCON_SIGN_XERROR(ParamError, e_inv_prop_value, .extra("I"));
  }
  int32 tz = value.forceInteger();

  if( tz < 0 || tz > 32 )
  {
     throw FALCON_SIGN_XERROR(ParamError, e_inv_prop_value, .extra("Timezone out of range"));
  }

  self->timeZone((TimeStamp::TimeZone)tz);
}



/*#
 @method getTZDisplacement TimeStamp
 @brief (static) Returns the distance in minutes from the GMT time of a given timezone
 @param tz A time zone code.
 @return A relative time distance in minutes.

 This static method, callable directly on the TimeZone class, returns the
 time displacement of a determined time zone with respect to GMT.
*/
FALCON_DECLARE_FUNCTION(getTZDisplacement, "tz:N")
void  Function_getTZDisplacement::invoke ( ::Falcon::VMContext* ctx, int32 )
{
   // verify that the string is valid
   Item *i_tz = ctx->param(0);
   if( i_tz == 0 || ! i_tz->isOrdinal() )
   {
      throw paramError(__LINE__, SRC);
   }

   int tz = (int) i_tz->forceInteger();
   if ( tz < 0 || tz >= 32 )
   {
      throw new ParamError( ErrorParam( e_param_range, __LINE__ ).origin( ErrorParam::e_orig_runtime ).
               extra( "Invalid timezone" ) );
   }

   int16 hours, minutes;
   TimeStamp::getTZDisplacement( (TimeStamp::TimeZone) tz, hours, minutes );
   ctx->returnFrame( (int64) (hours *60 + minutes) );
}

 /*#
    @method getTZName TimeStamp
    @brief (static) Returns a descriptive string naming the required timezone.
    @param tz A time zone code.
    @optparam semantic Return a symbolic name for those zones having one.
    @optparam dst Return the symbolic zone name during the daylight saving time.
    @return A timezone name.

    This static method, callable directly on the TimeZone class, returns a
    RFC 2822 compliant timezone name, given a timezone code. The "name" is
    in the format "+/-hhmm", unless semantic is set to true; in that case,
    if the zone has a symbolic name (as UTC, EDT, PST etc.),
    that name is returned instead.

 */

FALCON_DECLARE_FUNCTION(getTZName, "tz:N,semantic:[B],dst:[B]")
void  Function_getTZName::invoke ( ::Falcon::VMContext* ctx, int32 pCount )
{
   Item *i_tz = ctx->param(0);
   if( i_tz == 0 || ! i_tz->isOrdinal() )
   {
      throw paramError(__LINE__, SRC);
   }

   int tz = (int) i_tz->forceInteger();
   if ( tz < 0 || tz >= 32 )
   {
      throw new ParamError( ErrorParam( e_param_range, __LINE__ ).origin( ErrorParam::e_orig_runtime ).
               extra( "Invalid timezone" ) );
   }

   bool bSemantic = false;
   if( pCount > 1 )
   {
      bSemantic = ctx->param(1)->isTrue();
   }

   bool bDst = false;
   if( pCount > 2 )
   {
      bDst = ctx->param(2)->isTrue();
   }

   ctx->returnFrame( FALCON_GC_HANDLE(new String(  TimeStamp::getRFC2822_ZoneName( (TimeStamp::TimeZone) tz, bSemantic, bDst ) ) ) );
 }

/*#
    @property localZone TimeStamp
    @brief (static) Return local time zone code.
    @return A time zone code corresponding to the system local timezone.

    To get a descriptive name of local timezone, use:

    @code
       TimeZone.getName( TimeZone.getLocal() )
    @endcode
*/

static void get_localZone( const Class*, const String&, void *, Item& value )
{
   value.setInteger( (int64) TimeStamp::getLocalTimeZone() );
}


/*#
 @method parseRFC2822 TimeStamp
 @brief (static) Parses a RFC2822 formatted date and returns a @a TimeStamp instance.
 @param str The string to be parsed
 @return A valid @a TimeStamp instance.
 @raise ParamError if the string is invalid

 @see TimeStamp.fromRFC2822
*/
FALCON_DECLARE_FUNCTION(parseRFC2822, "ts:S")
void Function_parseRFC2822::invoke ( VMContext* ctx, int32 )
{
   // verify that the string is valid
   Item *i_string = ctx->param(0);
   if( i_string == 0 || ! i_string->isString() )
   {
      throw paramError(__LINE__, SRC);
   }

   TimeStamp *ts1 = new TimeStamp;
   if( ! TimeStamp::fromRFC2822( *ts1, *i_string->asString() ) )
   {
      delete ts1;
      throw FALCON_SIGN_XERROR( ParamError, e_param_range, .extra("Invalid RFC2822"));
   }

   ctx->returnFrame( FALCON_GC_STORE(methodOf(), ts1) );
}

/*#
 @method currentTime TimeStamp
 @brief (static) Returns the current system local time as a new @a TimeStamp instance.
 @return A new TimeStamp instance.

 Returns the current system local time as a TimeStamp instance.
 The function can never fail.

 @see TimeStamp.current
*/
FALCON_DECLARE_FUNCTION(currentTime, "ts:S")
void Function_currentTime::invoke ( VMContext* ctx, int32 )
{
   TimeStamp *ts = new TimeStamp;
   ts->currentTime();
   ctx->returnFrame( FALCON_GC_STORE(methodOf(), ts) );
}

}


//=========================================================
// TimeStamp class
//=========================================================


ClassTimeStamp::ClassTimeStamp():
         Class("TimeStamp")
{
   setConstuctor( new Function__constructor );

   addMethod( new Function_changeZone);
   addMethod( new Function_changeDisplacement);
   addMethod( new Function_changeDST);
   addMethod( new Function_compare);
   addMethod( new Function_setCurrent);
   addMethod( new Function_fromRFC2822 );
   addMethod( new Function_strftime );
   addMethod( new Function_toRFC2822 );
   addMethod( new Function_toRFC2822 );

   addMethod( new Function_currentTime, true );
   addMethod( new Function_parseRFC2822, true );
   addMethod( new Function_getTZName, true );
   addMethod( new Function_getTZDisplacement, true );


   addProperty("year", &get_year, &set_year );
   addProperty("month", &get_month, &set_month );
   addProperty("day", &get_day, &set_day );
   addProperty("hour", &get_hour, &set_hour );
   addProperty("minute", &get_minute, &set_minute );
   addProperty("second", &get_second, &set_second );
   addProperty("msec", &get_millisecond, &set_millisecond );
   addProperty("timezone", &get_timezone, &set_timezone );
   addProperty("displacement", &get_displacement, &set_displacement );
   addProperty("msSinceEpoch", &get_msSinceEpoch, &set_msSinceEpoch );
   addProperty("dst", &get_dst, &set_dst );

   addProperty("localZone", &get_localZone, 0, true, false );

   addProperty("isLeapYear", &get_isLeapYear );
   addProperty("dayOfWeek", &get_dayOfWeek );
   addProperty("dayOfYear", &get_dayOfYear );
   addProperty("weekOfYear", &get_weekOfYear );

   addConstant("msInSeconds", 1000 );
   addConstant("msInMinutes", 60*1000 );
   addConstant("msInHours", 60*60*1000 );
   addConstant("msInDays", 24*60*60*1000 );

   addConstant("NONE", TimeStamp::tz_NONE );
   addConstant("UTC", TimeStamp::tz_UTC );
   addConstant("GMT", TimeStamp::tz_UTC );

   addConstant("E1", TimeStamp::tz_UTC_E_1 );
   addConstant("E2", TimeStamp::tz_UTC_E_2 );
   addConstant("E3", TimeStamp::tz_UTC_E_3 );
   addConstant("E4", TimeStamp::tz_UTC_E_4 );
   addConstant("E5", TimeStamp::tz_UTC_E_5 );
   addConstant("E6", TimeStamp::tz_UTC_E_6 );
   addConstant("E7", TimeStamp::tz_UTC_E_7 );
   addConstant("E8", TimeStamp::tz_UTC_E_8 );
   addConstant("E9", TimeStamp::tz_UTC_E_9 );
   addConstant("E10", TimeStamp::tz_UTC_E_10 );
   addConstant("E11", TimeStamp::tz_UTC_E_11 );
   addConstant("E12", TimeStamp::tz_UTC_E_12 );

   addConstant("W1", TimeStamp::tz_UTC_W_1 );
   addConstant("W2", TimeStamp::tz_UTC_W_2 );
   addConstant("W3", TimeStamp::tz_UTC_W_3 );
   addConstant("W4", TimeStamp::tz_UTC_W_4 );
   addConstant("W5", TimeStamp::tz_UTC_W_5 );
   addConstant("W6", TimeStamp::tz_UTC_W_6 );
   addConstant("W7", TimeStamp::tz_UTC_W_7 );
   addConstant("W8", TimeStamp::tz_UTC_W_8 );
   addConstant("W9", TimeStamp::tz_UTC_W_9 );
   addConstant("W10", TimeStamp::tz_UTC_W_10 );
   addConstant("W11", TimeStamp::tz_UTC_W_11 );
   addConstant("W12", TimeStamp::tz_UTC_W_12 );

   addConstant("EDT", TimeStamp::tz_UTC_W_4 );
   addConstant("EST", TimeStamp::tz_UTC_W_5 );
   addConstant("CDT", TimeStamp::tz_UTC_W_5 );
   addConstant("CST", TimeStamp::tz_UTC_W_6 );
   addConstant("MDT", TimeStamp::tz_UTC_W_6 );
   addConstant("MST", TimeStamp::tz_UTC_W_7 );
   addConstant("PDT", TimeStamp::tz_UTC_W_7 );
   addConstant("PST", TimeStamp::tz_UTC_W_8 );

   addConstant("NFT", TimeStamp::tz_NFT );
   addConstant("ACDT", TimeStamp::tz_ACDT );
   addConstant("ACST", TimeStamp::tz_ACST );
   addConstant("HAT", TimeStamp::tz_HAT );
   addConstant("NST", TimeStamp::tz_NST );
}

ClassTimeStamp::~ClassTimeStamp()
{
}

void ClassTimeStamp::dispose( void* instance ) const
{
   TimeStamp* self = static_cast<TimeStamp*>(instance);
   delete self;
}

void* ClassTimeStamp::clone( void* instance ) const
{
   TimeStamp* self = static_cast<TimeStamp*>(instance);
   return new TimeStamp(*self);
}

void* ClassTimeStamp::createInstance() const
{
   return new TimeStamp;
}

void ClassTimeStamp::describe( void* instance, String& target, int, int ) const
{
   TimeStamp* self = static_cast<TimeStamp*>(instance);
   self->toString(target);
}

void ClassTimeStamp::gcMarkInstance( void* instance, uint32 mark ) const
{
   TimeStamp* self = static_cast<TimeStamp*>(instance);
   self->gcMark( mark );
}

bool ClassTimeStamp::gcCheckInstance( void* instance, uint32 mark ) const
{
   TimeStamp* self = static_cast<TimeStamp*>(instance);
   return self->currentMark() >= mark ;
}

void ClassTimeStamp::store( VMContext*, DataWriter* stream, void* instance ) const
{
   TimeStamp* self = static_cast<TimeStamp*>(instance);
   self->store(stream);
}

void ClassTimeStamp::restore( VMContext* ctx, DataReader* stream ) const
{
   TimeStamp * ts = new TimeStamp();
   try
   {
      ts->restore(stream);
      ctx->pushData(Item(this, ts));
   }
   catch(...)
   {
      delete ts;
      throw;
   }
}

}

/* end of classtimestamp.cpp */

