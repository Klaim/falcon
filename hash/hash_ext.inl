/*
   FALCON - The Falcon Programming Language.
   FILE: hash_ext.inl

   Provides multiple hashing algorithms
   Interface extension functions
   -------------------------------------------------------------------
   Author: Maximilian Malek
   Begin: Thu, 25 Mar 2010 02:46:10 +0100

   -------------------------------------------------------------------
   (C) Copyright 2010: The above AUTHOR

         Licensed under the Falcon Programming Language License,
      Version 1.1 (the "License"); you may not use this file
      except in compliance with the License. You may obtain
      a copy of the License at

         http://www.falconpl.org/?page_id=license_1_1

      Unless required by applicable law or agreed to in writing,
      software distributed under the License is distributed on
      an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      KIND, either express or implied. See the License for the
      specific language governing permissions and limitations
      under the License.

*/

/** \file
   Provides multiple hashing algorithms
   Interface extension functions
*/

#include <stdio.h>
#include <falcon/engine.h>
#include "hash_mod.h"
#include "hash_ext.h"
#include "hash_st.h"

namespace Falcon {
namespace Ext {

/*#
   @class HashBase
   @brief Base class for each hash algorithm

   The HashBase class itself does nothing, but provides a set of methods to be overloaded for each
   hash implementation, as well as some shared methods that are the same for each hash, like shared interfaces,
   type conversion, and endian management.

   Hashes are generated by creating an instance of a specialized class.
   Note that each hash class instance, after calling UpdateData() to feed it with stuff,
   has to be Finalize()ed before the actual result can be obtained.
*/


template <class HASH> FALCON_FUNC Hash_init( ::Falcon::VMachine *vm )
{
    vm->self().asObject()->setUserData(new Mod::HashCarrier<HASH>);
}

/*#
@method update
@brief Feeds data into the hash function

This method accepts an arbitrary amount of arguments of the following types: String, MemBuf, MPZ.
Strings and MemBufs are hashed with respect to their byte count (1, 2, or 4 byte strings) and endianness.
MPZ are converted to a hex string internally, which is then converted to a byte array and hashed (this operation is endian-neutral).
The arguments are hashed in the order they are passed.
Note: Arguments that are not of the above types will be automatically converted to a string.
*/
template <class HASH> FALCON_FUNC Hash_update( ::Falcon::VMachine *vm )
{
    Mod::HashCarrier<HASH> *carrier = (Mod::HashCarrier<HASH>*)(vm->self().asObject()->getUserData());
    Mod::HashBase *hash = carrier->GetHash();
    if(hash->IsFinalized())
    {
        throw new Falcon::AccessError( 
            Falcon::ErrorParam( e_acc_forbidden, __LINE__ )
            .extra(FAL_STR(hash_err_finalized)));
    }
    for(uint32 i = 0; i < uint32(vm->paramCount()); i++)
    {
        Item *what = vm->param(i);
        if (!what)
        {
            throw new Falcon::ParamError( 
                Falcon::ErrorParam( Falcon::e_inv_params, __LINE__ )
                .extra( "MemBuf or S" ) );
        }
        if(what->isMemBuf())
        {
            hash->UpdateData(what->asMemBuf());
        }
        else if(what->isString())
        {
            hash->UpdateData(what->asString());
        }
        else if(what->isOfClass("MPZ")) // direct conversion from MPZ to hash
        {
            Item *mpz = new Item;
            // involve the VM to convert an MPZ to string in base 16
            // and then convert that into the individual bytes beeing hashed (backwards, to represent the original number)
            // i have checked it and the way this is done here is *correct*!
            if(what->asObject()->getMethod("toString", *mpz))
            {
                vm->pushParameter(16);
                vm->callItemAtomic(*mpz, 1);
                String *hexstr = vm->regA().asString();
                if(uint32 len = hexstr->length())
                {
                    char tmp[3];
                    tmp[2] = 0;
                    uint32 maxlen = (len & 1) ? len - 1 : len; // skip leftmost byte if string length is uneven
                    byte b;

                    for(uint32 i = 0 ; i < maxlen ; i += 2)
                    {
                        tmp[0] = hexstr->getCharAt((len - 1) - (i + 1));
                        tmp[1] = hexstr->getCharAt((len - 1) - i);
                        b = (byte)strtoul(tmp, NULL, 16); // converting max. 0xFF, this is safe
                        hash->UpdateData(&b, 1);
                    }
                    if(len & 1) // something remaining? must be treated as if it was prepended by '0'
                    {
                        tmp[0] = hexstr->getCharAt(0);
                        tmp[1] = 0;
                        b = (byte)strtoul(tmp, NULL, 16);
                        hash->UpdateData(&b, 1);
                    }

                }
            }
            else
            {
                delete mpz;
                throw new Falcon::AccessError(
                    Falcon::ErrorParam( Falcon::e_miss_iface, __LINE__ )
                    .extra( "MPZ does not provide toString, blame OmniMancer" ) );
            }
            delete mpz;
        }
        else // fallback - convert to string if nothing else works
        {
            String *str = new String();
            what->toString(*str);
            hash->UpdateData(str);
            delete str;
        }
    }


    Falcon::Item& self = vm->self();

}

/*#
@method finalize
@brief Finalizes a hash and produces the actual result

A hash object instance must be finalized before the result can be obtained.
After finalizing, no more data can be added.
*/
template <class HASH> FALCON_FUNC Hash_finalize( ::Falcon::VMachine *vm )
{
    ((Mod::HashCarrier<HASH>*)vm->self().asObject()->getUserData())->GetHash()->Finalize();
}

/*#
@method isFinalized
@brief Checks if a hash is finalized
@return A boolean indicating whether the hash is already finalized or not
*/
template <class HASH> FALCON_FUNC Hash_isFinalized( ::Falcon::VMachine *vm )
{
    vm->retval(((Mod::HashCarrier<HASH>*)vm->self().asObject()->getUserData())->GetHash()->IsFinalized());
}

/*#
@method bytes
@return The amount of *bytes* of the hash result

The amount of returned bytes is specific for each hash algorithm.
Does not require Finalize() called previously.
*/
template <class HASH> FALCON_FUNC Hash_bytes( ::Falcon::VMachine *vm )
{
    vm->retval((Falcon::int32)((Mod::HashCarrier<HASH>*)vm->self().asObject()->getUserData())->GetHash()->DigestSize());
}

/*#
@method bits
@return The amount of *bytes* of the hash result

The amount of returned bytes is specific for each hash algorithm.
Does not require Finalize() called previously.
*/
template <class HASH> FALCON_FUNC Hash_bits( ::Falcon::VMachine *vm )
{
    vm->retval((Falcon::int32)((Mod::HashCarrier<HASH>*)vm->self().asObject()->getUserData())->GetHash()->DigestSize() * 8);
}

/*#
@method toMemBuf
@return The hash result, in a 1-byte wide MemBuf
*/
template <class HASH> FALCON_FUNC Hash_toMemBuf( ::Falcon::VMachine *vm )
{
    Mod::HashBase *hash = ((Mod::HashCarrier<HASH>*)vm->self().asObject()->getUserData())->GetHash();
    uint32 size = hash->DigestSize();
    Falcon::MemBuf_1 *buf = new Falcon::MemBuf_1(size);
    if(byte *digest = hash->GetDigest())
    {
        memcpy(buf->data(), digest, size);
        vm->retval(buf);
    }
    else
    {
        vm->retnil();
    }
}

/*#
@method toString
@return The hash result, as a big-endian-orientated hexadecimal string
*/
template <class HASH> FALCON_FUNC Hash_toString( ::Falcon::VMachine *vm )
{
    Mod::HashBase *hash = ((Mod::HashCarrier<HASH>*)vm->self().asObject()->getUserData())->GetHash();
    uint32 size = hash->DigestSize();
    if(byte *digest = hash->GetDigest())
    {
        Falcon::String *str = new Falcon::String(size * 2); // each byte will be encoded to 2 chars
        char tmp[3];

        for(uint32 i = 0; i < size; i++)
        {
            sprintf(tmp, "%02x", digest[i]); // convert byte to hex
            str->A(tmp[0]).A(tmp[1]); // and add it to output string
        }

        vm->retval(str);
        return;
    }

    vm->retnil();
}

/*#
@method toInt
@return The checksum result, as an Integer

Only Hashes/Checksums up to 8 bytes / 64 bits provide this.
The returned int is in native endianness!
*/
template <class HASH> FALCON_FUNC Hash_toInt( ::Falcon::VMachine *vm )
{
    vm->retval((Falcon::int64)((Mod::HashCarrier<HASH>*)vm->self().asObject()->getUserData())->GetHash()->AsInt());
}


}
}

/* end of hash_mod.inl */
