/*
   FALCON - The Falcon Programming Language.
   FILE: hash_ext.inl

   Provides multiple hashing algorithms
   Interface extension functions
   -------------------------------------------------------------------
   Author: Maximilian Malek
   Begin: Thu, 25 Mar 2010 02:46:10 +0100

   -------------------------------------------------------------------
   (C) Copyright 2010: The above AUTHOR

         Licensed under the Falcon Programming Language License,
      Version 1.1 (the "License"); you may not use this file
      except in compliance with the License. You may obtain
      a copy of the License at

         http://www.falconpl.org/?page_id=license_1_1

      Unless required by applicable law or agreed to in writing,
      software distributed under the License is distributed on
      an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      KIND, either express or implied. See the License for the
      specific language governing permissions and limitations
      under the License.

*/

/** \file
   Provides multiple hashing algorithms
   Interface extension functions
*/

#include <stdio.h>
#include <falcon/engine.h>
#include "hash_mod.h"
#include "hash_ext.h"
#include "hash_st.h"

namespace Falcon {
namespace Ext {

/*#
   @class HashBase
   @brief Base class for each hash algorithm

   The HashBase class itself does nothing, but provides a set of methods to be overloaded for each
   hash implementation, as well as some shared methods that are the same for each hash, like shared interfaces,
   type conversion, and endian management.

   Hashes are generated by creating an instance of a specialized class.
   Note that each hash class instance, after calling update() to feed it with stuff,
   has to be finalize()ed before the actual result can be obtained.
   @code
       crc = CRC32()
       crc.update("abc")
       crc.finalize()
       > crc // prints "352441c2"
   @endcode


   To easily implement other hash algorithms in native falcon code, HashBase can be overloaded.
   For simplicity, only 2 methods have to be overloaded, and 2 new methods have to be added:
   @code
       class MyHash from HashBase
           state = nil // internal state
           outp = nil
           function bytes(): return 12       // must be overloaded and return a constant integer > 0
           function toMemBuf(): return outp  // must be overloaded and return a MemBuf with wordSize 1 and length equal to bytes()
           function process(buf)             // must be declared, as it is invoked by the module on update() calls
               // *mangle MemBuf and update state*
           end
           function internal_finalize()      // must be declared, as it is invoked by the module on finalize()
               // *transform state and assign result MemBuf(1, bytes()) to outp*
           end
       end
   @endcode

   How this works:
   - bytes() is internally invoked by bits()
   - process() is invoked by update() and updateInt()
   - toMemBuf() is invoked by toString()
   - internal_finalize() is invoked by finalize()
   You are strongly advised NOT to overload other methods unless you REALLY know what you're doing.

   Advantages of doing it this way:
   - it is not necessary to implement update() in native falcon code
   - all value endian conversions and error checking is done by the module, so focus can be set on the algorithm itself
   - the value returned by bytes() is cached, means less calls, less time
   - the module ensures that internal_finalize() is called only once, no explicit checking required

*/


template <class HASH> FALCON_FUNC Hash_init( ::Falcon::VMachine *vm )
{
    vm->self().asObject()->setUserData(new Mod::HashCarrier<HASH>);
}

template <> FALCON_FUNC Hash_init<Mod::HashBaseFalcon>( ::Falcon::VMachine *vm )
{
    Mod::HashCarrier<Mod::HashBaseFalcon> *carrier = new Mod::HashCarrier<Mod::HashBaseFalcon>;
    carrier->GetHash()->SetVM(vm);
    vm->self().asObject()->setUserData(carrier);
}

/*#
@method update HashBase
@brief Feeds data into the hash function
@raise AccessError if the hash is already finalized

This method accepts an arbitrary amount of arguments of the following types: String, MemBuf, MPZ, Sequences (List, Array, Dictionary).
Strings and MemBufs are hashed with respect to their byte count (1, 2, or 4 byte strings) and endianness.
MPZ are converted to a hex string internally, which is then converted to a byte array and hashed (this operation is endian-neutral).
Lists and Arrays are traversed, each item beeing hashed.
From Dictionaries, only the values are hashed. Note that the order in which the values are processed depends on the keys!
All arguments are hashed in the order they are passed. Sequences can be nested.

@note Arguments that are not of the above types will be automatically converted to a string.
@note Multiple calls can be chained, e.g. hash.update(x).update(y).update(z)
*/

// updateItem is a helper function to process the individual items passed to update()
void Hash_updateItem_internal(Item *what, Mod::HashBase *hash, ::Falcon::VMachine *vm)
{
    if(what->isMemBuf())
    {
        hash->UpdateData(what->asMemBuf());
    }
    else if(what->isString())
    {
        hash->UpdateData(what->asString());
    }
    else if(what->isArray())
    {
        CoreArray *arr = what->asArray();
        for(uint32 i = 0; i < arr->length(); ++i)
        {
            Hash_updateItem_internal(&arr->at(i), hash, vm);
        }
    }
    else if(what->isDict())
    {
        CoreDict *dict = what->asDict();
        Iterator iter(&dict->items());
        while( iter.hasCurrent() )
        {
            Hash_updateItem_internal(&iter.getCurrent(), hash, vm);
            iter.next();
        }
    }
    else if(what->isOfClass("List"))
    {
        ItemList *li = dyncast<ItemList *>( what->asObject()->getSequence() );
        Iterator iter(li);
        while( iter.hasCurrent() )
        {
            Hash_updateItem_internal(&iter.getCurrent(), hash, vm);
            iter.next();
        }
    }
    else if(what->isOfClass("MPZ")) // direct conversion from MPZ to hash
    {
        Item *mpz = new Item;
        // involve the VM to convert an MPZ to string in base 16
        // and then convert that into the individual bytes beeing hashed (backwards, to represent the original number)
        // i have checked it and the way this is done here is *correct*!
        if(what->asObject()->getMethod("toString", *mpz))
        {
            vm->pushParameter(16);
            vm->callItemAtomic(*mpz, 1);
            String *hexstr = vm->regA().asString();
            if(uint32 len = hexstr->length())
            {
                char tmp[3];
                tmp[2] = 0;
                uint32 maxlen = (len & 1) ? len - 1 : len; // skip leftmost byte if string length is uneven
                byte b;

                for(uint32 i = 0 ; i < maxlen ; i += 2)
                {
                    tmp[0] = hexstr->getCharAt((len - 1) - (i + 1));
                    tmp[1] = hexstr->getCharAt((len - 1) - i);
                    b = (byte)strtoul(tmp, NULL, 16); // converting max. 0xFF, this is safe
                    hash->UpdateData(&b, 1);
                }
                if(len & 1) // something remaining? must be treated as if it was prepended by '0'
                {
                    tmp[0] = hexstr->getCharAt(0);
                    tmp[1] = 0;
                    b = (byte)strtoul(tmp, NULL, 16);
                    hash->UpdateData(&b, 1);
                }
            }
        }
        else
        {
            delete mpz;
            throw new Falcon::AccessError(
                Falcon::ErrorParam( Falcon::e_miss_iface, __LINE__ )
                .extra( "MPZ does not provide toString, blame OmniMancer" ) );
        }
        delete mpz;
    }
    // skip nil, hashing it as string "Nil" would be useless and error-prone
    else if(what->isNil())
    {
        return;
    }
    else // fallback - convert to string if nothing else works
    {
        String *str = new String();
        what->toString(*str);
        hash->UpdateData(str);
        delete str;
    }
}

template <class HASH> FALCON_FUNC Hash_update( ::Falcon::VMachine *vm )
{
    Mod::HashCarrier<HASH> *carrier = (Mod::HashCarrier<HASH>*)(vm->self().asObject()->getUserData());
    Mod::HashBase *hash = carrier->GetHash();
    if(hash->IsFinalized())
    {
        throw new Falcon::AccessError( 
            Falcon::ErrorParam( e_acc_forbidden, __LINE__ )
            .extra(FAL_STR(hash_err_finalized)));
    }
    for(uint32 i = 0; i < uint32(vm->paramCount()); i++)
    {
        Item *what = vm->param(i);
        if (!what)
        {
            throw new Falcon::ParamError( 
                Falcon::ErrorParam( Falcon::e_inv_params, __LINE__ )
                .extra( "MemBuf or S or Array" ) );
        }
        Hash_updateItem_internal(what, hash, vm);
    }

    vm->retval(vm->self());
}

/*#
@method updateInt HashBase
@brief Feeds an integer of a specified size into the hash function
@param num The integer to hash
@param bytes The amount of bytes to take
@raise ParamError if @b bytes is not in 1..8 or @b num is not an Ordinal
@raise AccessError if the hash is already finalized

This method can be used to avoid creating a MemBuf to hash integer values.
It supports 1 up to 8 bytes (uint64).
All integers are converted to little-endian. Numerics are automatically converted to Integers, all other types raise an error.

@note Multiple calls can be chained, e.g. hash.updateInt(x).updateInt(y).updateInt(z)
*/
template <class HASH> FALCON_FUNC Hash_updateInt( ::Falcon::VMachine *vm )
{
    Mod::HashCarrier<HASH> *carrier = (Mod::HashCarrier<HASH>*)(vm->self().asObject()->getUserData());
    Mod::HashBase *hash = carrier->GetHash();
    if(hash->IsFinalized())
    {
        throw new Falcon::AccessError( 
            Falcon::ErrorParam( e_acc_forbidden, __LINE__ )
            .extra(FAL_STR(hash_err_finalized)));
    }
    if(vm->paramCount() < 2)
    {
        throw new Falcon::ParamError( 
            Falcon::ErrorParam( Falcon::e_inv_params, __LINE__ )
            .extra( "N, N" ) );
    }
    uint64 num = vm->param(0)->forceIntegerEx();
    uint8 bytes = (uint8)vm->param(1)->forceIntegerEx();
    if( !(bytes && bytes <= 8) )
    {
        throw new Falcon::ParamError( 
            Falcon::ErrorParam( Falcon::e_inv_params, __LINE__ )
            .extra( "bytes must be in 1..8" ) );
    }
    num = endianInt64(num);
    hash->UpdateData((byte*)&num, bytes);

    vm->retval(vm->self());
}

/*#
@method finalize HashBase
@brief Finalizes a hash and produces the actual result

A hash object instance must be finalized before the result can be obtained.
After finalizing, no more data can be added.

@note Does nothing if the hash is already finalized
*/
template <class HASH> FALCON_FUNC Hash_finalize( ::Falcon::VMachine *vm )
{
    Mod::HashCarrier<HASH> *carrier = (Mod::HashCarrier<HASH>*)(vm->self().asObject()->getUserData());
    Mod::HashBase *hash = carrier->GetHash();
    if(hash->IsFinalized())
        return;

    hash->Finalize();
    vm->retval(vm->self());
}

/*#
@method isFinalized HashBase
@brief Checks if a hash is finalized
@return true if the hash is finalized, false if not
*/
template <class HASH> FALCON_FUNC Hash_isFinalized( ::Falcon::VMachine *vm )
{
    vm->retval(((Mod::HashCarrier<HASH>*)vm->self().asObject()->getUserData())->GetHash()->IsFinalized());
}

/*#
@method bytes HashBase
@return The amount of @b bytes of the hash result

The amount of returned bytes is specific for each hash algorithm.
Does not require finalize() called previously.
*/
template <class HASH> FALCON_FUNC Hash_bytes( ::Falcon::VMachine *vm )
{
    vm->retval((Falcon::int32)((Mod::HashCarrier<HASH>*)vm->self().asObject()->getUserData())->GetHash()->DigestSize());
}

// specialization to return 0 for HashBaseFalcon
template <> FALCON_FUNC Hash_bytes<Mod::HashBaseFalcon>( ::Falcon::VMachine *vm )
{
    vm->retval(Falcon::int32(0));
}

/*#
@method bits HashBase
@return The amount of @b bits of the hash result
@note This method is a shortcut for bytes() * 8
*/
template <class HASH> FALCON_FUNC Hash_bits( ::Falcon::VMachine *vm )
{
    vm->retval((Falcon::int32)((Mod::HashCarrier<HASH>*)vm->self().asObject()->getUserData())->GetHash()->DigestSize() * 8);
}

/*#
@method toMemBuf HashBase
@return The hash result, in a 1-byte wide MemBuf
*/
template <class HASH> FALCON_FUNC Hash_toMemBuf( ::Falcon::VMachine *vm )
{
    Mod::HashBase *hash = ((Mod::HashCarrier<HASH>*)vm->self().asObject()->getUserData())->GetHash();
    uint32 size = hash->DigestSize();
    Falcon::MemBuf_1 *buf = new Falcon::MemBuf_1(size);
    if(byte *digest = hash->GetDigest())
    {
        memcpy(buf->data(), digest, size);
        vm->retval(buf);
    }
    else
    {
        vm->retnil();
    }
}

template <> FALCON_FUNC Hash_toMemBuf<Mod::HashBaseFalcon>( ::Falcon::VMachine *vm )
{
    throw new Falcon::GenericError( 
        Falcon::ErrorParam( Falcon::e_miss_iface, __LINE__ )
        .extra(vm->moduleString(hash_err_no_overload)));
}

/*#
@method toString HashBase
@return The hash result, as a big-endian-orientated hexadecimal string

@note Big-endian notation exists in the specification of the SHA-family and has been adopted by others as "official" representation
*/
template <class HASH> FALCON_FUNC Hash_toString( ::Falcon::VMachine *vm )
{
    Mod::HashBase *hash = ((Mod::HashCarrier<HASH>*)vm->self().asObject()->getUserData())->GetHash();
    uint32 size = hash->DigestSize();
    if(byte *digest = hash->GetDigest())
    {
        Falcon::String *str = new Falcon::String(size * 2); // each byte will be encoded to 2 chars
        char tmp[3];

        for(uint32 i = 0; i < size; i++)
        {
            sprintf(tmp, "%02x", digest[i]); // convert byte to hex
            str->A(tmp[0]).A(tmp[1]); // and add it to output string
        }

        vm->retval(str);
        return;
    }

    vm->retnil();
}

/*#
@method toInt HashBase
@return The checksum result, as an Integer
@note The returned int is in native endianness.
@note Only hashes/checksums up to 8 bytes / 64 bits provide this.
*/
template <class HASH> FALCON_FUNC Hash_toInt( ::Falcon::VMachine *vm )
{
    vm->retval((Falcon::int64)((Mod::HashCarrier<HASH>*)vm->self().asObject()->getUserData())->GetHash()->AsInt());
}


}
}

/* end of hash_mod.inl */
