
                               RELNOTES for Falcon

                                 Condor Release

                                     0.8.12


  Condor release closes the overall language structure extension and completes
the paradigms supported by falcon adding prototype based OOP and tabular
programming.

  The functional programming paradingm has been greatly extended through the
introduction of late bindings and the addition of more functional-oriented
operators in the the funcext feather module.

  Functionally, late bindings are variables declared in sequences which
assume values as the evaluation proceeds. They are declared through the "&"
opeartor, and

  Paradigms are now more formalized and the overall stability of the engine
and of the language has sensibly grown. Be sure to read carefully the
ChangeLog in this version, as many aspects of the grammar has been changed.

  Current package is a bleeding edge verison released to test build and
installation issues on supported platforms.

Open issues at 0.8.12
=====================

   * Streams, mainly file streams, are still to be buffered and optimized.
     If Falcon is employed for high throughput applications, as i.e.
     grepping files, writing massive log amounts, copying files, applicative
     data buffering should be used, and raw write/read stream methods on
     large strings or MemBuf data types should be employed for
     better performance.

   * Stream API may undergo some reshaping during 0.8.12->0.9 step.

   * Assembler has some issues; it is being moved to a stand-alone
     application and library (and possibly to a separate project)
     in 0.9, so its known problems are not being fixed now. The
     assembler is not functional to a correct Falcon application,
     so its status is irrilevant at current development stage.

   * Functional closeures are checking and closing only the direct
     parent's local variables and globally visible variables;
     other parents in the hierarcy are not being considered. So

        glob n = 0

        function a()
          x = 1
          function b()
            y = 2
            return (function(); y * x *n; end)
          end
        end

     will close y and n, but not x. In this moment it is not clear
     if this is a issue or not.

  * FBOM (falcon basic object model) and operator overloading is corrently
    not strongly defined. We need to work a better and deeper object model
    set and enforce it as a generic interface to access items across all
    the engine. The main consequence is that some VM operators can use
    class instance define symbols (as i.e. string conversion), while
    automatic method calls are not available for prototype oriented OOP.
