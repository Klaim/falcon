/*
 MessageQueue Test
 
 Message queues are FIFO queues of arbitrary objects that
 will be read by all the agents (parallel contexts) that 
 subscribed for later receival, or that are actively waiting
 for new messages to be processed.
 
 Named message queues are globally visible in a virtual machine,
 so different VM processes can pass data through a queue by
 just knowing its name.
 
 This test screates a set of agents that will receive some obect
 at different times; some agents will sleep enough that they will
 receive two messages at once.
*/

// regoalte this for different outcomes
simultaneity = 0.4
generator_interval = 0.5

// The message that we're sending around
// Can be any arbitrary Falcon data.
class Message(count)
   readCount = 0
   previous = nil
   msgid = count
end

// our test encapsulation
class Entity(count)
   done = Barrier()
   count = count
   loops = 0   
   // A generic mutex to do pretty output
   outputMutex = Mutex()
   
   
   // theese are our agents.
   function worker( id )
   
    self.outputMutex.locked( 
      {() > "Worker -- entering ", ^~id, "."} )      
      
      entity = self
      work = function(id, signaled)
         while not signaled.empty
            msg = signaled.get()
            
            // the pretty output and mutex allow us to put some agent-specific data
            // on the shared object for the latecomers to see it.
            entity.outputMutex.locked( 
               {[] 
                  msgcount = ^~(msg).readCount++
                  > "Worker ", ^~id, " -- received message ", ^~(msg.msgid), " with count ", msgcount
                   > "       -- previous worker left \"", ^~(msg).previous, "\""
                  ^~(msg).previous = "Worker " + ^~id + " read count " + msgcount
               } )            
         end
         
         // simulate some work so we stay behind messages
         sleep(simultaneity*(id+1))
      end
      
      // get the named queue "general" from the VM
      queue = MessageQueue("general")
      // the work is automatically marshalled by a waiter
      waiter = Waiter()
      // when the semaphore is signaled, we can work...
      waiter.add( queue, [work,id] )
      //... and we're done when the barrier is signaled.
      waiter.add( self.done )

      // this will keep us locked until a non-marshalled entity 
      // is signaled. In our case, the "done" barrier.
      // At that point, it returns the signaled entity (but we
      // don't need it).
      waiter.wait()
            
      self.outputMutex.locked( 
         {() > "Worker ", ^~id, "-- terminating." }
         )      
   end
   
      
   function control( time )
      // using a traditional lock approach here.
      self.outputMutex.locked(
         {[] > "Entering control for ", ^~time, " seconds."})
      
      startedAt = seconds()
      
      // again, get the "general" VM queue
      queue = MessageQueue("general")
      self.outputMutex.locked( {()
            > "Control -- Waiting for subscribers."} )
      // this method generates a fence that will tell us
      // when the receivers are ready
      queue.subscribersFence( self.count ).wait()
      // then we can start sending them some message
      self.outputMutex.locked( {()
            > "Control -- Subscribers have subscribed -- proceed."} )
            
      count = 0
      while seconds() - startedAt < time
         sleep(generator_interval)
         self.outputMutex.locked( {()
            > "Control -- sending a new message."} )
         // mark the mesages with a different sequential
         msg = Message(count++)
         // just send it
         queue.send( msg )
      end
      
      >
      > "Control agent terminated. Signaling the other agents."
      
      // open the barrier to terminate the others.
      self.done.open()      
   end


   // This creates a parallel computation for our test to run.
   function getReady( time )
      comp = Parallel()
      
      // add all our methods using closures
      this = self
      for i = 0 to self.count-1
         comp.add([{n=> this.worker(n) }, i])
      end
      
      // add also the control method
      comp.add( {=> this.control(time) } )
      
      return comp
   end
   
end


//===============================================================
// The main program.
//===============================================================

> "Computation test"

// creating five agents.
instance = Entity(5)

// for 20 seconds
computation = instance.getReady(20)

try
   computation.launch()
   >
   > "Test complete."
   
catch in error
   >
   > "Caught a generic error:"
   > error
end
