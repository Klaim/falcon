/*
 MessageQueue Marshal Test
 
 Marshaling a message means automatically sending it
 to an handler as it is received by its processor.
*/

// A generic mutex to do pretty output
outputMutex = Mutex()


// this will receive automatically our messages.
class Marshal( id )
   id = id
   count_item = 0
   count_params = 0
   count_single = 0
   count_dflt = 0
   
   function on_( item )
      self.count_item++
   end
   
   function on_MouseXY(x,y)
      self.count_params++
   end
   
   function on_MouseClick( evt )
      self.count_single++
   end
   
   function on__discard()
      self.count_dflt++
   end
end



// our test encapsulation
class Entity(count)
   done = Barrier()
   prodDone = Barrier()
   count = count
   loops = 0
   receivers = []
   
   completeProd = Event()
   completeFence = Fence(count)
   
   init
      for i = 1 to count
         self.receivers += nil
      end
   end
   
   // theese are our agents.
   function worker( id )
   
    outputMutex.locked( 
      {() > "Worker -- entering ", ^~id, "."} )      
      
      receiver = Marshal(id)
      self.receivers[id] = receiver
      // get the named queue "general" from the VM
      queue = MessageQueue("general")
      // the work is automatically marshalled by a waiter
      waiter = Waiter()
      // when the semaphore is signaled, we can work...
      waiter.add( queue, queue.marshal(receiver) )
      //... and we're done when the barrier is signaled.
      waiter.add( self.done )

      // this will keep us locked until a non-marshalled entity 
      // is signaled. In our case, the "done" barrier.
      // At that point, it returns the signaled entity (but we
      // don't need it).
      waiter.wait()
            
      outputMutex.locked( 
         {() > "Worker ", ^~id, "-- terminating." }
         )  
      self.completeFence.signal()
   end
   
      
   function producer()   
      // again, get the "general" VM queue
      queue = MessageQueue("general")
      outputMutex.locked( {()
            > "Producer -- Waiting for subscribers."} )
      // this method generates a fence that will tell us
      // when the receivers are ready
      queue.subscribersFence( self.count ).wait()
      // then we can start sending them some message
      outputMutex.locked( {()
            > "Producer -- Subscribers have subscribed -- proceed."} )
            
      count = 0
      while not self.prodDone.tryWait()
         // Send a standard message.
         queue.send( "Standard message" )
         // send a mouse event
         queue.sendEvent("MouseXY", count*10, count*20)
         // send a mouse event
         queue.sendEvent("MouseClick", '"click"' )
         // Send an unknown message
         queue.sendEvent("Unknown", '""' )       
         ++count
      end
      
      outputMutex.locked( {[] > "Producer terminated."} )
      self.completeProd.set()
   end

   
   function control( time )
      // using a traditional lock approach here.
      outputMutex.locked(
         {[] > "Entering control for ", ^~time, " seconds."})
      
      startedAt = seconds()
      while seconds() - startedAt < time
         sleep(0.2)
         >> @"$({seconds() - startedAt}.2): "
         self.display()
      end
      
      >
      > "Control agent terminated. Signaling the other agents."
      self.prodDone.open()
      self.completeProd.wait()
      sleep(1)
      // open the barrier to terminate the others.
      self.done.open()  
      // wait for final result:
      self.completeFence.wait()
      > "Final result:"
      self.display()
      > 
   end
   
   
   function display()
      for rec in self.receivers
         >> "["
         >> rec.count_item, "|"
         >> rec.count_params, "|"
         >> rec.count_single, "|"
         >> rec.count_dflt
         >> "]"
         formiddle: >> " "
         forlast: >> "    \r"
      end
   end
   

   // This creates a parallel computation for our test to run.
   function getReady( time )
      comp = Parallel()
      
      // add all our methods using closures
      this = self
      for i = 0 to self.count-1
         comp.add([{n=> this.worker(n) }, i])
      end
      
      // add also the control method
      comp.add( {=> this.control(time) } )
      
      // And a producer
      comp.add( this.producer )
      
      return comp
   end
   
end


//===============================================================
// The main program.
//===============================================================

> "Computation test"

// creating 10 agents.
instance = Entity(7)

// for 10 seconds
computation = instance.getReady(60)

try
   computation.launch()
   >
   > "Test complete."
   
catch in error
   >
   > "Caught a generic error:"
   > error
end
