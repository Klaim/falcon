/*
   FALCON - The Falcon Programming Language.
   FILE: log.h

   Engine-level pluggable asynchronous logging facility.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Sat, 08 Dec 2012 22:29:41 +0100

   -------------------------------------------------------------------
   (C) Copyright 2012: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

#ifndef _FALCON_LOG_H_
#define _FALCON_LOG_H_

#include <falcon/setup.h>
#include <falcon/mt.h>
#include <falcon/refcounter.h>

namespace Falcon {

class String;

/**
 * Engine-level pluggable asynchronous logging facility.
 *
 */
class FALCON_DYN_CLASS Log: public Runnable
{
public:
   Log();
   virtual ~Log();

   /**
    * Reference counted listener class.
    *
    * This class has a virtual callback that is invoked when a new
    * message arrives, and it has the required characteristics.
    *
    * The Log class holds a reference to all the non-closed listeners
    * it is sending messages to.
    *
    * When a listener is not willing to listen to messages anymore,
    * it can call the close() method.
    *
    * If the listener creator is not interested in handling the listener
    * during the program lifetime, it can invoke a decref() in any moment,
    * as the Log will take care of keeping it alive until it's not used
    * anymore.
    *
    */
   class FALCON_DYN_CLASS Listener
   {
   public:
      Listener();

      /**
       * Sets a minimal log level for this listener.
       *
       * This listener's onMessage will be only called back when the
       * incoming message level is LESS or EQUAL to the given level.
       *
       * Use lvl = lvl_debug2 as a catch-all clause.
       *
       * @note As this method is not synchronized, time might pass before
       * the filter level change is actually enforced.
       */
      virtual void logLevel( int lvl );

      /**
       * Indicates a facility that shall be received.
       * @param fac The facility to be received, or -1 to receive all.
       *
       * When this is set and >= 0, that facility only will be received.
       *
       * Use fac = fac_all as a catch-all clause.
       *
       * @note As this method is not synchronized, time might pass before
       * the filter facility change is actually enforced.
       */
      virtual void facility( int fac );

      /**
       * Returns current facility.
       * \return The currently set facility, fac_all meaning get all.
       */
      int facility() const;

      /**
       * Returns current level.
       */
      int level() const;

   protected:
      virtual void onMessage( int fac, int lvl, const String& message ) = 0;
      virtual ~Listener();

   private:
      // we don't really care about synchronicity of this.
      int m_facility;
      int m_level;


      FALCON_REFERENCECOUNT_DECLARE_INCDEC(Listener);
      friend class Log;
   };

   static const int lvl_critical = 0;
   static const int lvl_error = 1;
   static const int lvl_warn = 2;
   static const int lvl_info = 3;
   static const int lvl_detail = 4;
   static const int lvl_debug = 5;
   static const int lvl_debug1 = 6;
   static const int lvl_debug2 = 7;


   /**
    * Use this value to catch all facility when setting a listener facility filter.
    */
   static const int fac_all = -1;
   /** Facility mark for logs generated by the Falcon engine */
   static const int fac_engine = 0;
   /** Facility mark for logs generated by relevant I/O operations in the Falcon engine */
   static const int fac_engine_io = 1;
   /** Facility mark for logs generated by scripts */
   static const int fac_script = 2;
   /** Facility mark for logs generated by embedding applications */
   static const int fac_app = 3;
   /** User mark; any integer >= than fac_user is at user disposal for scripts or applications. */
   static const int fac_user = 4;


   /**
    * Send a log message.
    * @param fac A logical sender for the message; should be one of the fac_* enumeration.
    * @param lvl A criticity level, lower value means highest criticity.
    * @param msg The message to be displayed.
    */
   void log( int fac, int lvl, const String& message );

   /**
    * Utility providing a standard format for output messages.
    * @param fac A logical sender for themessage.
    * @param lvl A criticity level, lower means highest.
    * @param msg The message to be displayed.
    *
    * Output is msg.
    *
    * Format is "<timestamp>\\t<facility>:<level>\\t<message>"
    *
    */
   static void formatLog( int fac, int lvl, const String& message, String& target );

   /**
    * Utility providing a 4 letter level description of a log level.
    *
    * @param lvl The level to be turned into a string.
    * @return The description, or "????" if unknonwn.
    *
    * The possible return values are:
    * - "CRIT"
    * - "ERR "
    * - "WARN"
    * - "INFO"
    * - "DET "
    * - "DBG "
    * - "DBG1"
    * - "DBG2"
    * - "????"
    */
   static const char* levelToString( int lvl );

   /**
    * Utility providing a 1 letter level description of the facility.
    *
    * @param fac The facility
    * @return The description, or "????" if unknonwn.
    *
    * The possible return values are:
    * - "E"  For engine.
    * - "I"  For engine I/O
    * - "S"  For script
    * - "A"  For application
    * - "U"  For user
    * - "?"  For anything else.
    */
   static const char* facilityToString( int fac );

   /**
    * Utility adding a timestamp to a falcon string.
    */
   static void addTS( String& target );

   /** Adds a listener for incoming logs.
    * @param l The listener to be added
    * @param msg If true, a "Starting log" message will be automatically and forcefully sent at info level.
    */
   void addListener( Listener* l , bool msg = true );

   /** Removes a listener for incoming logs.
    * @param l The listener to be removed
    * @param msg If true, a "Stopping log" message will be automatically and forcefully sent at info level.
    *
    *  */
   void removeListener( Listener* l, bool msg = true );

   /**
    * Thread main function.
    */
   void *run();


private:

   /** Maximum number of pre-allocated String* */
   static const unsigned int STRING_POOL_THRESHOLD = 64;

   SysThread* m_thread;
   class Private;
   Log::Private* _p;

   void handleMessage(void* data);
   void handleLogger(void* data);

};

}

#endif

/* end of log.h */
