/*
   FALCON - The Falcon Programming Language
   FILE: stderrors.h

   Engine static/global data setup and initialization
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Sun, 31 Jul 2011 15:30:08 +0200

   -------------------------------------------------------------------
   (C) Copyright 2011: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

#ifndef _FALCON_STDERRORS_H
#define _FALCON_STDERRORS_H

#include <falcon/setup.h>
#include <falcon/types.h>

namespace Falcon
{

class Class;

/** Storage for classes representing standard errors in the scripts.
 
 This classes are used by the scriptification process of errors to turn
 exceptions thrown at C++ level into script entities.
 
 In practice, if a script intercepts an exception generated by a C++ routine
 it invokes, this exception is handled to the script by associating a given
 class handler to the exception. 
 
 The class handler must be exception-type specific because the class is also
 exposed to the script: the script could throw a C++ ecxeption by creating
 an instance of that class and then raising it.
 
 In short, every error class must have a Class handler that the script should
 know, to be able to intercept or generate an exception of that type.
 
 This class is a repository for the error Class handlers of exeptions generated
 by the engine and commonly used also by other modules.
 */
class StdErrors
{
public:
   StdErrors();
   ~StdErrors();
   
   /** Returns the global instance of the Error handler class. */
   Class* error() const { return m_error; }
   
   /** Returns the global instance of the CodeError handler Class.
    */
   Class* code() const{ return m_code; } 

   /** Returns the global instance of the GenericError handler Class.
    */
   Class* generic() const { return m_generic; }

   /** Returns the global instance of the OperandError handler Class.
    */
   Class* operand() const { return m_operand; }

   /** Returns the global instance of the UnsupportedError handler Class.
    */
   Class* unsupported() const { return m_unsupported; }

   /** Returns the global instance of the IOError handler Class.
    */
   Class* io() const { return m_io; }

   /** Returns the global instance of the InterruptedError handler Class.
    */
   Class* interrupted() const { return m_interrupted; }

   /** Returns the global instance of the EncodingError handler Class.

    */
   Class* encoding() const { return m_encoding; }

   /** Returns the global instance of the AccessError class.
    */
   Class* access() const { return m_access; }

   /** Returns the global instance of the AccessTypeError handler Class.
    */
   Class* accessType() const { return m_accessType; }

   /** Returns the global instance of the SyntaxError class.
    */
   Class* syntax() const { return m_syntax; }

   /** Returns the global instance of the ParamError handler Class.
    */
   Class* param() const { return m_param; }
   
   /** Returns the global instance of the MathError handler Class.
    */
   Class* math() const { return m_math; }

   
   /** Returns the global instance of the LinkError handler Class.
    */
   Class* link() const { return m_link; }
   
   /** Returns the global instance of the UnserializableError handler Class.
    */
   Class* unserializable() const { return m_unserializable; }

   /** Returns the global instance of the TypeError handler Class.
    */
   Class* type() const { return m_type; }

   /** Adds all the error classes to the engine builtins. 
    
    Usually called by the engine at startup.
    */
   void addBuiltins() const;
   
private:
   Class* m_error;
   Class* m_code;
   Class* m_generic;
   Class* m_operand;
   Class* m_unsupported;
   Class* m_io;
   Class* m_interrupted;
   Class* m_encoding;
   Class* m_access;
   Class* m_accessType;
   Class* m_syntax;
   Class* m_param;
   Class* m_math;
   Class* m_link;
   Class* m_unserializable;
   Class* m_type;
};

}

#endif	/* _FALCON_STDERRORS_H */

/* end of stderrors.h */
