/*
   FALCON - The Falcon Programming Language.
   FILE: collector.h

   Garbage collector
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Sun, 08 Feb 2009 16:08:50 +0100

   -------------------------------------------------------------------
   (C) Copyright 2009: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

#ifndef FALCON_COLLECTOR_H
#define FALCON_COLLECTOR_H

#include <falcon/setup.h>
#include <falcon/mt.h>
#include <falcon/rampmode.h>
#include <falcon/string.h>
#include <falcon/enumerator.h>


#ifndef SRC
#define SRC __FILE__
#endif

#if FALCON_TRACE_GC
   #define FALCON_GC_STORE( cls, data ) ( Engine::collector()->trace() ?\
         Engine::GC_H_store( cls, (void*) data, SRC, __LINE__ ): \
         Engine::GC_store( cls, (void*) data ))
   #define FALCON_GC_STORELOCKED( cls, data ) ( Engine::collector()->trace() ?\
         Engine::GC_H_storeLocked( cls, (void*) data, SRC, __LINE__ ): \
         Engine::GC_storeLocked( cls, (void*) data ))

   #define FALCON_GC_STORE_SRCLINE( cls, data, src, line ) ( Engine::collector()->trace() ?\
         Engine::GC_H_store( cls, (void*) data, src, line ): \
         Engine::GC_store( cls, (void*) data ))

   #define FALCON_GC_STORELOCKED_SRCLINE( cls, data, src, line ) ( Engine::collector()->trace() ?\
         Engine::GC_H_storeLocked( cls, (void*) data, src, line ): \
         Engine::GC_storeLocked( cls, (void*) data ))

#else  //FALCON_TRACE_GC
   /** This macro can be used to activate the history recording of GC entities.
    See the main body class.
    */
   #define FALCON_GC_STORE( cls, data ) (Engine::GC_store( cls, (void*) data ))

   #define FALCON_GC_STORE_SRCLINE( cls, data, src, line ) (Engine::GC_store( cls, (void*) data ))

   /** This macro can be used to activate the history recording of GC entities.
    See the main body class.
    */
   #define FALCON_GC_STORELOCKED( cls, data ) (Engine::GC_storeLocked( cls, (void*) data ))
         
   #define FALCON_GC_STORELOCKED_SRCLINE( cls, data, src, line ) (Engine::GC_storeLocked( cls, (void*) data ))
#endif  //FALCON_TRACE_GC

#define FALCON_GC_HANDLE( data ) (FALCON_GC_STORE((data)->handler(), data))

namespace Falcon {

class GCToken;
class GCLock;
class Item;
class Class;
class VMContext;
class TextWriter;

/** Falcon Garbage collector.

 @section coll_loop Collection mark-sweep loop thread.
 The mark-sweep loop has the follwing structure:
 - The items currently locked are marked.
 - The live modules are makred.
 - The VMs registered with this collector are scanned for live items to be marked.
 - The sweep loop reapes all the items that fall beyond the last live VM generation.
 - The new items are marked with the CURRENT generation, and moved in the normal garbage.
 - The generation is advanced.

   Items may be locked by active threads right after the first step, but they are
   allocated in the new item list; so, they cannot be reaped during the current loop.

 @section coll_trace History tracing

 The garbage collector provides a powerful debug feature called "history tracing".

 History tracing traces any operation performed by the GC on any pointer passed
 to it as a DeepData pointer, in particular creation, marking and destruction.
 The report includes taking timings and perform consistency checks. For instance,
 if the GC tries to create a pointer over another pointer that is not yet free,
 or if it tries to mark a pointer that has been already deleted, the program
 dies immediately tracing all the needed information via Engine::die.

 The tracing is useful not just to expose bugs in Falcon GC and engine memory
 management, but also to fix bugs generated by modules and embedding applications
 during the early development stages.

 For instance, suppose that an application misbehaves and destroys a DeepData
 that has ben delegated to Falcon. Then, the whole program will crash later on,
 when the GC tries to mark or destroy it; but using a C++ debugging device or
 an appropriate crash error handler, it is possible to get the history of the
 pointer that has caused the error and see where and when it was created, and
 approximately up to when it was still valid.

 Normally, history tracing is compiled in debug builds and disabled in
 release builds, but it is possible to
 compile it in release enabling the compilation option FALCON_TRACE_GC. Once
 compiled-in, the trace option can be enabled and disabled at any time. When
 disabled, it has just a small marginal cost with respect to the trace-free
 version, so it can stay compiled into any non time-critical application to
 be available for activation in case a deep diagniostic is needed.

 The history tracing is transparently enabled on any store() operator,
 using the FALCON_GC_STORE macro, which will be directed to the H_store operation
 when FALCON_TRACE_GC is enabled at compile-time. Then, to enable tracing the activity
 of the GC at runtime, the trace() method must be called.

 At that point, the tracing process becomes transparent.

 To get information about a single data pointer passed to the GC use the method
 getHistory(), while the whole status can be dumped using either dumpHistory() or
 enumerateHistory().

 \note The trace events are never removed until the the collector is destroyed,
 or until clearTrace() is explicitly called. This might cause an exponential
 growth in memory usage in large programs. Either be sure to periodically
 call clearTrace() or consider using traceMark() method to disable the tracing
 of GC mark calls.
 
*/

class FALCON_DYN_CLASS Collector: public Runnable
{

public:
   enum constants {
      MAX_GENERATION = 0xFFFFFFFE,
      SWEEP_GENERATION = 0xFFFFFFFF
   };

   /** Base class for History Trace entries (ABC).
    Subclasses must reimplement the dump() method to have meaningful
    descriptions of events.
    
    */
   class HistoryEntry
   {
   public:
      /** Type of events.
       
       Subclasses must pick one of this types describing what kind
       of event they represent.
       */
      typedef enum tag_action_t {
         ea_create,
         ea_mark,
         ea_destroy
      } action_t;

      /** Kind of event that happened. */
      action_t m_action;

      /** Milliseconds since the program start when this event happend.
       */
      int64 m_ticks;

      virtual ~HistoryEntry();

      /** Returns a string representation of this entry.
       \return A string reprsenting this entry.
       */
      virtual String dump() const = 0;

   protected:
      /** Creates the entry.
         \param action The type of event
               (determining the type of subclass created here).
       */
      HistoryEntry( action_t action );

   };

   /** Entry representing a data creation in the History Trace.
    */
   class HECreate: public HistoryEntry
   {
   public:
      /** The file by which this entry was created. */
      String m_file;
      /** The line where this event was created. */
      int m_line;
      /** The name of the class that was associated with this data at DeepItem creation. */
      String m_class;

      /** Creates a creation event in the History Trace.
       \param file The file by which this entry was created.
       \param line The line in the given file where this event was created.
       \param The name of the class that was associated with this data at
               DeepItem creation.
       */
      HECreate( const String& file, int line, const String& className );
      virtual ~HECreate();
      
      virtual String dump() const;
   };

   /** Entry representing a data GC Mark in the History Trace.
    */
   class HEMark: public HistoryEntry
   {
   public:
      HEMark();
      virtual ~HEMark();

      virtual String dump() const;
   };

    /** Entry representing a data destruction in the History Trace.
    */
   class HEDestroy: public HistoryEntry
   {
   public:
      HEDestroy();
      virtual ~HEDestroy();

      virtual String dump() const;
   };

   /** Class representing the status of a data assigned to this collector.
    This is a container for the History Trace specific of a single data pointer.

    Also, it sotres some information about the current status of the given data,
    so that it is possible to immediately know about what the data is supposed
    to be and if it's still valid.
    */
   class DataStatus
   {
   public:
      /** Create the data status.
       Normally this constructor is called only by the owning collector
       after an H_store or H_storeLocked call.
       */
      DataStatus( void* data );
      ~DataStatus();

      /** The data that was delegated to the GC. */
      void* m_data;
      /** True if the data has been created and not yet destroyed. */
      bool m_bAlive;

      /** Adds an entry in the history list.
       \param e The new History Entry.
       */
      void addEntry( HistoryEntry* e );
      
      /** A String representation of this item and of all the associated history.
       \return a String representation of this entry.
       */
      String dump();

      typedef Enumerator<HistoryEntry> EntryEnumerator;

      /** Enumerates all the events in this status.
       \param r The enumerator that will receive the HistoryEntry items one at a time.

       Notice that the enumerator will receive an HistoryEntry reference, which
       might actually be a pointer to any one of the HistoryEntry subclasses.
       Use proper casting, if the virtual methods provided by the HistoryEntry
       hyerarcy is not enough.
       */
      
      void enumerateEntries( EntryEnumerator& r ) const;
      
   private:
      class Private;
      Private* _p;
   };


   /** Builds a memory pool.
      Initializes all element at 0 and set buffer sizes to the FALCON default.
   */
   Collector();

   /** Destroys all the items.
      Needless to say, this must be called outside any VM.
   */
   virtual ~Collector();

   /** Called upon creation of a new VM.
      This sets the current generation of the VM so that it is unique
      among the currently living VMs.
   */
   void registerContext( VMContext *vm );

   /** Called before destruction of a VM.
      Takes also care to disengage the VM from idle VM list.
   */
   void unregisterContext( VMContext *vm );


   /** Returns the number of elements managed by this collector. */
   int32 allocatedItems() const;

   /** Returns the current generation. */
   uint32 generation() const { return m_generation; }

   virtual void* run();

   /** Starts the parallel garbage collector. */
   void start();

   /** Stops the collector.
      The function synchronously wait for the thread to exit and sets it to 0.
   */
   void stop();

   /** Sets the normal threshold level. */
   void thresholdNormal( size_t mem ) { m_thresholdNormal = mem; }

   /** Sets the active threshold level. */
   void thresholdActive( size_t mem ) { m_thresholdActive = mem; }

   size_t thresholdNormal() const { return m_thresholdNormal; }

   size_t thresholdActive() const { return m_thresholdActive; }

   /** Sets the algorithm used to dynamically configure the collection levels.
      Can be one of:
      - RAMP_MODE_STRICT_ID
      - RAMP_MODE_LOOSE_ID
      - RAMP_MODE_SMOOTH_SLOW_ID
      - RAMP_MODE_SMOOTH_FAST_ID

      Or RAMP_MODE_OFF to disable dynamic auto-adjust of collection levels.
      \param mode the mode to be set.
      \return true if the mode can be set, false if it is an invalid value.
   */
   bool rampMode( int mode );
   int rampMode() const;


   /** Run a complete garbage collection.
    *
    * This method orders the GC to perform a complete garbage collection loop as soon as
    * possible, and then waits for the completion of that loop.
    *
    */
   void performGC();

   /** Stores an entity in the garbage collector.

    \note Use the macro FALCON_GC_STORE to transparently allow selecting
    this method or the H_store method depending on compilation options.
    Calling directly this method is to be considerated a deprecated practice.
    
     The entity gets stored in the new items, and will become reclaimable
     since the first scan loop that comes next.
    
     The data must be delivered to the garbage collection system with the
     class that describes it. The collector will call Class::gcmark to
     indicate that the item holding this object is alive. When the item
     is found dead, the collector will call Class::dispose to inform
     the class that the item is not needed by Falcon anymore.

    
     @param cls The class that manages the data.
     @param data An arbitrary data to be passed to the garbage collector.
     @return the token associated with this storage.
    */
   GCToken* store( const Class* cls, void* data );

   /** Stores an entity in the garbage collector and immediately locks it.

    \note Use the macro FALCON_GC_STORELOCKED to transparently allow selecting
    this method or the H_storeLocked method depending on compilation options.
    Calling directly this method is to be considerated a deprecated practice.
    
     This method stores an entity for garbage collecting, but adds an initial
     lock so that the collector cannot reclaim it, nor any other data depending
     from the stored entity.
    
     This is useful when the object is known to be needed by an external entity
     that may be destroyed separately from Falcon activity. A locked entity
     gets marked via Class::gcmark even if not referenced in any virtual machine,
     and gets disposed only if found unreferenced after the garbage lock is
     removed.
    
      @param cls The class that manages the data.
      @param data An arbitrary data to be passed to the garbage collector.
      @return A GCLock entity to control when the item becomes disposeable.
    */
   GCLock* storeLocked( const Class* cls, void* data );

   /** Locks an item.
    * @see GCLock
    */
   GCLock* lock( const Item& item );

   /** Unlocks a locked item. */
   void unlock( GCLock* lock );

#if FALCON_TRACE_GC
   /** Debug version of store.

      This specialization of store() saves an entry in the activity log of the
      garbage collector.

    Please refer to store() and to the class documentation for further details.

     @param cls The class that manages the data.
     @param data An arbitrary data to be passed to the garbage collector.
     @param file The file where the storage was done.
    @param line the line where the storage was done.
    @return the token associated with this storage.

    */
   GCToken* H_store( const Class* cls, void* data, const String& file, int line );

  /** DebugVersion of storeLocked().

   This specialization of storeLocked() saves an entry in the activity log of the
   garbage collector.

   Please refer to storeLocked() and to the class documentation for further details.

   @param cls The class that manages the data.
   @param data An arbitrary data to be passed to the garbage collector.
    @param file The file where the storage was done.
    @param line the line where the storage was done.
    @return A GCLock entity to control when the item becomes disposeable.

    */
   GCLock* H_storeLocked( const Class* cls, void* data, const String& file, int line );

   /** Returns true if activity tracing system is on.
    \return true if the tracing facility is active.
    \note this method is available only when FALCON_TRACE_GC macro is defined
    at compile time.
    */
   bool trace() const;

   /** Changes the tracing status of a collector.
      \param t True to enable tracing, false to disable it.

    Disabling and enabling tracing in a program at random spots may
    cause spurious critical error detection, or might miss serious errors,
    as the collector would not be able to determine if the event sequence
    is correct.

    It is advisable to enable and then eventually disable the tracing facility
    once per run at maximum.

    As marking and destroying untraced object is ignored, relevant errors involving
    objecsts created before the tracing option was enabled might go undetected.
    When in doubt, enable tracign since the beginning of the program, before
    doing anything else with Falcon engine. OTOH, when the source of problems
    is well identified (i.e. a module under testing), it is perfectly viable to
    enable tracing just before the problematic code section.

    \note Activating the trace through this method will also activate mark
    event tracing. If this is not desired, traceMark(false) must be invoked
    after each trace(true).

      \note this method is available only when FALCON_TRACE_GC macro is defined
    at compile time.

    */
   void trace( bool t );

   /** Returns true if activity tracing system is on -- relatively to the mark operation.
    \return true if the tracing facility is active.

    This method describes wether mark events are traced in the History Trace
    or not. Mark events are pretty numerous and they may grow the memory dedicated
    to tracing by many order of magnitudes, while the vital information is usually
    in the sequence of creation and destruction of items.

    However, even if the trace recording is disable, a formal check for the data
    pointer to be valid is always performed if trace() is active and traceMark()
    is disabled. Just, in this case the history of the various GC marking performed
    on the data is not recorded and cannot be inspected at a later time.

    \note this method is available only when FALCON_TRACE_GC macro is defined
    at compile time.
    */
   bool traceMark() const;

   /** Changes the tracing status of mark events in collector.
      \param t True to enable tracing, false to disable it.

       This method determines wether mark events are traced in the History Trace
    or not. Mark events are pretty numerous and they may grow the memory dedicated
    to tracing by many order of magnitudes, while the vital information is usually
    in the sequence of creation and destruction of items.

    However, even if the trace recording is disable, a formal check for the data
    pointer to be valid is always performed if trace() is active and traceMark()
    is disabled. Just, in this case the history of the various GC marking performed
    on the data is not recorded and cannot be inspected at a later time.

    Contrarily to trace(), this method may be invoked multiple times to activate
    and disactivate mark tracing at random in a program without compromising the
    validity of the checks that are performed.

      \note this method is available only when FALCON_TRACE_GC macro is defined
    at compile time.

    */
   void traceMark( bool t );

   
   /** Dumps all the history information on a selected device.
    \param target The TextWriter where to write the informaton.

    \note this method is available only when FALCON_TRACE_GC macro is defined
    at compile time.
    */
   void dumpHistory( TextWriter* target ) const;

   /** Enumeration receiving DataStatus entities.
    */
   typedef Enumerator<DataStatus> DataStatusEnumerator;

   /** Enumerates all the data-status.
    \param r The enumerator that will receive the DataStatus items one at a time.

    \note this method is available only when FALCON_TRACE_GC macro is defined
    at compile time.
    */
   void enumerateHistory( DataStatusEnumerator& r ) const;

   /** Gets the history of a single pointer that was delegated to the GC.
      \param pointer the data of which the history need to be known.
      \return A valid DataStatus entry or 0 if the pointer was never handled.

    The pointer in the parameter must be the address of a data that was passed
    to the H_store or H_storeLocked methods. Notice that it is possible that
    a destroyed data pointer was used more than once to hold different data
    (and even different data type); the history entries will then report
    multiple creation and destruction events. However, a creation event cannot
    follow another creation event if the pointer wasn't destroyed in the meanwhile,
    and similarly a destruction event cannot be followed by anything but another
    creation event.

    If the method returns 0, either the pointer was never seen by an H_* method
    or trace() was not active when the pointer was handled.

   \note this method is available only when FALCON_TRACE_GC macro is defined
    at compile time.

    */
   DataStatus* getHistory( const void* pointer ) const;

   /** Clears all the trace events recorded up to date.
    This destroys all the entries recored by the history tracing systems.
    
    New events on previously existing pointers will be ignored.

    \note this method is available only when FALCON_TRACE_GC macro is defined
    at compile time.

    */
   void clearTrace();
#endif

protected:

   size_t m_thresholdNormal;
   size_t m_thresholdActive;

   /** Minimal generation.
      Items marked with generations lower than this are killed.
   */
   uint32 m_mingen;

   /** Alive and possibly collectable items are stored in this ring. */
   GCToken *m_garbageRoot;

   /** Newly created and unreclaimable items are stored in this ring. */
   GCToken *m_newRoot;

   /** A place where to store tokens for recycle. */
   GCToken *m_recycleTokens;
   int32 m_recycleTokensCount;
   Mutex m_mtx_recycle_tokens;


   /** The machine with the oldest generation loop checked out. */
   VMachine *m_olderVM;

   /** Ring of VMs */
   VMachine *m_vmRing;

   int32 m_vmCount;

   /** List of VM in idle state and waiting to be inspected */
   VMachine *m_vmIdle_head;
   VMachine *m_vmIdle_tail;

   // for gc
   uint32 m_generation;
   int32 m_allocatedItems;
   uint32 m_allocatedMem;

   SysThread *m_th;
   bool m_bLive;

   Event m_eRequest;
   Mutex m_mtxa;


   /** Mutex for newly created items ring.
      - GarbageableBase::nextGarbage()
      - GarbageableBase::prevGarbage()
      - m_generation
      - m_newRoot
      - rollover()
      \note This mutex is acquired once while inside  m_mtx_vms.lock()
   */
   mutable Mutex m_mtx_newitem;

   /** Mutex for the VM ring structure.
      - VMachine::m_nextVM
      - VMachine::m_prevVM
      - m_vmRing
      - electOlderVM()   -- call guard
      - advanceGeneration()
   */
   Mutex m_mtx_vms;

   /** Mutex for the idle VM list structure.
      Guards the linked list of VMs being in idle state.

      - VMachine::m_idleNext
      - VMachine::m_idlePrev
      - m_vmIdle_head
      - m_vmIdle_tail
   */
   Mutex m_mtx_idlevm;

   /** Guard for ramp modes. */
   mutable Mutex m_mtx_ramp;

   RampMode* m_ramp[RAMP_MODE_COUNT];
   RampMode* m_curRampMode;
   int m_curRampID;

   Mutex m_mtxRequest;
   Event m_eGCPerformed;
   bool m_bRequestSweep;

   /** Mutex for locked items ring. */
   Mutex m_mtx_lockitem;

   /** Locked and non reclaimable items are stored in this ring.  */
   GCLock *m_lockRoot;

   GCLock *m_recycleLock;
   int32 m_recycleLockCount;
   Mutex m_mtx_recycle_locks;

   //==================================================
   // Private functions
   //==================================================
   void gcSweep();

   void clearRing( GCToken *ringRoot );
   void rollover();
   void remark(uint32 mark);
   void electOlderVM(); // to be called with m_mtx_vms locked

   void promote( uint32 oldgen, uint32 curgen );
   void advanceGeneration( VMachine* vm, uint32 oldGeneration );
   void markLocked();
   void disposeLock( GCLock* lock );
   void disposeToken(GCToken* token);

   void addGarbageLock( GCLock* lock );
   void removeGarbageLock( GCLock* lock );

   // Gets a new or pre-allocated token
   GCToken* getToken( Class* cls, void* data );

   // Marks the newly created items.
   void markNew();

   // True to activate runtime trace.
   bool m_bTrace;
   bool m_bTraceMarks;
   
private:

   mutable Mutex m_mtx_history;
   
   void onCreate( const Class* cls, void* data, const String& file, int line );
   void onMark( void* data );
   void onDestroy( void* data );

   class Private;
   Private* _p;
};

}

#endif
/* end of collector.h */
