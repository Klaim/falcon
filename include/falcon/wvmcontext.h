/*
   FALCON - The Falcon Programming Language.
   FILE: wvmcontext.h

   Falcon virtual machine -- waitable VM context.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Sat, 15 Jan 2011 11:36:42 +0100

   -------------------------------------------------------------------
   (C) Copyright 2011: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

#ifndef FALCON_WVMCONTEXT_H_
#define FALCON_WVMCONTEXT_H_

#include <falcon/setup.h>
#include <falcon/vmcontext.h>
#include <falcon/mt.h>

namespace Falcon {

class TextReader;
class String;

/** Waitable virtual machine context.
 *
 * This is an extended front-end to the Falcon engine
 * that simplifies the writing of embedded scripts in applications.
 *
 * Instead of programming the raw process of loading a main module
 * through a process, then launching it in the executor process, this
 * executor-in-a-box can take care of loading or evaluating scripts from
 * VFS (virtual file systems) or texts.
 *
 */
class FALCON_DYN_CLASS WVMContext: public VMContext
{
public:
   WVMContext( Process* prc, ContextGroup* grp=0 );
   virtual ~WVMContext();

   /** Calls and immediately send to process execution this function. */
   void start( Function* f, int32 np = 0, Item const* params=0 );

   /** Calls and immediately send to process execution this function. */
   void start( Closure* closure, int32 np=0, Item const* params=0 );

   /** Calls and immediately send to process execution this item. */
   void startItem( const Item& item, int32 np=0, Item const* params=0 );

   /** Access the event that will be signaled on operation completion. */
   Event* completeEvent() const { return m_evtComplete; }

   /** Wait for the completion event to be signaled.
    *
    * If an error is thrown in the context, the waiter will be waken up
    * and the error will be re-thrown in the caller's context.
    *
    * If this is not desired, wait directly on completeEvent(), then check
    * completionError() to be zero (all OK) or nonzero (something was thrown).
    *
    * \note: The WVMContext class wraps uncaught raised items into a CodeError.
    * The original raised item can still be found in the VMContext::raisedItem() method,
    * while the original error is found VMContext::in thrownError(). So the following rules
    * apply:
    * - If an item was raised and the context exits because it's uncaught, completionError() is
    *   an CodeError instance, and thrownError() is 0.
    * - If the context exits on a raised error, thrownError() is nonzero and completionError() is the same.
    * - If something external (third party code, WVMExtension) explicitly calls completeWithError(),
    *   thrownError() is zero and raisedItem() is nil.
    */
   bool wait(int32 to=-1) const;

   /** Wait for the completion event to be signaled */
   bool tryWait() const { return wait(0); }

   /** Callback function for context completion. */
   typedef void (*complete_cbfunc)(WVMContext* ctx, void* data);

   /** Declares a function that will be invoked when the processing is complete. */
   void setOnComplete( complete_cbfunc func, void* data=0 );

   virtual void gcPerformMark();

   /** Access the return value of the completed processing. */
   const Item& result() const { return m_result; }

   virtual void onComplete();

   /** Error that caused the waitable context to terminate.
    *
    * If this is nonzero after eventComplete()::wait() returns, then the
    * context was terminated with error. The error may be raised because:
    * - explicitly raised item in code. In this case thrownError() is zero,
    *   and completionError() already holds an CodeError instance.
    * - internal error generated by the run code (as a math, I/O or access error).
    *   In this case, thrownError() and completionError() are the same.
    * - direct call of completeWithError(). In this case, thrownError() is zero,
    *   and raisedItem() is nil.
    *
    * \note the wait() method will automatically throw this error if it's nonzero.
    */
   Error* completionError() const { return m_completionError; }

   /** Terminates the context with error.
    *
    * \param error The error that causes the termination of the context.
    *
    * This method raises the completion event and thus asks the
    * processor to swap out the context as soon as possible, while
    * indicating that the cause of the premature exit is an error.
    *
    * This is similar to what is done to a VMContext when it is
    * terminated by an error, but automates some of the customizable
    * behaviors that are configurable in a basic VMContext.
    *
    * \note The given error is increffed. If another error was previously
    * given to the WVMContext this way, it's decreffed.
    */
   void completeWithError( Error* error );

   /** Compiles and start the evaluation of the given code.
    *
    * \param script A source code to be evaluated.
    *
    * To know when the evaluation complete, the caller should have already registered
    * a completion callback routine via setOnComplete(), or wait for completion via
    * the wait() method.
    *
    * \note In case of error. Throw.
    */
   void startEvaluation( const String& script );

   void startEvaluation( TextReader* tr );

   void reset();
private:
   Event* m_evtComplete;
   complete_cbfunc m_completeCbFunc;
   void* m_completeData;

   class PStepComplete;
   friend class PStepComplete;
   PStep* m_stepComplete;

   class PStepErrorGate;
   PStep* m_stepErrorGate;

   Item m_result;
   Error* m_completionError;

   Function* m_baseFrame;

   // A module used to store globals and mantras that might be dynamically defined.
   Module* m_defhub;
};

}

#endif /* FALCON_VMCONTEXT_H_ */

/* end of wvmcontext.h */
