/*
   FALCON - The Falcon Programming Language.
   FILE: QVMContext.h

   Falcon virtual machine -- queued VM context.
   -------------------------------------------------------------------
   Author: AlexRou

   -------------------------------------------------------------------
   (C) Copyright 2014: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

#ifndef FALCON_QVMCONTEXT_H_
#define FALCON_QVMCONTEXT_H_

#include <falcon/setup.h>
#include <falcon/vmcontext.h>
#include <falcon/mt.h>
#include <falcon/itemarray.h>

namespace Falcon
{

class TextReader;
class String;

/** Waitable virtual machine context.
 *
 * This is an extended front-end to the Falcon engine
 * that simplifies the writing of embedded scripts in applications.
 *
 * Instead of programming the raw process of loading a main module
 * through a process, then launching it in the executor process, this
 * executor-in-a-box can take care of loading or evaluating scripts from
 * VFS (virtual file systems) or texts.
 *
 */
class FALCON_DYN_CLASS QVMContext: public VMContext
{
	public:
		QVMContext( Process* prc, ContextGroup* grp = 0 );
		virtual ~QVMContext();

		/** Calls and immediately send to process execution this function. */
		void start( Function* f, int32 np = 0, Item const* params = 0 );

		/** Calls and immediately send to process execution this function. */
//		void start( Closure* closure, int32 np = 0, Item const* params = 0 );

		/** Calls and immediately send to process execution this item. */
		void startItem( const Item& item, int32 np = 0, Item const* params = 0 );

		/** Wait for the completion event to be signaled.
		 *
		 * If an error is thrown in the context, the waiter will be waken up
		 * and the error will be re-thrown in the caller's context.
		 *
		 * If this is not desired, wait directly on completeEvent(), then check
		 * completionError() to be zero (all OK) or nonzero (something was thrown).
		 *
		 * \note: The QVMContext class wraps uncaught raised items into a CodeError.
		 * The original raised item can still be found in the VMContext::raisedItem() method,
		 * while the original error is found VMContext::in thrownError(). So the following rules
		 * apply:
		 * - If an item was raised and the context exits because it's uncaught, completionError() is
		 *   an CodeError instance, and thrownError() is 0.
		 * - If the context exits on a raised error, thrownError() is nonzero and completionError() is the same.
		 * - If something external (third party code, WVMExtension) explicitly calls completeWithError(),
		 *   thrownError() is zero and raisedItem() is nil.
		 */
		bool wait( int32 to = -1 ) const;

		/** Callback function for context completion. */
		typedef void ( *complete_cbfunc )( QVMContext* ctx, void* data );

		/** Declares a function that will be invoked when the processing is complete. */
		void setOnComplete( complete_cbfunc func, void* data = 0 );

		virtual void gcPerformMark();

		/** Access the return value of the completed processing. */
        ItemArray result()
		{
		    ItemArray tmp = m_result;
		    m_result.clear();
			return tmp;
		}

		virtual void onComplete();

		/** Error that caused the waitable context to terminate.
		 *
		 * If this is nonzero after eventComplete()::wait() returns, then the
		 * context was terminated with error. The error may be raised because:
		 * - explicitly raised item in code. In this case thrownError() is zero,
		 *   and completionError() already holds an CodeError instance.
		 * - internal error generated by the run code (as a math, I/O or access error).
		 *   In this case, thrownError() and completionError() are the same.
		 * - direct call of completeWithError(). In this case, thrownError() is zero,
		 *   and raisedItem() is nil.
		 *
		 * \note the wait() method will automatically throw this error if it's nonzero.
		 */
		Error* completionError() const
		{
			return m_completionError;
		}

		/** Terminates the context with error.
		 *
		 * \param error The error that causes the termination of the context.
		 *
		 * This method raises the completion event and thus asks the
		 * processor to swap out the context as soon as possible, while
		 * indicating that the cause of the premature exit is an error.
		 *
		 * This is similar to what is done to a VMContext when it is
		 * terminated by an error, but automates some of the customizable
		 * behaviors that are configurable in a basic VMContext.
		 *
		 * \note The given error is increffed. If another error was previously
		 * given to the QVMContext this way, it's decreffed.
		 */
		void completeWithError( Error* error );

		void reset();
	private:
		Event* m_evtComplete;
		complete_cbfunc m_completeCbFunc;
		void* m_completeData;

		class PStepComplete;
		friend class PStepComplete;
		PStep* m_stepComplete;

		class PStepErrorGate;
		PStep* m_stepErrorGate;

		ItemArray m_result;
		Error* m_completionError;

		Function* m_baseFrame;

		// A module used to store globals and mantras that might be dynamically defined.
		Module* m_defhub;

		ItemArray m_items;
};

}

#endif /* FALCON_VMCONTEXT_H_ */

/* end of QVMContext.h */
