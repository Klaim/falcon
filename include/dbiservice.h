/*
   FALCON - The Falcon Programming Language.
   FILE: dbiservice.h

   Short description
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Sun, 23 Dec 2007 19:22:38 +0100
   Last modified because:

   -------------------------------------------------------------------
   (C) Copyright 2004: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
   In order to use this file in its compiled form, this source or
   part of it you have to read, understand and accept the conditions
   that are stated in the LICENSE file that comes boundled with this
   package.
*/

#ifndef DBI_SERVICE_H
#define DBI_SERVICE_H

#include <falcon/engine.h>
#include <falcon/service.h>

namespace Falcon
{

class CoreArray;
class VMachine;
class String;

/** Abstraction of transaction class.
   The transaction class is the minimal operative interface unit towards the database.
   It represents a single database transaction. Through this class, queries can be
   performed, results can be fetched and changes can be commited.

   Some databases are mono-transaction (one transaction per connection). For those
   databases, opening new transactions except the default one is considered an error,
   and will raise an error at script level.

   DBITransactions may live either inside the DBIHandle class that originated them
   (representing the "default" transaction of the DB), or can be stored into
   wrapping CoreObjects fors cripts.
*/

class DBITransaction: public UserData
{
public:
 typedef enum {
      s_ok,
      s_error
   }
   dbt_status;

   /** Launches a query */
   virtual dbt_status query(const String &query )=0;

   /** Fetch a result row */
   virtual dbt_status fetch( CoreArray *resultCache )=0;

   /** Fetch the row headers */
   virtual dbt_status fetchColumns( CoreArray *resultCache )=0;

   // Note: add methods to retreive single values at will.
   // the methods should accept an item to fill and the VM as parameters
   // VM is not necessary when receiving a core array, as the array has a pointer to the VM.

   /** Commits operations. */
   virtual dbt_status commit()=0;

   /** Rollback the transaction. */
   virtual dbt_status rollback()=0;

   /** Close the transaction.
      This tells the DB API that this transaction will not be used anymore.
      \note Subclasses desctructor must take care to properly close the
            transaction if it's still open at object destruction.
      \note the instances are often required to be closed through their
            database handlers. The subclasses should have an owner field
            and perform closing through the close( DBITransaction *) method
            of the owner.
   */
   virtual void close()=0;

   /** Returns last error and its description.
      Internal codes and possibly their meaning are written in the description
      field, while dbt_status return the status generated by the last operation.
      If the last exit code was s_ok, nothing is written in description.
      \param description a string where to write last error description
      \return the last operation status
   */
   virtual dbt_status getLastError( String &description )=0;
};

/** Base class for handlers.
   This class holds handle to database connections.

   Database drivers must derive this and provide specific handlers
   towards given connections.

   Shared connection management (i.e. persistent connections, resource
   condivisions and so on) must be handled at driver level; at user
   level, each instance of database object must receive a different
   handler.

   The handle is derived from UserData as it is likely to be assigned
   to a CoreObject.
*/
class DBIHandle: public UserData
{
public:
   typedef enum {
      s_ok,
      s_single_transaction,
      s_error
   }
   dbh_status;

   DBIHandle() {}
   virtual ~DBIHandle() {}

   /** Starts a new transaction.
      It is legal to return the default transaction even for mono-transaction db.
      If more than one transaction is asked for non-transactional dbs, a
      s_single_transaction error is set in the class, and 0 is returned.
      \return a DBITransaction instance on success,
              0 on error (use getLastError to determine what happened).
   */
   virtual DBITransaction *startTransaction()=0;

   /** Closes a transaction.
      Once called this method, the subclasses should forget about
      the given transaction object: it will be disposed by the caller.
      This even if the close operation wasn't succesful.

      \param tr the transaction to be closed.
      \return s_ok on success, an error on failure.
   */
   virtual dbh_status closeTransaction( DBITransaction *tr )=0;


   /** Returns last error and its description.
      Internal codes and possibly their meaning are written in the description
      field, while dbt_status return the status generated by the last operation.
      If the last exit code was s_ok, nothing is written in description.
      \param description a string where to write last error description
      \return the last operation status
   */
   virtual dbh_status getLastError( String &description )=0;

   /** Disconnects this handle from the database */
   virtual dbh_status close()=0;
};

/** Base class for database providers.
   Database provider services must derive from this class and subscribe
   their module with different names.
*/
class DBIService: public Service
{
protected:
   DBIService( const String &name ):
      Service( name )
   {}

public:

   typedef enum {
      s_ok,
      s_error,
      s_memory_alloc_error,
      s_connect_failed
   }
   dbi_status;

   /** Initialization hook.
      It gets called as soon as the service is loaded. It may be used by the
      module to initialize global data.
      \return s_ok if initialization is succesfull or error.
   */
   virtual dbi_status init()=0;

   /** Initialization hook
      It gets called as soon as the service is loaded. It may be used by the
      module to initialize global data.

      The function returns a DBIHandle because some driver may want to re-use
      already existing DBI handles if they are capable to perform concurrent
      operations and if the connection parameters are compatible with already
      existing connections.

      \note add doc on connection parameters
      \param parameters the connection parameters.
      \param persistent true if the DBIHandle may be one already served DBI handle,
         false if it should anyhow be created anew.
      \param retval error code if necessary
      \param errorMessage error description if necessary and available
      \return a configured DBIHandle or 0 on error.
   */
   virtual DBIHandle *connect( const String &parameters, bool persistent, 
                               dbi_status &retval, String &errorMessage )=0;

   /** Creates an instance of database handle for Falcon scripts.
      This function creates a core object getting the DBI database handler subclass
      managed by the providing module.

      It can't fail.
   */
   virtual CoreObject *makeInstance( VMachine *vm, DBIHandle *dbh ) = 0;
};

/** Service used to load DBI modules.
   This service is meant as an utility and is mainly used internally by the DBI module.
   It resolves the module names, checks if they are currently loaded in the VM and, if not,
   loads and links them.
*/
class DBILoader: public Service
{
protected:
   DBILoader( const String &name ):
      Service( name )
   {}

public:
   /** Loads the required provider and returns the service it provides.
      If the service is already present in the VM, that service is returned instead.
      The VM is used as the error handler of the loader that will load the modules,
      so, in case of errors, the VM will be notified with a standard module loading
      error.

      \return a DBIService instance or 0
   */
   virtual DBIService *loadDbProvider( VMachine *vm, const String &provName )=0;

};

class DBIError: public ::Falcon::Error
{
public:
   DBIError():
      Error( "DBIError" )
   {}

   DBIError( const ErrorParam &params  ):
      Error( "DBIError", params )
      {}
};

}

#endif

/* end of dbiservice.h */
