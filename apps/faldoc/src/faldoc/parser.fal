/*
   FALCON - Documentation tool

   FILE: faldoc_parser.fal

   Autodocumentation tool - parser code main file
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Thu, 10 Jan 2008 08:12:57 -0800

   -------------------------------------------------------------------
   (C) Copyright 2008: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

load .parser_c
load .blexer
import Parser from parser.faldoc.falsrc as FalParser
import Parser from parser.faldoc.generic as GenericParser
import Parser from parser.faldoc.txt as TxtParser


//load regex

import currentFile, currentLine

function fileParse( filename )
   global currentFile, currentLine

   p = Path( filename )
   currentFile = p.filename
   
   broadcast( "message", @ "Parsing file: $filename" )

   // before each file retract automatic properties
   retract( "current_module" )
   retract( "current_set" )
   retract( "current_group" )

   if currentFile.endsWith( ".fal" )
      parser = FalParser()
   else
      parser = GenericParser()
   end
   
   try
      stream = InputStream( filename )
      ctx = parser.parseStream( stream )
   catch IoError in err      
      broadcast ( "warn", err.toString() )
   end
   
   if stream: stream.close()

   node = ctx.topNode.content
   txtparser = TxtParser()
   cur_entity = nil
   
   while node
      // faldoc TXT always creates an entity, which may be then re-configured afterwards
      if node.type == "faldoc_txt"
         try
            ctxNode = txtparser.parse( node.content, "start", node.infos["line"] )
            // if the context is made exclusively of global commands, they are not generating a node.
            if not processGlobalCommands( ctxNode )
               de = DocEntity( filename, node.infos[line] )
               de.content = node.content
               de.pcontent = ctxNode
               de.processContent()
               // the current entity on which declarations are applied is this one.
               cur_entity = de
            end
         catch ParseError in e
            broadcast("warn", "Can't properly parse entity at line " + node.infos["line"] )
         end
      end
      
      node = node.next
   end
end 

function processGlobalCommands( ctx )
   node = ctx.topNode.content

   while node
      switch node.type
      
         case "@begingroup"
            node = beginCmd( "group", node )

         case "@beginset"
            node = beginCmd( "set", node )

         case "@beginmodule"
            node = beginCmd( "module", node )

         case "@endgroup"
            node = endCmd( "group", node )

         case "@endset"
            node = endCmd( "set", node )

         case "@endmodule"
            node = endCmd( "module", node )

         default
            node = node.next
   end

   // was this block just a global command?
   return ctx.topNode.content == nil
end

function beginCmd( what, node )
   an = "current_" + what
   
   if (grp = getAssert( an, nil ))
      broadcast( "warn", @"Already in $what \"$grp\" when declaring @begin$what at line " + node.infos["line"] )
   end
   assert( an, node.infos["name"] )
   n1 = node.next
   node.remove()
   return n1
end

function endCmd( what, node )
   an = "current_" + what

   if not (grp = getAssert( an, nil ))
      broadcast( "error", @"No active $what when declaring @end$what at line " + node.infos["line"] )
   else
      retract( an, node.infos["name"] )
   end
   
   n1 = node.next
   node.remove()
   return n1
end


function addAutoProps()
   // add automatic property
   if (set = getAssert( "current_set", nil )) and self.checkProperty( "inset", false )
      l =  Link( self.elem, self.lexer.nline, set )
      l.membership = "funset"
      self.elem.props["inset"] = l
   end

   if (grp = getAssert( "current_group", nil )) and self.checkProperty( "ingroup", false )
      l = Link( self.elem, self.lexer.nline, grp )
      l.membership = "group"
      extendList( self.elem.props, "ingroup", l )
   end

   if (module = getAssert( "current_module", nil )) and self.checkProperty( "inmodule", false )
      l = Link( self.elem, self.lexer.nline, module )
      l.membership = "module"
      self.elem.props["inmodule"] = l
   end
end


export fileParse
