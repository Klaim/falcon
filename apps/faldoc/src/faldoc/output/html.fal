/*
   FALCON - Documentation tool

   FILE: faldoc_output_html.fal

   Autodocumentation tool - HTML output module
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Sat, 12 Jan 2008 12:21:30 +0100

   -------------------------------------------------------------------
   (C) Copyright 2008: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

import from web.htmaker in ht
import from parser.render.html in render

// The faldoc_output function must be provided by all output modules
function faldoc_output( doctree, conf )
   HTMLGenerator( doctree, conf ).go()
end

function _htmlEscape( string )
   return string.replace( "&", "&amp;" ).replace( "<", "&lt;").replace(">", "&gt;").replace("\"", "&quot;")
end

class FaldocHtmlRenderer() from render.Renderer()
   level = 0
   
   init
      self.renderers += [
         "@section" => self.renderSection,
         "@note" => self.renderNote,
         "@a" => self.render_a
      ]
   end

/*
   function render( context )
      content = self.rcont( context.topNode )
      return content
   end
*/

   function renderSection( node )
      hl = self.level + 2
      title = _htmlEscape(node.infos["title"])
      link = strEscape(node.infos["name"])
      
      prefix = @"<h$(hl)><a name=\"$(link)\">$(title)</a></h$(hl)>\n"
      ++self.level
      content = self.rcont(node)
      --self.level

      // the level will be closed when necessary
      return prefix + content
   end

   function renderNote( node )
      content = self.rcont( node )
      return i"<b>Note:</b> "+ content + "\n"
   end

   function render_a( node )
      l = node.infos["link"]
      return HTMLGenerator.makeLink( l )
   end

end


class HTMLGenerator( doctree, conf )
   doc = doctree
   conf = bless(conf)
   basedir = faldoc.config.basedir
   directory = "directory" in conf ? conf["directory"] : nil
   htmltitle = "title" in conf ? conf["title"] : doctree.title
   baseurl = "url" in conf ? conf["url"] : nil
   encoding = "encoding" in conf? conf["encoding"] : "utf-8"

   _rndr = FaldocHtmlRenderer()
   //_htframe = ht.TransitionalFrame
   _htframe = ht.XHTMLFrame
   

   _entityHandler = [
      "object" => self.makeObject,
      "class" => self.makeClass,
      "enum" => self.makeEnum
   ]

   //# represents the section order
   _moduleOrder =  .[
      .["object" i"Objects" i"Object"]
      .["class" i"Classes" i"Class"]
      .["function" i"Functions" ""]
      .["global" i"Variables" "" ]
      .["enum" i"Enumerations" i"Enum"]
      .["message" i"Messages" ""]
   ]
   
   
   function go()
      faldoc.info( "=" * 60 )
      faldoc.info( "HTML Generator module started." )
      
      if not self.directory
         faldoc.error( i"html output - Missing mandatory parameter \"directory\"" )
         return false
      end
      
      fpath = Path()
      fpath.fulloc = self.directory
      if not fpath.fulloc.startsWith("/")
         self.directory = self.basedir + "/" + self.directory
      end

      faldoc.info( "html output - Writing to " + self.directory )

      try
         // prepare the directory
         dirMake( self.directory, true )
         
         // the index page is generated together with all the entity pages it points to.
         self.makeIndex()

      catch IoError in err
         faldoc.error( "html.fal: " + err )
         return
      end
      
      faldoc.info( "HTML Generator module ended." )
      faldoc.info( "=" * 60 )
   end
   
   //# Generates the index pages and all the entities reachable from there.
   function makeIndex()
   
      // Creating the index.
      file = OutputStream( self.directory + "/index.html" )
      doc = self._htframe()

      doc.html.head = self.makeHead( self.doc.title, i"Index" )

      // Each entity in the main module is inserted as a LI.
      struct = ht.OL()
      // Creates the structure listing of the main module
      self.makeStruct( struct, self.doc )
      for modname, module in self.doc.getAllModules()
         substruct = ht.OL()
         // Create the structure listing of the submodules
         title = self.makeStruct( substruct, module )
         //... each of which is a sub-element of the main structure.
         listruct = ht.LI()
         listruct.add(title)
         listruct.add(substruct)
         struct.add( listruct )
      end

      faldoc.info( i"Index document generation complete." )

      // Put the index at the top 
      doc.html.body = ht.Body().CLASS("faldoc").add(
         ht.H1( self.doc.title ),
         struct )

      // Then add the main page.

      // finally, render the index
      doc.render( file )
      file.close()
   end


   //===============================================================
   // Handlers
   //===============================================================


   function makeEntity( entity )
      faldoc.verbose( @i"Making entity $(entity.type) $(entity.name)" )

      if entity.type in self._entityHandler
         self._entityHandler[ entity.type ]( entity )
      end
   end


   function makeObject( entity )
      self.makeObjectoid( entity, i"Object", true )
   end

   function makeClass( entity )
      self.makeObjectoid( entity, i"Class", true )
   end

   function makeEnum( entity )
      self.makeObjectoid( entity, i"Enumeration" )
   end


   function makeObjectoid( entity, typeName, proto )
      faldoc.verbose( @i"Making objectoid $(entity.type) $(entity.name)" )

      file = OutputStream( self.directory +"/"+ self.getFileName( entity ) )
      doc = self._htframe()

      // pretty sure we have a title
      title = typeName + " " + entity.name
      doc.html.head = self.makeHead( self.doc.title, title )
      doc.html.body = ht.Body().CLASS("faldoc").add(
            ht.H1( title ),
            self.makeBrief( entity ) )

      if proto
         self.makePrototype( doc.html.body, entity, typeName )
      end

      doc.html.body.add( self.makeContent( entity ) )
         
      if entity.members
         members = entity.membersByType()
         // we know we have at least a member, so we have a table.
         doc.html.body.add( self.makePropsTable( members ) )
         // then print the properties and the methods.
         // make the property list
         if "property" in members
            faldoc.verbose( @i"Making properties of objectoid $(entity.type) $(entity.name)" )
            doc.html.body.add( ht.H2( i"Properties" ) )
            for prop in members["property"]
               self.makeIntraPageMember( doc.html.body,  prop )
            end
         end

         // then print the properties and the methods.
         // make the property list
         if "method" in members
            faldoc.verbose( @i"Making methods of objectoid $(entity.type) $(entity.name)" )
            doc.html.body.add( ht.H2( i"Methods" ) )
            for prop in members["method"]
               self.makeIntraPageMember( doc.html.body,  prop )
            end
         end
      end

      // see also...
      if "see" in entity.props
          doc.html.body.add( self.makeSeeAlso( entity.props["see"] ) )
      end

      doc.render( file )
      file.close()
   end


   function makeIntraPageMember( struct, entity )
      // add the title
      struct.add( ht.H3().add( ht.A().set( ["name"=>entity.name] ).add(entity.name ) ) )
      // add the brief
      struct.add( self.makeBrief( entity ) )
      // add the prototype
      if entity.type == "function" or entity.type == "method"
         self.makePrototype( struct, entity )
      end

      // finally, add the body
      struct.add( self.makeContent( entity ) )
      
      // see also...
      if "see" in entity.props
         struct.add( self.makeSeeAlso( entity.props["see"] ) )
      end
   end


   function makePage( entity )
      faldoc.verbose( @i"Making page $(entity.type) $(entity.name)" )

      file = OutputStream( self.directory +"/"+ self.getFileName( entity ) )
      doc = self._htframe()

      // pretty sure we have a title
      title = entity.props["title"]
      doc.html.head = self.makeHead( self.doc.title, title )
      
      body = ht.Body().CLASS("faldoc").add(
         ht.H1( title ),
         self.makeBrief( entity ),
         self.makeContent( entity )
         )

      if entity.members
         members = entity.membersByType()

         // Create the entities using a consistent order.
         for type, listName, ename in self. _moduleOrder
            if type in members
               mlist = members[type]
               body.add( ht.H2( listName ) )

               // if the entity is heavy, just place a link
               if ename
                  elemList = ht.UL().CLASS("memberlist")
                  for entity in mlist
                     elemList.add( self.makeMemberLink( entity ) )
                  end
                  body.add( elemList )
               else
                  // it's light. Add the entities.
                  for entity in mlist
                     self.makeIntraPageMember( body, entity )
                  end
               end
            end
         end
      end

      // see also...
      if "see" in entity.props
         body.add( self.makeSeeAlso( entity.props["see"] ) )
      end

      doc.html.body = body
      doc.render( file )
      file.close()
   end


   function makeBrief( entity )
      if "brief" in entity.props
         content = self._rndr.rcont( entity.props["brief"] )
         if content: return ht.P().CLASS("brief").add( ht.Verbatim( content ) )
      end
      return ^+ ""
   end


   function makePrototype( struct, entity, typeName )

      proto = entity.prototype()
      if typeName: proto = typeName + " " + proto
      protoEntry = ht.Pre().CLASS("prototype").add( proto )
      
      if "from" in entity.props
         fr = entity.props["from"]
         protoEntry.add( " from " )
         for link, callexp in fr
            linkcal = self.makeLink( link )
            cexp = callexp? "(" + self._rndr.rcont( callexp ) + ")" : ""
            protoEntry.add( "\\\n                 " )
            protoEntry.add(linkcal)
            protoEntry.add(cexp)
         end
      end

      struct.add( protoEntry )
      table = self.makePrototable( entity )
      if table
         struct.add(table)
      end
   end



   function makePrototable( entity )
      tbody = nil
      if "param" in entity.props
         tbody = ht.TBody()
         for paraName, paraContent in entity.props["param"]
            tbody.add( ht.TR().CLASS("param").add(
               ht.TD().CLASS("name").add( paraName ),
               ht.TD().CLASS("content").add( ht.Verbatim(self._rndr.rcont( paraContent )) )
               ))
         end
      end
      
      if "optparam" in entity.props
         if not tbody: tbody = ht.TBody()
         for paraName, paraContent in entity.props["optparam"]
            tbody.add( ht.TR().CLASS("optparam").add(
               ht.TD().CLASS("name").add( paraName ),
               ht.TD().CLASS("content").add( ht.Verbatim(self._rndr.rcont( paraContent )) )
               ))
         end
      end

      
      if "return" in entity.props
         if not tbody: tbody = ht.TBody()
         tbody.add( ht.TR().CLASS("return").add(
            ht.TD().CLASS("name").add( i"Return" ),
            ht.TD().CLASS("content").add( ht.Verbatim(self._rndr.rcont( entity.props["return"] )) )
            ))
      end

      if "raise" in entity.props
         if not tbody: tbody = ht.TBody()
         tb2 = ht.TBody()
         for link, content in entity.props["raise"]
            tb2.add( ht.TR().add(
               ht.TD().CLASS("name").add( self.makeLink( link ) ),
               ht.TD().CLASS("content").add( ht.Verbatim(self._rndr.rcont( content )) )
               ))
         end
         tbody.add( ht.TR().CLASS("raise").add(
               ht.TD().add( i"Raise" ),
               ht.TD().CLASS("content").add( ht.TABLE().add(tb2) )
            ))
      end

      if tbody
         return ht.TABLE().CLASS( "prototype" ).add( tbody )
      end
   end


   function makePropsTable( members )
      table = nil
      if "property" in members
         table = ht.TABLE().CLASS( "members" )
         self.makePropsTablePart( table, i"Properties", members["property"] )
      end
      if "method" in members
         if not table: table = ht.TABLE().CLASS( "members" )
         self.makePropsTablePart( table, i"Methods", members["method"] )
      end
      return table
   end

   function makePropsTablePart( table, title, members )
      tbody = ht.TBody()
      tbody.add( ht.TR().add( ht.TD( title ).set( ["colspan" => 2, "CLASS"=>"member_type"] ) ) )
      for prop in members
         tdName = ht.TD().add( ht.A( "#" + prop.name, prop.name ) )
         row = ht.TR().add( tdName )
         if "brief" in prop.props
            row.add( ht.TD().add( ht.Verbatim( self._rndr.rcont( prop.props["brief"] ) ) ) )
         else
            tdName.set(["colspan"=>2])
         end
         tbody.add(row)
      end
      table.add( tbody )
   end


   function makeSeeAlso( seeList )
      para = ht.P(i"See also" + ": ").CLASS("see_also")
      for link, content in seeList
         para.add( self.makeLink(link) )
         formiddle: para.add( ", " )
         forlast: para.add( "." )
      end
      return para
   end

   function makeLink( l )
      // ingore links to empty elements.
      if l.target
         target = l.target
         
         if "title" in l.target.props
            text = target.props["title"]
         else
            text = l.destination
         end
         return ht.A( self.getLinkName( target ), text )
      else
         return ht.B( l.destination )
      end
   end


   function makeContent( entity )
      if entity.pcontent
         content = self._rndr.rcont( entity.pcontent.topNode )
         if content: return ht.Verbatim( content )
      end
      return ^+ ""
   end
   
   //===============================================================
   // Utilities
   //===============================================================

   /*# Creates the structured listing of a module.
      @return The title of the module, formatted for output.
   */
   function makeStruct( struct, module )
      pages = module.orderPages()

      faldoc.verbose( @i"Making pages for $module.name" )
      title = ""
      for page in pages
         if page.type == "main"
            title = page.props["title"]
         end
         struct.add( self.makeStructNode( page ) )
         self.makePage( page )
      end
      
      entities = module.groupEntities()
      faldoc.verbose( @i"Making entities for $module.name" )
      for type, type_title, type_name in self._moduleOrder
         faldoc.verbose( @i"Making entities of type $type for $module.name" )
         
         if type_name
            // it's an heavy object.
            if type in entities
               faldoc.verbose( @i"Found heavy entities of type $type" )
               for entity in entities[type]
                  faldoc.verbose( @i"Making entity " + entity.getID() )
                  struct.add( self.makeStructNode( entity, type_name ) )
                  self.makeEntity( entity )
               end
            end
         else
            // they are light objects
            if self.makeLightTypes( module, type, type_title, entities )
               // Yes, we did that page.
               // (we may not do that if all the entities are grouped).
               faldoc.verbose( @i"Found some light entity of type $type" )
               struct.add( ht.LI().add( ht.A(self.getFilenameForType( type, module ), type_title ) ))
            end
         end
      end

      modid = module.getID()
      if title
         title += " " + @i"(module $modid)"
      else
         title = @i"Module $modid"
      end

      if "brief" in module.props
         title += " - " + module.props["brief"]
      end
      
      return title
   end

   function makeLightTypes( module, type, type_title, entities )
      if not type in entities: return false
      done = false
      entlist = entities[type]
      
      for ent in entlist
         if ent.parent != module or "inset" in ent.props or "ingroup" in ent.props
            continue
         end

         // we have found an ungrouped entity!
         if not done
            done = true
            file = OutputStream( self.directory +"/"+ self.getFilenameForType( type, module ) )
            doc = self._htframe()
            doc.html.head = self.makeHead( self.doc.title, type_title )
            doc.html.body = ht.Body().CLASS("faldoc").add( ht.H1( type_title ) )
         end

         self.makeIntraPageMember( doc.html.body, ent )
      end

      if done
         // finally, render the index
         doc.render( file )
         file.close()
      end
      
      return done
   end
   
   function makeStructNode( entity, prefix )
      if "title" in entity.props
         text = entity.props["title"]
      else
         text = prefix ? prefix + " " + entity.name : entity.name
      end

      li = ht.LI()
      li.add( ht.A( self.getFileName(entity, true), text.trim() ) )
      if "brief" in entity.props
         li.add( " - " + self._rndr.rcont(entity.props["brief"]) )
      end

      return li
   end

   // Gets the filename, and eventually the link position, where an entity should be placed.
   function getFileName( entity, forlink )
      if entity.type == "property" or entity.type == "method"
         if entity.parent
            return entity.parent.getID().replace( ".", "_" ) + ".html" + (forlink ? "#" + entity.name : "")
         end
      // only functions and variables, when in groups, are hosted in the parent item.
      elif "ingroup" in entity.props and not self.isFat(entity)
         return entity.parent.members[entity.props["ingroup"]].getID().replace( ".", "_" ) + ".html" + (forlink ? "#" + entity.name : "")
      // function sets own their items.
      elif "inset" in entity.props
         return entity.parent.members[entity.props["inset"]].getID().replace( ".", "_" ) + ".html" + (forlink ? "#" + entity.name : "")

      // Unbound functions and globals have their own file.
      elif not self.isFat( entity )
         filename = self.getFilenameForType( entity.type, entity.parent )
         if forlink: filename += "#" + entity.name
         return filename         

      // otherwise, the entity has its own name (but "#main" should be "main").
      else
         return entity.getID().replace( ".", "_" ).replace("#", "") + ".html"
      end
   end

   //# Return the filename of pages holding types (functions, messages, variables...)
   function getFilenameForType( type, parent )
      if parent
         filename = parent.getID().replace(".","_")
      else
         filename = "__"
      end
      filename += "_" + type + ".html"

      return filename
   end
         

   function getLinkName( entity )
      return self.getFileName( entity, true )
   end

   //# Returns true if the entity is "massive", and should have its own page.
   function isFat( entity )
      static
         fatness = [
            "object" => true,
            "class" => true,
            "enum" => true,
            "group" => true,
            "page" => true,
            "funset" => true,
            "main" => true,
            "module" => true ]
      end

      return entity.type in fatness
   end

   function makeHead( category, itemName )
      title = category + itemName ? " - " + itemName : ""
      
      return ht.Head().add(
         ht.Meta( nil, "text/html;charset=\"$(self.charset)\"", "Content-type" ),
         ht.Link( "faldoc.css", "stylesheet", "text/css"),
         ht.Title( title ))
   end

   //# Creates a node to be directly added in a member list (OL of class "memberlist")
   function makeMemberLink( member )
      node = ht.LI().add( ht.A( self.getFileName(member, true ), member.name ) )
      if "brief" in member.props
         brief = self._rndr.rcont(member.props["brief"])
         if brief: node.add( " - " ).add( ht.Verbatim( brief ) )
      end
      return node
   end
end
