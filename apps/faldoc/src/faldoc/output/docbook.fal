/*
   FALCON - Documentation tool

   FILE: docbook.fal

   Autodocumentation tool - DOCBOOK output module
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Sat, 12 Jan 2008 12:21:30 +0100

   -------------------------------------------------------------------
   (C) Copyright 2008: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

import from parser.render.docbook in docbook

// The faldoc_output function must be provided by all output modules
function faldoc_output( doctree, conf )
   DOCBOOKGenerator( doctree, conf ).go()
end

class FaldocBookRenderer( frame ) from docbook.Renderer( frame )
   init
      self.renderers += [
         "@section" => self.renderSection,
         "@note" => self.renderNote,
         "@a" => self.render_a
      ]
   end

   function render( context )
      content = self.rcont( context.topNode )
      return content
   end

   function renderSection( node )
      level = self.blevel
      front = self.make_section( level+1, node.infos["name"], node.infos["title"] )
      content = self.rcont(node)
      back = self.go_to_level( level )
      
      // the level will be closed when necessary
      return front + content + back
   end

   function renderNote( node )
      content = self.rcont( node )
      return "<note><para>" + content + "</para></note>\n"
   end
   
   function render_a( node )
      return "[@a node, todo]"
   end
         
end

class DOCBOOKGenerator( doctree, conf )
   doc = doctree
   conf = bless(conf)
   basedir = faldoc.config.basedir
   frame = nil
   file = "file" in conf ? conf["file"] : nil
   encoding = "encoding" in conf? conf["encoding"] : "utf-8"
   copyyear = "copyright.year" in conf? conf["copyright.year"] : nil
   copyholder = "copyright.holder" in conf? conf["copyright.holder"] : nil

   //# Level of the document.
   docLevel = 0
   
   _outfile = nil

   _rndr = nil

   _entityHandler = [
      "page" => self.makePage,
      "variable" => self.makeGlobal,
      "object" => self.makeObject,
      "class" => self.makeClass,
      "function" => self.makeFunction,
      "group" => self.makeGroup,
      "funset" => self.makeFunset,
      "enum" => self.makeEnum,
      "message" => self.makeMessage
   ]

   //# represents the section order
   _moduleOrder =  .[
      "page" "group" "funset"
      .["object" i"Objects"]
      .["class" i"Classes"]
      .["function" i"Functions"]
      .["variable" i"Variables"]
      .["enum" i"Enumerations"]
      .["message" i"Messages" ]
   ]
   
   init
      inspect (conf )
      if "frame" in conf
         switch conf["frame"]
            case "article"
               self.frame = docbook.ArticleFrame( self.encoding )
            case "book"
               if self.file: fname = fileName( self.file )
               self.frame = docbook.BookFrame( self.encoding, fname, self.doc.title, self.doc.author, self.copyyear, self.copyholder )
            case "article5"
               if self.file: fname = fileName( self.file )
               self.frame = docbook.Article5Frame( self.encoding )
            case "book5"
               if self.file: fname = fileName( self.file )
               self.frame = docbook.Book5Frame( self.encoding, fname, self.doc.title, self.doc.author, self.copyyear, self.copyholder )
            default
               self.frame = docbook.ArticleFrame( self.encoding )
         end
      end

      self._rndr = FaldocBookRenderer( self.frame )
   end
   
   function go()
      faldoc.info( "=" * 60 )
      faldoc.info( "DOCBOOK Generator module started." )

      if not self.file
         faldoc.error( i"docbook output - Missing mandatory parameter \"file\"" )
         return false
      end

      fpath = Path(self.file)
      if not fpath.fulloc.startsWith("/")
         self.file = self.basedir + "/" + self.file
      end

      faldoc.info( "docbook output - Writing to " + self.file )

      try
         self._outfile = OutputStream( self.file )
         self._outfile.setEncoding( self.encoding )
         self._outfile.writeText( self.frame.open() )

         // each element of the main module is a chapter
         self.docLevel = 0
         self.makeModule( self.doc.mainModule )

         // other modules must be in their own chapter.
         self.docLevel = 1
         for modname, module in self.doc.modules
            self.makeModule( module )
         end

         self._outfile.writeText( self.frame.close() )
      catch IoError in err
         faldoc.error( "docbook.fal: " + err )
         return
      end

      if self._outfile: self._outfile.close()
      faldoc.info( "DOCBOOK Generator module ended." )
      faldoc.info( "=" * 60 )
   end


   function makeModule( module )

      self._outfile.writeText(self.frame.openSection(0))

      if "#main" in module.entities
         main = module.entities["#main"]
         self.writeTag( "title", main.props["title"] )
         self._outfile.writeText( self._rndr.render( main.pcontent ) )
      end

      entities = module.groupEntities()
      for etype in self._moduleOrder
         if etype.typeId() == StringType
            self.makeEntityList( etype, entities ) 
         else
            self.makeEntityPage( etype[0], etype[1], entities )
         end
      end


      self._outfile.writeText( self._rndr.go_to_level(0) )
      self._outfile.writeText(self.frame.closeSection(0))
   end
      
   //===============================================================
   // Handlers
   //===============================================================
   function makeEntityList( etype, entities )
      if etype in entities
         maker = self._entityHandler[ etype ]
         for entity in entities[ etype ]
            maker( entity )
            //# todo - remove grouped entities.
         end
      end
   end
   
   function makeEntityPage( etype, chapName, entities )
      if etype in entities
         dl = self.docLevel
         self.docLevel ++
         // section heading -- no need for xref here.
         self._outfile.writeText( self._rndr.make_section( self.docLevel, "", chapName ) )

         maker = self._entityHandler[ etype ]
         for entity in entities[ etype ]
            maker( entity )
         end
         
         self.docLevel = dl
      end
   end
   
   function makePage( entity )
      self._outfile.writeText( self._rndr.make_section( self.docLevel + 1, entity.name, entity.props["title"] ) )
      self._outfile.writeText( self._rndr.render( entity.pcontent ) )
   end
   
   function makeGlobal( entity )
   end
   
   function makeObject( entity )
      self._outfile.writeText( self._rndr.make_section( self.docLevel + 1, entity.name, entity.name ) )
      data = self._rndr.render( entity.pcontent )
      // at least one para is mandatory in every section
      self._outfile.writeText( data = "" ? "<para/>\n" : data )
   end
   
   function makeClass( entity )
      self._outfile.writeText( self._rndr.make_section( self.docLevel + 1, entity.name, entity.name ) )
      data = self._rndr.render( entity.pcontent )
      // at least one para is mandatory in every section
      self._outfile.writeText( data == "" ? "<para/>\n" : data )
   end
   
   function makeFunction( entity )
      self._outfile.writeText( self._rndr.make_section( self.docLevel + 1, entity.name, entity.name ) )
      data = self._rndr.render( entity.pcontent )
      // at least one para is mandatory in every section
      self._outfile.writeText( data == "" ? "<para/>\n" : data )
   end
   
   function makeGroup( entity )
   end
   
   function makeFunset( entity )
   end
   
   function makeEnum( entity )
   end
   
   function makeMessage( entity )
   end
   
   //===============================================================
   // Utilities
   //===============================================================
   
   function opentag( tag )
      self._outfile.writeText( @"<$tag>\n" )
   end
   
   function closetag( tag )
      self._outfile.writeText( @"</$tag>\n" )
   end

   function write( xtag )
      self._outfile.writeText( xtag.render() )
   end
   
   function writeTag( tag, content, attribs )
      content = _htmlEscape(content)
      att = ""
      for k,v in attribs
         forfirst: att = " "
         att += k + '="' + v.replace('"', '\"') + '"'
         formiddle: att += " "
      end

      if not content
         self._outfile.writeText( "<"+ tag + att +"/>\n" )
      else
         self._outfile.writeText( "<"+ tag + att +">" + content + "</"+tag+">\n" )
      end
   end
   
end

function _htmlEscape( content )
   return content.replace( "&", "&amper").replace( "<", "&lt;" ).replace( ">", "&gt;" ).replace("\"", "&quot;" )
end


class Tag( tag, content, attribs )
   attribs = attribs
   tag = tag
   content = content

   function render()
      if self.content.typeId() == StringType
         content = _htmlEscape(self.content)
      else
         content = ""
         for tag in self.content
            content += tag.render()
         end
      end
      
      att = ""
      for k,v in self.attribs
         forfirst: att = " "
         att += k + '="' + v.replace('"', '\"') + '"'
         formiddle: att += " "
      end

      if not content
         self._outfile.writeText( "<"+ tag + att +"/>\n" )
      else
         self._outfile.writeText( "<"+ tag + att +">" + content + "</"+tag+">\n" )
      end
   end
end

