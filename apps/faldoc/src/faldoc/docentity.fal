/*
   FALCON - Documentation tool

   FILE: docentry.fal

   Autodocumentation tool - basic entry item.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Sat, 23 May 2009 12:19:38 +0200

   -------------------------------------------------------------------
   (C) Copyright 2009: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

import from struct.tree

/*# Entity class.

   A document entity is a single entry in the documentation
   file. It can be a page, a section, a class, an object,
   a function, a method, or in general any entity that can be
   indexed and cross-linked.

   An entity is made of multiple paragraph and has multiple
   properties. It's type and name cannot always be determied
   at creation (actually, that is rare), and is usually
   assigned after the whole entity documentation text have
   been parsed.

   Entities can be hierarchically organized into different
   relationship groups:
   - parent - children; ownership relationship, like properties and methods for classes.
   - group - members: Multiple grouping where each group can have a list of members, but
     a member can be present in multiple groups.s

   Parent-children relationships are described through a pair of property
   (parent and children), while grouping is expressed through entries in
   the @a self.props property (with the property "in<entity type>" => "<entity id>".

   The @a self.props property contains many important elements, as the parameters.
   Parameters entry (under props
*/

class Entity( content, file, line )

   //# Type of the entity
   type = nil
   /*# Local name of the entity. */
   name = nil
   /*# Filename where the entity is coming from. */
   file = file
   
   /*# First line of comment declaration of the entity. */
   firstline = line
   /*# Line at which the entity is defined at language level (if any). */
   dline = nil

   props = bless([=>])

   //# Module of this entity, if any
   module = nil

   /*# Parsed content.
      Documentation of the entity parsed as an infonode.
   */
   pcontent = nil

   //# Textual (unparsed) content. For debugging and reference
   content = content

   //# Non-child members (for entities with grouping abilities)
   members = nil

   //# Calculates the unique ID of this node.
   function getID()
      if self.parent
         return self.parent.getName() + "." + self.name
      end

      return self.name
   end

   /*# Processess the commands in the parsed content block.
      @param onGroupingChange callback receiving line, command and name in case of grouping commands.
      @return false if this entity is actually a set of document-wide command and should not be considered
              a real document entity.
              
      @note Interesting commands are at top level. Everything else (inline commands)
      is expanded by the generic parser into DOM entities or is made to "stand out".
   */
   function parseContent( onGroupingChange )
      return self.parseNodeContent( self.pcontent.topNode.firstChild, onGroupingChange )
   end

   function parseNodeContent( node, onGroupingChange )
      
      while node != nil

         // go deep before proceeding
         if node.firstChild
            // ignore the result of the analisys of the first-level children.
            self.parseNodeContent( node.firstChild, onGroupingChange )
         end
         
         isASimpleCommand = false
         line = node provides infos ? node.infos["line"] + self.firstline - 1 : self.firstline
         
         switch node.type
            case "@a"
               node.infos["link"] = self.addLink( node.infos["dest"], line, true )
               node = node.next
               
            case "@raise", "@from", "@see"
               l = self.addLink( node.infos["what"], line, node.type == "@see" )
               // we trick the system a bit and send a link instead of a name here.
               // however, it's ok and wors as expected
               self.addParam( node.type[1:], l, node, line )
               node = node.remove()
               
            case "@brief", "@return"
               self.props[ node.type[1:] ] = node
               node = node.remove()

            case "@param", "@optparam"
               self.addParam( node.type[1:], node.infos["name"], node, line )
               node = node.remove()

            case "@inset"
               if "inset" in self.props
                  faldoc.error( "Function set already declared for entity \"$name\"", line )
               else
                  self.props["inset"] = node.infos["name"] 
               end
               node = node.remove()
            
            case "@inmodule"
               if self.module
                  faldoc.error( "Module already declared for entity \"$name\"", line)
               else
                  self.module = faldoc.document.getModule( node.infos["name"] )
               end
               node = node.remove()

            case "@ingroup"
               gname = node.infos["group"]
               if "ingroup" in self.props
                  groups = self.props["ingroup"]
                  if gname in groups
                     faldoc.error( "Group \$gname already declared for entity \"$name\"", line)
                  else
                     groups.add( gname )
                  end
               else
                  self.groups = [gname]
               end
               node = node.remove()

            case "@begingroup", "@beginset", "@beginmodule"
               onGroupingChange( line, node.type, node.infos["name"] )
               isASimpleCommand = true
               node = node.remove()

            case "@endgroup", "@endnset", "@endmodule"
               onGroupingChange( line, node.type, nil )
               isASimpleCommand = true
               node = node.remove()
               
            // we have the type defined!
            case "@class", "@function", "@object", "@enum", "@global"
               self.name = node.infos["name"]
               self.type = node.type[1:]
               node = node.remove()

            case "@method", "@property"
               self.name = node.infos["name"]
               self.type = node.type[1:]
               self.cls = node.infos["class"]
               node = node.remove()

            case "@page"
               self.name = node.infos["name"]
               self.type = "page"
               self.props[ "title" ] = node.infos["title"]
               node = node.remove()

            case "@group", "@funset"
               self.name = node.infos["name"]
               self.type = node.type[1:]
               self.props[ "title" ] = node.infos["title"]
               isASimpleCommand = true
               node = node.remove()

            case "@main"
               self.name = "#main"
               self.type = "main"
               node = node.remove()

            case "cmd_unrecognized"
               command = node.infos["cmd"]
               faldoc.error( @i"Unrecognized command \"$command\"", node.infos["line"] )
               node = node.remove()

            default
               node = node.next
         end
      end
      
      return not isASimpleCommand
   end


   function addLink( dest, line, explicit )
      l = Link( self, line, dest, explicit )
      if "links" in self.props
         self.props["links"].add( l )
      else
         self.props["links"] = [l]
      end
      return l
   end
      

   //# Adds a parameter or similar multiple entry in properties.
   function addParam( type, name, content, line )

      // First, a special control for parameters and optional parameters which relate to each other
      if type == "param" and "optparam" in self.props and arrayScan( self.props["optparam"], {elem => elem[0] == name} ) >= 0
         faldoc.error( @i"Parameter \"$name\" of type already declared as optparam", line )
         return
      elif type == "optparam" and "param" in self.props and arrayScan( self.props["param"], {elem => elem[0] == name} ) >= 0
         faldoc.error( @i"Optional parameter \"$name\" of type already declared as parameter", line )
         return
      end

      // the add the property
      if type in self.props
         vt = self.props[type]

         if arrayScan( vt, {elem => elem[0] == name} ) >= 0
            faldoc.error( @i"Property \"$name\" of type \"$type\" already declared", line )
         else
            vt.add( [name, content] )
         end
      else
         self.props[type] = [[name, content]]
      end
      
   end

   //# Adds a parameter declared in the function prototype
   function addFoundParam( name, content, line )
      vtp = "param" in self.props ? self.props["param"] : nil
      vto = "optparam" in self.props ? self.props["optparam"] : nil

      foundParam = vtp and arrayScan( vtp, {elem => elem[0] == name} ) != -1
      foundOpt = vto and arrayScan( vto, {elem => elem[0] == name} ) != -1

      if not foundParam and not foundOpt
         faldoc.warn( @i"Formal parameter \"$name\" not referenced in text block", line )
         self.addParam( "param", name, nil, line )
      end
   end

   //# adds a member
   function addMember( entity, ownership )
      if ownership
         entity.parent = entity
      end
      
      if not self.members
         self.members = [entity.name=> entity]
      else
         if entity.name in self.members
            faldoc.error( @i"Re-Adding member $entity.name to $self.name", entity.dline )
         else
            self.members[entity.name] = entity
         end
      end
   end

   function membersByType()
      data = [=>]
      for member in self.members
         if member.type in data
            data[member.type].add( member )
         else
            data[member.type] = [member]
         end
      end
   end

   function prototype()
      pars = ""
      if "param" in self.props
         pars = ", ".merge(map( {x=> x[0]}, self.props["param"]))
      end
      if "optparam" in self.props
         if pars: pars += ", "
         pars += ",".merge( map( {x=> "[" + x[0] + "]"}, self.props["optparam"]) )
      end

      if pars
         return self.name + "( " + pars + " )"
      else
         if self.type == "function" or self.type == "method"
            return self.name + "()"
         else
            return self.name
         end
      end
   end
   
end


export
