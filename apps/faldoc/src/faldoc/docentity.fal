/*
   FALCON - Documentation tool

   FILE: docentry.fal

   Autodocumentation tool - basic entry item.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Sat, 23 May 2009 12:19:38 +0200

   -------------------------------------------------------------------
   (C) Copyright 2009: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

/*# Entity class.

   A document entity is a single entry in the documentation
   file. It can be a page, a section, a class, an object,
   a function, a method, or in general any entity that can be
   indexed and cross-linked.

   An entity is made of multiple paragraph and has multiple
   properties. It's type and name cannot always be determied
   at creation (actually, that is rare), and is usually
   assigned after the whole entity documentation text have
   been parsed.

   Entities can be hierarchically organized into different
   relationship groups:
   - parent - children; ownership relationship, like properties and methods for classes.
   - group - members: Multiple grouping where each group can have a list of members, but
     a member can be present in multiple groups.s

   Parent-children relationships are described through a pair of property
   (parent and children), while grouping is expressed through entries in
   the @a self.props property (with the property "in<entity type>" => "<entity id>".

   The @a self.props property contains many important elements, as the parameters.
   Parameters entry (under props
*/

class DocEntity( file, line, parent )

   //# Type of the entity
   type = nil
   /*# Local name of the entity. */
   name = nil
   /*# Filename where the entity is coming from. */
   file = file
   
   /*# First line of comment declaration of the entity. */
   firstline = line
   /*# Line at which the entity is defined at language level (if any). */
   dline = nil

   /*# Is this entity created out of a real language construct?. */
   hard = false

   props = bless([=>])
   parent = nil
   children = nil

   //# Module of this entity, if any
   module = nil

   //# function set of this entity, if any
   funset = nil
   
   //# Groups of this entity (an array), if any
   groups = nil
   
   /*# Textual content of the entity.
      This is the document tree that should be rendered for the
      description of the node.
   */
   content = nil

   /*# Parsed content.
      Documentation of the entity parsed as an infonode.
   */
   pcontent = nil

   init
      if parent
         parent.addChild( self )
      end
   end

   //# Defines the entity and stores it in the database.
   function define( type, name, line )
      if (self.type != nil or self.name != nil)
         // we don't care about re-definitions
         if self.type != type or self.name != name
            broadcast( "error", @i"Entity \"$name\"/$type doesn't match previous definition at line $line"
         end
         return
      end
            
      self.type = type
      self.name = name
      self.dline = line

      EntityDB.add( self )
   end

   //# Calculates the unique ID of this node.
   function getID()
      if self.parent
         return self.parent.getName() + "." + self.name
      end

      return self.name
   end
   
   function addChild( child )
      if self.children == nil
         self.children = [child]
      else
         self.children += child
      end
      child.parent = self
   end

   function addMember( member )
      if self.children == nil
         self.children = [child]
      else
         self.children += child
      end
   end

   /*# Processess the commands in the parsed content block.

      @note Interesting commands are at top level. Everything else (inline commands)
      is expanded by the generic parser into DOM entities or is made to "stand out".
   */
   function parseContent()
      node = self.pcontent.topNode.content
      while node != nil
         switch node.type
            case "@brief", "@return"
               self.props[ node.type[1:] ] = node.content
               node = node.remove()

            case "@param", "@optparam", "@raise"
               self.addParam( node.type[1:], node.infos["name"], node.content, node.infos["line"] )
               node = node.remove()

            case "@see"
               link = EntryDB.link( self, node.infos["line"], node.infos["name"], true )
               self.addParam( "see", node.infos["name"], link )
               node = node.remove()

            case "@inset"
               if self.funset
                  broadcast( "error", "Function set already declared for entity \"$name\" at line $node.infos['line']")
               else
                  self.funset = self.groupIn( node.infos["name"], node.infos["line"] )
               end
               node = node.remove()
            
            case "@inmodule"
               if self.module
                  broadcast( "error", "Function set already declared for entity \"$name\" at line $node.infos['line']")
               else
                  self.module = self.groupIn( node.infos["name"], node.infos["line"] )
               end
               node = node.remove()

            case "@ingroup"
               if self.groups
                  self.groups.add( self.groupIn( node.infos["name"], node.infos["line"] ) )
               else
                  self.groups = [add( self.groupIn( node.infos["name"], node.infos["line"] ) )]
               end
               node = node.remove()
            
            default
               node = node.next
         end
      end
   end

   //# Put this object in a group
   function groupIn( name, line )
      link = EntryDB.link( self, line, name, true )
      // already resolved?
      if link.target: link.target.addMember( self )
      return link
   end

   //# Adds a parameter or similar multiple entry in properties.
   function addParam( type, name, content, line )

      // First, a special control for parameters and optional parameters which relate to each other
      if type == "param" and "optparam" in self.props and arrayScan( self.props["optparam"], {elem => elem[0] == name} ) >= 0
         broadcast( "error", @i"Parameter \"$name\" of type already declared as optparam at line $line" )
         return
      elif type == "optparam" and "param" in self.props and arrayScan( self.props["param"], {elem => elem[0] == name} ) >= 0
         broadcast( "error", @i"Optional parameter \"$name\" of type already declared as parameter at line $line" )
         return
      end

      // the add the property
      if type in self.props
         vt = self.props[type]

         if arrayScan( vt, {elem => elem[0] == name} )
            broadcast( "error", @i"Property \"$name\" of type \"$type\" already declared at line $line" )
         else
            vt.add( [name, content] )
         end
      else
         self.props[type] = [[name, content]]
      end
      
   end

   //# Adds a parameter declared in the function prototype
   function addFoundParam( name, content, line )
      vtp = "param" in self.props ? self.props["param"] : nil
      vto = "optparam" in self.props ? self.props["optparam"] : nil

      foundParam = vtp and arrayScan( vtp, {elem => elem[0] == name} ) == -1
      foundOpt = vto and arrayScan( vto, {elem => elem[0] == name} ) == -1

      if not foundParam and not foundOpt
         broadcast( "warn", @i"Formal parameter $name not referenced in text block" )
         addParam( "param", name, nil, line )
      end
   end
      
end



/*#
   A link between an entity and another one.
   @param source The entity that is searching for the link.
   @param line The line in file where the link is found.
   @param destination The target item of the link.
   @optparam automatic When false, the system will complain if not resolved.

   The link is created when a Generic Parser InfoNode of the proper type
   ("a") is found, or automatically when some other entities
   are parsed (i.e. "from" inheritance InfoNodes, "see" InfoNodes, "raise" and so on).

   The link is then added to the infonode as a "link" property, with one end
   referencing the entity where the infonode is located (source), and the other
   referencing a destination.

   If the destination exists when the link is created, it is immediately
   referenced.

   If it doesn't exist, an entry in the @a EntityDB.missing property is created,
   and the link is stored as the value of the missing dictionary, while the
   expected unique ID is set both as the destination of the link and as the
   key of the missing dictionary.

   When a new entity arrives, it is checked against the missing dictionary, and
   if a link is found there, the @a Link.target field gets referenced.

   
*/
class Link( source, line, destination, automatic )
   source = source
   line = line
   destination = destination
   automatic = automatic
   
   target = nil

   init
      EntityDB.addLink( self )
   end

   function toString()
      if self.target
         return self.target.toString()
      end

      return @"(undef at $(self.source.file):$(self.line)) " + self.destination
   end

   function describe()
      return (@ "$(self.destination) at $(self.source.file):$(self.line) ") + (self.target ? "(*)" : "(-)")
   end
end



/*# Database of all the defined entities. */
object EntityDB
   /*# All the data, organized by unique ID */
   data = [=>]

   //# Missing entities as unique ID -> link
   missing = [=>]
   
   /*# All the data, organized by type -> list of entities. */
   grouping = [=>]

   /*# Data in function sets. */
   sets = [=>]

   /*# Data in groups. */
   groups = [=>]

   /*# Data in modules. */
   modules = [=>]

   function add( entry )
      if not entry.derivedFrom( DocEntity )
         broadcast( "error", "Trying to add non-entity to EntityDB \"" +
               entry + "\" from: " + fself.caller() )
         return
      end

      if not entry.name
         broadcast( "error", entry.file, entry.firstline, "Entry declared at this line has no ID." )
         return
      end

      if not entry.type
         broadcast( "error", entry.file, entry.firstline, "Entry with ID " + entry.name + " has no type." )
         return
      end

      if "brief" notin entry.props
         try
            if prototypes.find( "type", entry.type, "brief")
               broadcast( "error", entry.file, entry.firstline, "Entry has no 'brief' description." )
            end
         end
         // but let it through
      end

      if entry.name in self.data
         other = self.data[entry.name]
         broadcast( "error", entry.file, entry.firstline, "Entry with ID " + entry.name +
                     @" already existing at $(other.file):$(other.firstline)" )
         return
      end

      self.data[ entry.name ] = entry
      extendList( self.grouping, entry.type, entry )

      // resolve links
      if entry.name in self.missing
         links = self.missing[entry.name]
         self.missing -= entry.name
         // is this entity a grouping entry? -- then, this link sources are our children.
         if (entry.type == "group" or entry.type == "funcset" or entry.type == "module")
            children = []
            for l in links
               l.target = entry
               children += l.source
            end
            entry.children = children
         else
            // else, we must just fill the link target
            for l in links
               l.target = entry
            end
         end

      end
   end

   
   //# Adds a single link
   function addLink( link )
      if link.destination in self.data
         link.target = self.data[link.destination]
      else
         self.missing.dop(link.destination, [], {v => v+= link})
      end
   end

   function link( sourceEntity, line, destination, automatic )
      l = Link( sourceEntity, line, destination, automatic )
      self.addLink( l )
      return l
   end

   function complete()
      for k,row in self.grouping: arraySort( row, { a,b => a.name.compare( b.name ) } )
      for k,row in self.sets: arraySort( row, { a,b => a.name.compare( b.name ) } )
      for k,row in self.groups: arraySort( row, { a,b => a.name.compare( b.name ) } )
      for k,row in self.modules: arraySort( row, { a,b => a.name.compare( b.name ) } )
   end
end

export
