/*
   FALCON - The Falcon Programming Language.
   FILE: parser/parser.h

   Parser subsystem main class.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Sat, 09 Apr 2011 17:36:38 +0200

   -------------------------------------------------------------------
   (C) Copyright 2011: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

#ifndef _FALCON_PARSER_PARSER_H_
#define	_FALCON_PARSER_PARSER_H_

#include <falcon/setup.h>
#include <falcon/string.h>
#include <falcon/enumerator.h>

namespace Falcon {
namespace Parser {

class Lexer;
class State;

/** Generic Falcon Parser class.

 A parser scan a text-oriented input stream applying a grammar in order to:
 - obtain an output.
 - modify a forming context.

 Falcon parser matches against an input stream that is pre-tokenized through a
 Lexer class which feeds back a continuous stream of TokenInstance which contain
 a Token definition and possibly a concrete value that the token assumes.

 The forming stream of tokens is matched against NonTerminal tokens which are
 organized in set of State instances; each state represents a list of
 alternative NonTerminal tokens that may be found in the input sequence.

 Each NonTerminal uses one or more Rule instacnes that describe various
 alternatives under which the given NonTerminal token is formed. Eventually,
 Terminal tokens or Literal tokens (tokens having an univoque value) which can
 be generated by the lexer, describe the NonTerminal tokens in terms of atomic
 input units.

 Each rule has an Apply function attached; when a rule is selected, that is, a
 sequence of tokens (either Terminal or NonTerminal) is found to be consisted with
 an higher-level NonTerminal token, the Apply function is applied, and the Rule
 may:
 - Transform the parsed tokens in a single higher level token, usually the token
 representing the NonTerminal exposing the rule, syntethizing a value out of the
 values that are attached to each token.
 - Push or pop a parser state.
 - Alter the forming context.
 - Signal error.

 */
class FALCON_DYN_CLASS Parser
{
public:
   /** Generates the parser.
    */
   Parser();
   virtual ~Parser();

   /** Adds a state to the known parser states.
    */
   void addState( State& state );

   /** Pushes a state.
    */
   void pushState( const String& name );

   /** Re-enables previous state.
   */
   void popState();

   /** Start the parsing process.
      \param mainState The state from which starting the parsing.
      \return true on success, false on error.
      \throw CodeError if the main state is not found, or if a lexer is not ready.

    Call this method after having called addState() and pushLexer().

    This method can be called multiple times, provided that all the lexers that
    might have been previously pushed are popped. 
    */
   bool parse( const String& mainState );

   /** Class used to store information about detected errors.

    This class is used by the parser to store persistent information about
    the errors detected while parsing a file.

    In case there are errors in the
    */
   class ErrorDef
   {
   public:
      /** Line where the error happened. */
      int nLine;
      /** Character where the error happened. */
      int nChar;
      /** Falcon Error code. */
      int nCode;
      /** Context information -- line where the failing context begun. */
      int nOpenContext;
      /** Extra information (error description is inferred through nCode). */
      String sExtra;
      /** Uri of the source stream. */
      String sUri;

      ErrorDef( int code, const String& uri, int l, int c, int ctx, const String& extra ):
         nLine(l),
         nChar(c),
         nCode(code),
         nOpenContext(ctx),
         sExtra( extra ),
         sUri( uri )
      {}

      ErrorDef( int code, const String& uri, int l, int c, int ctx=0  ):
         nLine(l),
         nChar(c),
         nCode(code),
         nOpenContext( ctx ),
         sUri( uri )
      {}

   };

   /** Callback functor receiving errors.
    */
   typedef Enumerator<ErrorDef> errorEnumerator;

   /** Enumerate received errors.
    In case parse returned false, calling this method will provide detailed
    error description for all the errors that have been found.
      \see Enumerator
    */
   void enumerateErrors( errorEnumerator& e );

   /** Sets a context data.
    \param ctx User specific context data.

    This context data can be used by user code to store information together
    with the parser as the parsing proceeds.

    This is a good place where to store data that must be accessed by the rules.
    */
   void setContext( void* ctx );

   /** Return the parser context.

    The context is user data that can be used by more specific parser code.
    */
   void* context() const { return m_ctx; }

   /** Pushes a new lexer.
    \param lexer The new lexer to be used from now on.

    Userful to support hard-inclusion, the new lexer punches in at current point.
    When the input terminates, the lexer is removed and the previous one continues
    to provide tokens.

    @Note: The lexer is owned by the parser; this means that it will be destroyed
    when going out of scope.
    */
   void pushLexer( Lexer* lexer );

   /** Removed current lexer.

    If the current lexer is also the topmost one, parsing is interrupted.
    The removed lexer is destroyed.
    */
   void popLexer();

   /** Adds an error for the parser.
      \param code The error code (as a falcon error code number).
      \param uri The URI of the stream or file where the error was detected.
      \param l The line where the error happened (1 based; 0 if the error was not detected on a specific line).
      \param c The character where the error happened (1 based; 0 if the error was not detected on a specific character).
      \param ctx The line where an error due to a remote line was first originated.
      \param extra Extra error description (beside the textual explanation of code).

      Once called, this method marks the current parsing as faulty, and parse() will return false.
    */
   void addError( int code, const String& uri, int l, int c, int ctx, const String& extra );

   /** Adds an error for the parser.

      \param code The error code (as a falcon error code number).
      \param uri The URI of the stream or file where the error was detected.
      \param l The line where the error happened (1 based; 0 if the error was not detected on a specific line).
      \param c The character where the error happened (1 based; 0 if the error was not detected on a specific character).
      \param ctx The line where an error due to a remote line was first originated.

    Once called, this method marks the current parsing as faulty, and parse() will return false.
    */
   void addError( int code, const String& uri, int l, int c=0, int ctx=0  );

protected:
   void* m_ctx;
   void parserLoop();
   
private:
   class Private;

   // Data that requires local instantation
   Private* _p;
};

}
}

#endif	/* _FALCON_PARSER_PARSER_H_ */

/* end of parser/parser.h */

