/*
   FALCON - The Falcon Programming Language.
   FILE: vm.h

   Falcon virtual machine.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Sat, 08 Jan 2011 18:46:25 +0100

   -------------------------------------------------------------------
   (C) Copyright 2011: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

#ifndef FALCON_VM_H
#define FALCON_VM_H

#include <falcon/setup.h>
#include <falcon/item.h>
#include <falcon/codeframe.h>
#include <falcon/callframe.h>
#include <falcon/vmcontext.h>
#include <falcon/string.h>

#define FALCON_VM_DFAULT_CHECK_LOOPS 5000

namespace Falcon {

class Error;
class LocationInfo;
class Stream;
class TextReader;
class TextWriter;
class Transcoder;

/** The Falcon virtual machine.
*/
class FALCON_DYN_CLASS VMachine
{

public:
   /** Events that may cause VM suspension or interruption. */
   typedef enum {
      /** All green, go on. */
      eventNone,
      /** Debug Breakpoint reached -- return. */
      eventBreak,
      /** Explicit return frame hit -- return. */
      eventReturn,
      /** Quit request -- get out. */
      eventTerminate,
      /** All the code has been processed -- get out. */
      eventComplete,
      /** Soft error raised -- manage it internally if possible. */
      eventRaise
   } t_event;

   /** Creates the virtual machine.
    \param stdIn Standard input stream used by the VM; if 0, will take a duplicate
    of the process standard input stream.
    \param stdOut Standard output stream used by the VM; if 0, will take a duplicate
    of the process standard output stream.
    \param stdErr Standard input stream used by the VM; if 0, will take a duplicate
    of the process standard error stream.

    The streams passed to the constructor are property of the virtual machine;
    they get destroyed (and closed) with it.

    If the script that should be run by this virtual machine is seen as the
    foreground process, the creator of this virtual machine should pass standard
    stream instances not duplicating the standard streams, so that the script
    can close the VM streams and that behavior is reflected to the process streams.
    */
   VMachine( Stream* stdIn = 0, Stream* stdOut=0, Stream* stdErr = 0 );
   virtual ~VMachine();

   //=========================================================
   // Context management
   //=========================================================

   inline VMContext* currentContext() const { return m_context; }

   //=========================================================
   // Execution management.
   //=========================================================

   /** Runs a prepared code, or continues running.
    * @return True if all the code was executed, false if a breakpoint forced to stop.
    *
    * This method runs the virtual machine until:
    * - All the code in the code stack is executed; or
    * - a break flag is set.
    *
    * In the second case, the method returns false.
    *
    * Notice that the effect of exit() is that of terminating the VM
    * cleanly; this will make this function to return true.
    */
   bool run();

   inline void call( Function* f, int np )
   {
      call( f, np, Item() );
   }

   /** Prepares the VM to execute a function (actually, a method).

    The VM gets readied to execute the function from the next step,
    which may be invoked via step(), run() or by returning from the caller
    of this function in case the caller has been invoked by the VM itself.
    @param function The function to be invoked.
    @param np Number of parameters that must be already in the stack.
    @param self The item on which this method is invoked. Pure functions are
                considered methods of "nil".
    */
   virtual void call( Function* function, int np, const Item& self );

   /** Returns from the current frame */
   void returnFrame();

   /** Returns the last event that was raised in this VM.
      @return The last event generated by the vm.
    */
   inline t_event event() const { return m_event; }

   /** Raises an item, throwing a soft-exception.

    Throwing a C++ exception can be time consuming, and shouldn't be done lightly.
    In case of langauge generated exceptions, it is better to rasie an item thorugh
    a soft-signal, so that the VM can handle the raised exeption without the need for
    a full stack unroll and CPU level longjump management.

    If the VM can't handle the raised item, a GenericError will be thrown at C++
    level by the main loop.
    */
   void raiseItem( const Item& item );

   /** Raises an error, throwing a soft-exception.

    Throwing a C++ exception can be time consuming, and shouldn't be done lightly.
    In case of langauge generated exceptions, it is better to rasie an item thorugh
    a soft-signal, so that the VM can handle the raised exeption without the need for
    a full stack unroll and CPU level longjump management.

    This operation boxes the error by wrapping it in a falcon object instance
    (using the handler class that the error provides; namely, Error::scriptize()
    is called). This also increfs the error.

    If the VM can't handle the raised error, it will be unboxed and rethrown as-is.
    */
   void raiseError( Error* error );

   /** Asks for a light termination of the VM.
    The VM immediately returns to the caller. The event is sticky; this means
    that intermediate callers will see this event set and propagate it upwards.
    */
   inline void quit() { m_event = eventTerminate; }

   /** Asks the VM to exit from its main loop.

    This is generally handled by a specific opcode that asks for the VM to
    exit its current main loop. The opcode may be inserted by special
    "atomic" calls. When such a call is made, if the called function needs
    to ask the VM to perform some calculation, then it can add this opcode
    to the code stack to be called back when the calculation is done.

    This is meant to be used internally by the engine and shouldn't be
    tackled by modules or external code.
    */
   inline void setReturn() { m_event = eventReturn; }

   /** Resets the event.
   */
   inline void clearEvent() { m_event = eventNone; }

   //=========================================================
   // Debug support
   //=========================================================

   /** Returns the step that is going to be executed next, or null if none.
    \return The next step that will be executed.
    */
   const PStep* nextStep() const;

   /** Performs a single step.
      @return true if there is another step ready to be executed,
         false if this was the last (i.e. if the VM is terminated).
    */
   bool step();

   /** Activates a breakpoint.

      Breaks the current run loop. This is usually done by specific
      breakpoint opcodes that are inserted at certain points in the code
      to cause interruption for debug and inspection.
   */
   inline void breakpoint() { m_event = eventBreak; }

      /** Gives a description of the location of the next step being executed.
    @return A string with a textual description of the source position of the
            next step being executed.

    This is a debug function used to indicate where is the next step being
    executed in a source file.
   */
   String location() const;

   /** Outlines VM status in a string.
    @return A string with a textual description of the VM status.

    This is a debug function used to indicate what's the current status of the
    virtual machine.
   */
   String report();

   /** Gives a description of the location of the next step being executed.
    @param infos An instance of LocationInfo receiving the debug information about
           the location in the source files of the next step.

    This information is more detailed and GUI oriented than the information
    returned by location().
    */
   bool location( LocationInfo& infos ) const;

   //=========================================================
   // General information.
   //=========================================================

   /** Raises a VM error.
    *
    * The method finds a try frame back in the code stack, and if it is found,
    * the control is moved to a suitable catch item.
    *
    * If a suitable catch frame is not found, the error is thrown as a C++ exception.
    *
    * \note Falcon exceptions are thrown by pointer. This is because the error entity
    * can be stored in several places, and in several threads, by the time it
    * surfaces to user code. This calls for reference management.
    */
   //void raiseError( Error* theError );


   /** Finds the variable corresponding to a symbol name in the current context.
    * @return A pointer to the item if found, 0 if not found.
    *
    * The search will be extended to global and imported symbols if the search
    * in the local symbol tables fails.
    */
   Item* findLocalItem( const String& name );

   /** Returns true if the current has not any code.

    */
   inline bool codeEmpty() const { return m_context->codeEmpty(); }

   /** Access the current context accumulator. */
   const Item& regA() const { return m_context->regA(); }
   /** Access the current context accumulator. */
   Item& regA() { return m_context->regA(); }

   //=========================================================
   // Deep call protocol
   //=========================================================

   /** Deep calls operand protocol -- part 1.

    The deep call protocol is used by falcon Function instances or other
    PStep* operands that are called by the virtual machine, and that may then
    call the virtual machine again.

    Some functions called by the virtual machine then need to call other functions that
    may or may not need the VM to perform other calculations.

    If a calculation that involves the Virtual Machine terminates immediately,
    the result is usually found in VMachine::topData(), and the caller can
    progress immediately.

    Otherwise, the caller needs to set a callback in the virtual machine so that
    it will be called back by it after the frame added by the called is
    entity is complete. Then, the result will be available in regA().

    But, the step should be on top of the code stack before the underluing called
    element has a chance to prepare its call frame. This means that normally a
    caller calling an operand that may or may not request a call frame should
    push its own callback on the code stack blindly, then eventually pop it if
    the called entity didn't push a new call frame.

    To avoid this on the most common situations where this may be required, a
    set of three metods are used by the operand implementations and a set of
    well defined functions known by the engine in the virtual machine.

    The caller sets a (non-destructible) PStep through the ifDeep() method.
    If the callee wants to add a frame, it calls goingDeep(), which does nothing
    if the caller didn't need to have a result from the called, but will store the
    PStep in the code stack otherwise.

    Then, the caller must check if the result is ready in topData() or if the
    processing must be delayed by calling wentDeep(); that method will also clear
    the readied PStep.

    To avoid this mechanism to be broken, ifDeep() raises an error if called
    while another PStep was readied.

    Of course, this mechanism cannot be used across context switches, but its
    meant for tightly coupled functions.
    */
   void ifDeep( const PStep* postcall );

   /** Called by a callee in a possibly deep call pair.
    @see ifDeep.
   */
   void goingDeep();

   /** Called by a calling method to know if the called sub-methdod required a deep operation.
    \return true if the sub-method needed to go deep.
    */
   bool wentDeep();

   //=========================================================
   // VM Streams
   //=========================================================

   /** Changes the standard input stream. 
    Previously owned standard input stream is closed and destroyed.
    */
   void stdIn( Stream* s );

   /** Changes the standard output stream.
    Previously owned standard output stream is closed and destroyed.
    */
   void stdOut( Stream* s );

   /** Changes the standard error stream.
    Previously owned standard error stream is closed and destroyed.
    */
   void stdErr( Stream* s );

   /** Returns current standard input stream.
    \return A valid standard input stream, owned by the VM.
    If needed elsewhere, the stream must be cloned().
   */
   inline Stream* stdIn() const { return m_stdIn; }

   /** Returns current standard input stream.
    \return A valid standard output stream, owned by the VM.
    If needed elsewhere, the stream must be cloned().
   */
   inline Stream* stdOut() const { return m_stdOut; }

   /** Returns current standard error stream.
    \return A valid standard error stream, owned by the VM.
    If needed elsewhere, the stream must be cloned().
   */
   inline Stream* stdErr() const { return m_stdErr; }

   /** Sets the standard encoding of streams.
    \param Encoding name as ISO encoding name.
    \return false if the given encoding is currently not served by the engine.

    The VM offers an utility TextReader to read from its standard input
    and TextWriter wrappers to write to its standard output and error
    streams.

    Applications are not required to use this readers/writers, but
    the standard library text based I/O functions use them.

    The text readers/writers are initialized to the system encoding, if it is
    possible to detect it and if the Transcoder is present in the Engine at the
    moment of VM creation.

    It is possible to change the transcoder used by the standard library text
    I/O routines anytime through the setStdEncoding() method. It is also possible
    to provide a custom transcoder, that can be disposed by the VM.

    \note The text writers used by the VM set their CRLF automatic transcoding
    option according to the host system, and with automatic flush at end-of-line;
    to change this setup, act directly on the TextWriters.

    */
   bool setStdEncoding( const String& name );

    /** Sets the standard encoding of streams using a custom transcoder.
     \param ts A transcoder instance.
     \param bOwn If true, the transcoder will be disposed by the VM at destruction.
     \see bool setStdEncoding( const String& name )
     */
   void setStdEncoding( Transcoder* ts, bool bOwn = false );

   /** Returns the TextReader accessing the standard input stream.
    \return A text reder.
    \see setStdEncoding
    */
   inline TextReader* textIn() const { return m_textIn; }

   /** Returns the TextReader accessing the standard input stream.
    \return A text reder.
    \see setStdEncoding
    \note The text writers used by the VM set their CRLF automatic transcoding
    option according to the host system, and with automatic flush at end-of-line;
    to change this setup, act directly on the TextWriters.
    */
   inline TextWriter* textOut() const { return m_textOut; }

   /** Returns the TextReader accessing the standard input stream.
    \return A text reder.
    \see setStdEncoding
    \note The text writers used by the VM set their CRLF automatic transcoding
    option according to the host system, and with automatic flush at end-of-line;
    to change this setup, act directly on the TextWriters.
    */
   inline TextWriter* textErr() const { return m_textOut; }


protected:

   Stream *m_stdIn;
   Stream *m_stdOut;
   Stream *m_stdErr;

   TextReader* m_textIn;
   TextWriter* m_textOut;
   TextWriter* m_textErr;

   Transcoder* m_stdCoder;
   bool m_bOwnCoder;

   /** Called back when an error was thrown directly inside the machine.
    \param e The error being thrown.
    */
   void onError( Error* e );

   /** Called back after the main loop gets a raiseItem().
    \param item The item being raised.
    */
   void onRaise( const Item& item );

private:
   
   // current context
   VMContext* m_context;

   // last raised event.
   t_event m_event;

   // used by ifDeep - goingDeep() - wentDeep() triplet
   const PStep* m_deepStep;
};

}

#endif

/* end of vm.h */
