/*
   FALCON - The Falcon Programming Language.
   FILE: vm.h

   Falcon virtual machine.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Sat, 08 Jan 2011 18:46:25 +0100

   -------------------------------------------------------------------
   (C) Copyright 2011: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

#ifndef FALCON_VM_H
#define FALCON_VM_H

#include <falcon/setup.h>
#include <falcon/item.h>
#include <falcon/codeframe.h>
#include <falcon/callframe.h>
#include <falcon/vmcontext.h>
#include <falcon/string.h>

#define FALCON_VM_DFAULT_CHECK_LOOPS 5000

namespace Falcon {

class Error;
class LocationInfo;
class Stream;
class TextReader;
class TextWriter;
class Transcoder;
class Module;
class Symbol;

/** The Falcon virtual machine.
*/
class FALCON_DYN_CLASS VMachine
{

public:
   /** Events that may cause VM suspension or interruption. */
   typedef enum {
      /** All green, go on. */
      eventNone,
      /** Debug Breakpoint reached -- return. */
      eventBreak,
      /** Explicit return frame hit -- return. */
      eventReturn,
      /** Quit request -- get out. */
      eventTerminate,
      /** All the code has been processed -- get out. */
      eventComplete,
      /** Soft error raised -- manage it internally if possible. */
      eventRaise
   } t_event;

   /** Creates the virtual machine.
    \param stdIn Standard input stream used by the VM; if 0, will take a duplicate
    of the process standard input stream.
    \param stdOut Standard output stream used by the VM; if 0, will take a duplicate
    of the process standard output stream.
    \param stdErr Standard input stream used by the VM; if 0, will take a duplicate
    of the process standard error stream.

    The streams passed to the constructor are property of the virtual machine;
    they get destroyed (and closed) with it.

    If the script that should be run by this virtual machine is seen as the
    foreground process, the creator of this virtual machine should pass standard
    stream instances not duplicating the standard streams, so that the script
    can close the VM streams and that behavior is reflected to the process streams.
    */
   VMachine( Stream* stdIn = 0, Stream* stdOut=0, Stream* stdErr = 0 );
   virtual ~VMachine();

   //=========================================================
   // Context management
   //=========================================================

   inline VMContext* currentContext() const { return m_context; }

   //=========================================================
   // Execution management.
   //=========================================================

   /** Runs a prepared code, or continues running.
    * @return True if all the code was executed, false if a breakpoint forced to stop.
    *
    * This method runs the virtual machine until:
    * - All the code in the code stack is executed; or
    * - a break flag is set.
    *
    * In the second case, the method returns false.
    *
    * Notice that the effect of exit() is that of terminating the VM
    * cleanly; this will make this function to return true.
    */
   bool run();

   /** Returns the last event that was raised in this VM.
      @return The last event generated by the vm.
    */
   inline t_event event() const { return m_event; }

   /** Raises an item, throwing a soft-exception.

    Throwing a C++ exception can be time consuming, and shouldn't be done lightly.
    In case of langauge generated exceptions, it is better to rasie an item thorugh
    a soft-signal, so that the VM can handle the raised exeption without the need for
    a full stack unroll and CPU level longjump management.

    If the VM can't handle the raised item, a GenericError will be thrown at C++
    level by the main loop.
    */
   void raiseItem( const Item& item );

   /** Raises an error, throwing a soft-exception.

    Throwing a C++ exception can be time consuming, and shouldn't be done lightly.
    In case of langauge generated exceptions, it is better to rasie an item thorugh
    a soft-signal, so that the VM can handle the raised exeption without the need for
    a full stack unroll and CPU level longjump management.

    This operation boxes the error by wrapping it in a falcon object instance
    (using the handler class that the error provides; namely, Error::scriptize()
    is called). This also increfs the error.

    If the VM can't handle the raised error, it will be unboxed and rethrown as-is.
    */
   void raiseError( Error* error );

   /** Asks for a light termination of the VM.
    The VM immediately returns to the caller. The event is sticky; this means
    that intermediate callers will see this event set and propagate it upwards.
    */
   inline void quit() { m_event = eventTerminate; }

   /** Asks the VM to exit from its main loop.

    This is generally handled by a specific opcode that asks for the VM to
    exit its current main loop. The opcode may be inserted by special
    "atomic" calls. When such a call is made, if the called function needs
    to ask the VM to perform some calculation, then it can add this opcode
    to the code stack to be called back when the calculation is done.

    This is meant to be used internally by the engine and shouldn't be
    tackled by modules or external code.

    To cause the code flow to be temporarily suspended at current point
    you may use the pushBreak() or pushReturn() methods, or otherwise push
    your own PStep taking care of breaking the code.
    */
   inline void setReturn() { m_event = eventReturn; }

   /** Resets the event.
   */
   inline void clearEvent() { m_event = eventNone; }

   /** Sets the complete event
   */
   inline void setComplete() { m_event = eventComplete; }


   //=========================================================
   // Debug support
   //=========================================================

   /** Returns the step that is going to be executed next, or null if none.
    \return The next step that will be executed.
    */
   const PStep* nextStep() const;

   /** Performs a single step.
      @return true if there is another step ready to be executed,
         false if this was the last (i.e. if the VM is terminated).
    */
   bool step();

   /** Activates a breakpoint.

      Breaks the current run loop. This is usually done by specific
      breakpoint opcodes that are inserted at certain points in the code
      to cause interruption for debug and inspection.

    To cause the code flow to be temporarily suspended at current point
    you may use the pushBreak() or pushReturn() methods, or otherwise push
    your own PStep taking care of breaking the code.

    The StmtBreakpoint can be inserted in source flows for this purpose.
   */
   inline void breakpoint() { m_event = eventBreak; }

      /** Gives a description of the location of the next step being executed.
    @return A string with a textual description of the source position of the
            next step being executed.

    This is a debug function used to indicate where is the next step being
    executed in a source file.
   */
   String location() const;

   /** Outlines VM status in a string.
    @return A string with a textual description of the VM status.

    This is a debug function used to indicate what's the current status of the
    virtual machine.
   */
   String report();

   /** Gives a description of the location of the next step being executed.
    @param infos An instance of LocationInfo receiving the debug information about
           the location in the source files of the next step.

    This information is more detailed and GUI oriented than the information
    returned by location().
    */
   bool location( LocationInfo& infos ) const;


   //=========================================================
   // General information.
   //=========================================================

   /** Raises a VM error.
    *
    * The method finds a try frame back in the code stack, and if it is found,
    * the control is moved to a suitable catch item.
    *
    * If a suitable catch frame is not found, the error is thrown as a C++ exception.
    *
    * \note Falcon exceptions are thrown by pointer. This is because the error entity
    * can be stored in several places, and in several threads, by the time it
    * surfaces to user code. This calls for reference management.
    */
   //void raiseError( Error* theError );


   /** Finds the variable corresponding to a symbol name in the current context.
    * @return A pointer to the item if found, 0 if not found.
    *
    * The search will be extended to global and imported symbols if the search
    * in the local symbol tables fails.
    */
   Item* findLocalItem( const String& name ) const;

   /** Finds a symbol that is globally exported or globally defined.
    \return The symbol, if defined or 0 if the name cannot be found.
    \param name The name of the symbol that is exported.
    
    */
   const Symbol* findExportedSymbol( const String& name ) const;

   /** Returns true if the current has not any code.

    */
   inline bool codeEmpty() const { return m_context->codeEmpty(); }

   /** Sets a value in the A register of the current context.
    \param v The return value.
    \deprecated  Kept for compatibility with engine 0.9.x

    This method sets a value in the A register of the current context.
    In the old vm 0.9.x this worked as a return value, and it is still
    interpreted this way in the implementation of the ExtFunction 
    class (which wraps the old functions).

    New code should use VMContext::returnFrame().
    */
   void retval( const Item& v ) { currentContext()->regA() = v; }


   /** Access the current context accumulator. */
   const Item& regA() const { return m_context->regA(); }
   /** Access the current context accumulator. */
   Item& regA() { return m_context->regA(); }

   /** Access the current "self" item. */
   const Item& self() const { return m_context->self(); }
   /** Access the current context "self" item. */
   Item& self() { return m_context->self(); }


   //=========================================================
   // VM Streams
   //=========================================================

   /** Changes the standard input stream. 
    Previously owned standard input stream is closed and destroyed.
    */
   void stdIn( Stream* s );

   /** Changes the standard output stream.
    Previously owned standard output stream is closed and destroyed.
    */
   void stdOut( Stream* s );

   /** Changes the standard error stream.
    Previously owned standard error stream is closed and destroyed.
    */
   void stdErr( Stream* s );

   /** Returns current standard input stream.
    \return A valid standard input stream, owned by the VM.
    If needed elsewhere, the stream must be cloned().
   */
   inline Stream* stdIn() const { return m_stdIn; }

   /** Returns current standard input stream.
    \return A valid standard output stream, owned by the VM.
    If needed elsewhere, the stream must be cloned().
   */
   inline Stream* stdOut() const { return m_stdOut; }

   /** Returns current standard error stream.
    \return A valid standard error stream, owned by the VM.
    If needed elsewhere, the stream must be cloned().
   */
   inline Stream* stdErr() const { return m_stdErr; }

   /** Sets the standard encoding of streams.
    \param Encoding name as ISO encoding name.
    \return false if the given encoding is currently not served by the engine.

    The VM offers an utility TextReader to read from its standard input
    and TextWriter wrappers to write to its standard output and error
    streams.

    Applications are not required to use this readers/writers, but
    the standard library text based I/O functions use them.

    The text readers/writers are initialized to the system encoding, if it is
    possible to detect it and if the Transcoder is present in the Engine at the
    moment of VM creation.

    It is possible to change the transcoder used by the standard library text
    I/O routines anytime through the setStdEncoding() method. It is also possible
    to provide a custom transcoder, that can be disposed by the VM.

    \note The text writers used by the VM set their CRLF automatic transcoding
    option according to the host system, and with automatic flush at end-of-line;
    to change this setup, act directly on the TextWriters.

    */
   bool setStdEncoding( const String& name );

    /** Sets the standard encoding of streams using a custom transcoder.
     \param ts A transcoder instance.
     \param bOwn If true, the transcoder will be disposed by the VM at destruction.
     \see bool setStdEncoding( const String& name )
     */
   void setStdEncoding( Transcoder* ts, bool bOwn = false );

   /** Returns the TextReader accessing the standard input stream.
    \return A text reder.
    \see setStdEncoding
    */
   inline TextReader* textIn() const { return m_textIn; }

   /** Returns the TextReader accessing the standard input stream.
    \return A text reder.
    \see setStdEncoding
    \note The text writers used by the VM set their CRLF automatic transcoding
    option according to the host system, and with automatic flush at end-of-line;
    to change this setup, act directly on the TextWriters.
    */
   inline TextWriter* textOut() const { return m_textOut; }

   /** Returns the TextReader accessing the standard input stream.
    \return A text reder.
    \see setStdEncoding
    \note The text writers used by the VM set their CRLF automatic transcoding
    option according to the host system, and with automatic flush at end-of-line;
    to change this setup, act directly on the TextWriters.
    */
   inline TextWriter* textErr() const { return m_textOut; }

   //=========================================================
   // VM Streams
   //=========================================================
   /** Links a module.
    \param mod The module to be linked.

    This method adds the module to the virtual machine, trying to find
    existing dependencies

    A module can be added only to a virtual machine. The virtual
    machine owns the module.

    \note currently a stub.
    */
   void link( Module* mod );

   //void enumerateUndefined( );

   /** Adds a symbol to the exported map. */
   bool addExportedSymbol( Module* mod, const Symbol* sym );

   /** Adds a link error.
    \param err_id Id of the error.
    \param mod The module where the error was found.
    \param sym The symbol that caused the error.
    \param extra Extra description.

    During the link process, multiple errors could be found.
    When the link process is complete, the Virtual Machine owner will
    call checkRun() that will throw an error.    
    */
   void addLinkError( int err_id, Module* mod, const Symbol* sym, const String& extra="" );

   /** Check if the VM is ready to run.
    \return A pointer to a throwable error if the virtual machine cannot be
    run, 0 if the VM is ready.
    
    This call performs checks on the current status of the virtual machine, and
    raises an error if:
    - There are pending link errors (usually duplicated symbols).
    - There are currently undefined symbols.
    
    This method can be called multiple times, in case new modules are added
    after run() is performed (even from inside a run), but 

    \note the call is threadsafe.
    */
   Error* checkRun();

protected:

   Stream *m_stdIn;
   Stream *m_stdOut;
   Stream *m_stdErr;

   TextReader* m_textIn;
   TextWriter* m_textOut;
   TextWriter* m_textErr;

   Transcoder* m_stdCoder;
   bool m_bOwnCoder;

   /** Called back when an error was thrown directly inside the machine.
    \param e The error being thrown.
    */
   void onError( Error* e );

   /** Called back after the main loop gets a raiseItem().
    \param item The item being raised.
    */
   void onRaise( const Item& item );

private:
   
   // current context
   VMContext* m_context;

   // last raised event.
   t_event m_event;

   class Private;
   Private* _p;
};

}

#endif

/* end of vm.h */
