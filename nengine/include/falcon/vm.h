/*
   FALCON - The Falcon Programming Language.
   FILE: vm.h

   Falcon virtual machine.
   -------------------------------------------------------------------
   Author: Giancarlo Niccolai
   Begin: Sat, 08 Jan 2011 18:46:25 +0100

   -------------------------------------------------------------------
   (C) Copyright 2011: the FALCON developers (see list in AUTHORS file)

   See LICENSE file for licensing details.
*/

#ifndef FALCON_VM_H
#define FALCON_VM_H

#include <falcon/setup.h>
#include <falcon/item.h>
#include <falcon/codeframe.h>
#include <falcon/callframe.h>
#include <falcon/vmcontext.h>
#include <falcon/string.h>

#define FALCON_VM_DFAULT_CHECK_LOOPS 5000

namespace Falcon {

class Error;
class LocationInfo;

/** The Falcon virtual machine.
*/
class FALCON_DYN_CLASS VMachine
{

public:
   /** Events that may cause VM suspension or interruption. */
   typedef enum {
      /** All green, go on. */
      eventNone,
      /** Debug Breakpoint reached -- return. */
      eventBreak,
      /** Explicit return frame hit -- return. */
      eventReturn,
      /** Quit request -- get out. */
      eventTerminate,
      /** All the code has been processed -- get out. */
      eventComplete,
      /** Soft error raised -- manage it internally if possible. */
      eventRaise
   } t_event;

   VMachine();
   virtual ~VMachine();

   //=========================================================
   // Context management
   //=========================================================

   inline VMContext* currentContext() const { return m_context; }

   //=========================================================
   // Execution management.
   //=========================================================

   /** Runs a prepared code, or continues running.
    * @return True if all the code was executed, false if a breakpoint forced to stop.
    *
    * This method runs the virtual machine until:
    * - All the code in the code stack is executed; or
    * - a break flag is set.
    *
    * In the second case, the method returns false.
    *
    * Notice that the effect of exit() is that of terminating the VM
    * cleanly; this will make this function to return true.
    */
   bool run();

   inline void call( Function* f, int np )
   {
      call( f, np, Item() );
   }

   /** Prepares the VM to execute a function (actually, a method).

    The VM gets readied to execute the function from the next step,
    which may be invoked via step(), run() or by returning from the caller
    of this function in case the caller has been invoked by the VM itself.
    @param function The function to be invoked.
    @param np Number of parameters that must be already in the stack.
    @param self The item on which this method is invoked. Pure functions are
                considered methods of "nil".
    */
   virtual void call( Function* function, int np, const Item& self );

   /** Returns from the current frame */
   void returnFrame();

   /** Returns the step that is going to be executed next, or null if none */
   const PStep* nextStep() const;

   /** Performs a single step.
    * @return true if there is another step ready to be executed,
    * false if this was the last (i.e. if the VM is terminated).
    */
   bool step();


   /** Raises a VM error.
    *
    * The method finds a try frame back in the code stack, and if it is found,
    * the control is moved to a suitable catch item.
    *
    * If a suitable catch frame is not found, the error is thrown as a C++ exception.
    *
    * \note Falcon exceptions are thrown by pointer. This is because the error entity
    * can be stored in several places, and in several threads, by the time it
    * surfaces to user code. This calls for reference management.
    */
   //void raiseError( Error* theError );


   /** Finds the variable corresponding to a symbol name in the current context.
    * @return A pointer to the item if found, 0 if not found.
    *
    * The search will be extended to global and imported symbols if the search
    * in the local symbol tables fails.
    */
   Item* findLocalItem( const String& name );

   /** Returns true if the current has not any code.

    */
   inline bool codeEmpty() const { return m_context->codeEmpty(); }

   /** Access the current context accumulator. */
   const Item& regA() const { return m_context->regA(); }
   /** Access the current context accumulator. */
   Item& regA() { return m_context->regA(); }

   /** Returns the last event that was raised in this VM.
      @return The last event generated by the vm.
    */
   inline t_event event() const { return m_event; }

   /** Raises an item, throwing a soft-exception.

    Throwing a C++ exception can be time consuming, and shouldn't be done lightly.
    In case of langauge generated exceptions, it is better to rasie an item thorugh
    a soft-signal, so that the VM can handle the raised exeption without the need for
    a full stack unroll and CPU level longjump management.

    If the VM can't handle the raised item, a GenericError will be thrown at C++
    level by the main loop.
    */
   void raiseItem( const Item& item );

   /** Asks for a light termination of the VM.
    The VM immediately returns to the caller. The event is sticky; this means
    that intermediate callers will see this event set and propagate it upwards.
    */
   inline void quit() { m_event = eventTerminate; }
   
   /** Asks the VM to exit from its main loop.
    
    This is generally handled by a specific opcode that asks for the VM to
    exit its current main loop. The opcode may be inserted by special 
    "atomic" calls. When such a call is made, if the called function needs
    to ask the VM to perform some calculation, then it can add this opcode
    to the code stack to be called back when the calculation is done.
    
    This is meant to be used internally by the engine and shouldn't be
    tackled by modules or external code.
    */
   inline void setReturn() { m_event = eventReturn; }


   /** Activates a breakpoint.
    
      Breaks the current run loop. This is usually done by specific
      breakpoint opcodes that are inserted at certain points in the code
      to cause interruption for debug and inspection.
   */
   inline void breakpoint() { m_event = eventBreak; }


   /** Resets the event.
   */
   inline void clearEvent() { m_event = eventNone; }

   /** Gives a description of the location of the next step being executed.
    @return A string with a textual description of the source position of the
            next step being executed.

    This is a debug function used to indicate where is the next step being
    executed in a source file.
   */
   String location() const;

   /** Outlines VM status in a string.
    @return A string with a textual description of the VM status.

    This is a debug function used to indicate what's the current status of the
    virtual machine.
   */
   String report();

   /** Gives a description of the location of the next step being executed.
    @param infos An instance of LocationInfo receiving the debug information about
           the location in the source files of the next step.

    This information is more detailed and GUI oriented than the information
    returned by location().
    */
   bool location( LocationInfo& infos ) const;

protected:

   Stream *m_stdIn;
   Stream *m_stdOut;
   Stream *m_stdErr;
   bool m_bhasStandardStreams;

   void internal_construct();

   /** Called back when an error was thrown directly inside the machine */
   void onError( Error* e );

   /** Called back after the main loop gets a raiseItem() */
   void onRaise( const Item& item );

private:
   // current context
   VMContext* m_context;
   // last raised event.
   t_event m_event;
};

}

#endif

/* end of vm.h */
